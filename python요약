<< Python 요약>>

○ 파이션의 특징
 - 파이썬은 C보다 훨씬 많은 에러 검사를 제공하고, 유연한 배열과 딕셔너리같은 고수준의 자료형들을 내장
 - 대규모의 표준 모듈들이 따라오는데 파일 입출력, 시스템 호출, 소켓들이 포함되는데, 심지어 Tk 와 같은 GUI 도구상자에 대한 인터페이스도 들어있음
 - C, C++, Java 프로그램들에 비교해 간결함
   . 고수준의 자료형 때문에 복잡한 연산을 한 문장으로 표현할 수 있음
   . 문장의 묶음은 괄호 대신에 들여쓰기를 통해 이루어짐
   . 변수나 인자의 선언이 필요 없음
 
 ○ 파이썬 인터프리터
  - py.exe
  - python -c command [arg] ...
  - python -m module [arg] ...
  -기본 프롬프트에서 EOF(end-of-file) 문자(유닉스에서는 Control-D, 윈도우에서는 Control-Z)를 입력하면 인터프리터가 종료하고, 종료 상태 코드는 0 이 됩니다. 이 방법이 통하지 않는다면 quit() 명령을 입력해서 인터프리터를 종료시킬 수 있습니다.
  - 대화형 모드 -i
  - -c command 가 사용되면 sys.argv[0] 는 '-c' 로 설정됩니다. -m module 이 사용되면 sys.argv[0] 는 모듈의 절대 경로명이 됨

○ 소스코드 인코딩
 - 기본적으로, 파이썬 소스 파일들은 UTF-8으로 인코드 된 것으로 취급됩니다. 이 인코딩에서는 대부분 언어에서 사용되는 문자들을 문자열 상수, 식별자, 주석 등에서 함께 사용할 수 있습니다. (하지만 표준 라이브러리는 오직 ASCII 문자만 식별자로 사용하고 있는데, 범용 코드에서는 이 관례를 따르는 것이 좋습니다.)
 - 유닉스에서, 파이썬 3.x 인터프리터는 보통 python 이라는 이름의 실행 파일로 설치되지 않는데, 동시에 설치되는 파이썬 2.x 실행 파일과 충돌하지 않도록 하기 위해섭니다. (예: python3.8)

○ 파이썬의 소개
 - 주석은 해시 문자, #, 로 시작하고 줄의 끝까지 이어짐
 - 나눗셈 (/) 은 항상 float를 돌려줌
 - 정수 나눗셈 으로 (소수부 없이) 정수 결과를 얻으려면 // 연산자를 사용하면 됨
   나머지를 얻으려면 % 를 사용할 수 있음
 - 정수 (예를 들어 2, 4, 20)는 int 형입니다. 소수부가 있는 것들 (예를 들어 5.0, 1.6)은 float 형입니다.
 - 대화형 모드에서는, 마지막에 인쇄된 표현식은 변수 _ 에 대입됨
 - int 와 float 에 더해, 파이썬은 Decimal 이나 Fraction 등의 다른 형의 숫자들도 지원합니다. 파이썬은 복소수 에 대한 지원도 내장하고 있는데, 허수부를 가리키는데 j 나 J 접미사를 사용합니다 (예를 들어 3+5j).
 - 대화형 인터프리터에서, 출력 문자열은 따옴표로 둘러싸여 있고, 특수 문자들은 역 슬래시로 이스케이핑 됩니다. 때로 입력한 것과 달라 보여도 (따옴표의 종류가 바뀔 수 있다), 두 문자열은 동등합니다. 문자열이 작은따옴표를 포함하고 큰따옴표를 포함하지 않으면 큰따옴표가 사용되고, 그 외의 경우는 작은따옴표가 사용됩니다. print() 함수는 따옴표를 생략하고, 이스케이핑된 특수 문자를 출력해서 더 읽기 쉬운 출력을 만들어냅니다:
 - \ 뒤에 나오는 문자가 특수 문자로 취급되게 하고 싶지 않다면, 첫 따옴표 앞에 r 을 붙여서 날 문자열 (raw string) 을 만들 수 있습니다:
 - 문자열 리터럴은 여러 줄로 확장될 수 있습니다. 한 가지 방법은 삼중 따옴표를 사용하는 것입니다: """...""" 또는 '''...'''. 줄 넘김 문자는 자동으로 문자열에 포함됩니다. 하지만 줄 끝에 \ 를 붙여 이를 방지할 수도 있습니다.
 - 문자열은 + 연산자로 이어붙이고, * 연산자로 반복시킬 수 있습니다:
 - 두 개 이상의 문자열 리터럴 (즉, 따옴표로 둘러싸인 것들) 가 연속해서 나타나면 자동으로 이어 붙여집니다.
 - 이것은 오직 두 개의 리터럴에만 적용될 뿐 변수나 표현식에는 해당하지 않습니다
 - 변수들끼리 혹은 변수와 문자열 리터럴을 이어붙이려면 + 를 사용해야 합니다
 - 문자열은 인덱스 (서브 스크립트) 될 수 있습니다. 첫 번째 문자가 인덱스 0에 대응됩니다. 
 - 음의 인덱스는 -1에서 시작한다
 - 슬라이싱(slicing)도 지원
 - 시작 위치의 문자는 항상 포함되는 반면, 종료 위치의 문자는 항상 포함되지 않는 것에 
   주의하세요.
   +---+---+---+---+---+---+
   | P | y | t | h | o | n |
   +---+---+---+---+---+---+
   0   1   2   3   4   5   6
  -6  -5  -4  -3  -2  -1
 - 너무 큰 값을 인덱스로 사용하는 것은 에러, 하지만, 범위를 벗어나는 슬라이스 인덱스는 슬라이싱할 때 부드럽게 처리됩니다
 - 파이썬 문자열은 변경할 수 없다 ? 불변
 - 내장 함수 len() 은 문자열의 길이를 돌려줍니다

○ 리스트
 - 대괄호 사이에 쉼표로 구분된 값(항목)들의 목록으로 표현될 수 있습니다. 리스트는 서로 다른 형의 항목들을 포함할 수 있지만, 항목들이 모두 같은 형인 경우가 많습니다.
 - 문자열(그리고, 다른 모든 내장 시퀀스 형들)처럼 리스트는 인덱싱하고 슬라이싱할 수 있습니다
 - 모든 슬라이스 연산은 요청한 항목들을 포함하는 새 리스트를 돌려줍니다
 - 리스트는 이어붙이기 같은 연산도 지원합니다. squares + [36, 49, 64, 81, 100]
 - 리스트는 가변 입니다. 즉 내용을 변경할 수 있습니다
 - append() 메서드 (method) (나중에 메서드에 대해 더 자세히 알아볼 것입니다) 를 사용하면 리스트의 끝에 새 항목을 추가할 수 있습니다
 - 슬라이스에 대입하는 것도 가능한데, 리스트의 길이를 변경할 수 있고, 모든 항목을 삭제할 수조차 있습니다
   . letters[2:5] = ['C', 'D', 'E']
   . letters[:] = []
 - 내장 함수 len() 은 리스트에도 적용됩니다
 - 리스트를 중첩할 수도 있습니다
  >>> a = ['a', 'b', 'c']
  >>> n = [1, 2, 3]
  >>> x = [a, n]
  >>> x
  [['a', 'b', 'c'], [1, 2, 3]]
  >>> x[0]
  ['a', 'b', 'c']
  >>> x[0][1]
  'b'
 - print() 함수는 주어진 인자들의 값을 인쇄합니다. 
 - 키워드 인자 end 는 출력 끝에 포함되는 개행문자를 제거하거나 출력을 다른 문자열로 끝나게 하고 싶을 때 사용됩니다:
  >>> a, b = 0, 1
  >>> while a < 1000:
  ...     print(a, end=',')
  ...     a, b = b, a+b

 - 다른 언어들과는 달리, `` `` 과 같은 특수 문자들은 작은따옴표('...')와 
   큰따옴표("...")에서 같은 의미가 있습니다. 둘 간의 유일한 차이는 작은따옴표 안에서 
   " 를 이스케이핑할 필요가 없고 (하지만 \' 는 이스케이핑 시켜야 합니다), 
   그 역도 성립한다는 것입니다.

○ if 문
  if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x == 0:
  ...     print('Zero')
  ... elif x == 1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...
  More

○ for 문
 - for 문은 임의의 시퀀스 (리스트나 문자열)의 항목들을 그 시퀀스에 들어있는 순서대로 이터레이션 합니다
  >>> # Measure some strings:
  ... words = ['cat', 'window', 'defenestrate']
  >>> for w in words:
  ...     print(w, len(w))
  ...
  cat 3
  window 6
  defenestrate 12
 - 숫자들의 시퀀스로 이터레이트할 필요가 있으면, 내장 함수 range()가 편리합니다
  >>> for i in range(5):
  ...     print(i)
  ...
  0
  1
  2
  3
  4

  range(5, 10)
     5, 6, 7, 8, 9

  range(0, 10, 3)
     0, 3, 6, 9

  range(-10, -100, -30)
    -10, -40, -70

 - 시퀀스의 인덱스들로 이터레이트 하려면, 다음처럼 range()와 len() 을 결합할 수 있습니다
  >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
  >>> for i in range(len(a)):
  ...     print(i, a[i])
  ...
  0 Mary
  1 had
  2 a
  3 little
  4 lamb

  >>> for i, v in enumerate(['tic', 'tac', 'toe']):
  ...     print(i, v)
  ...
  0 tic
  1 tac
  2 toe

 - 많은 경우에 range()가 돌려준 객체는 리스트인 것처럼 동작하지만, 
 - 사실 리스트가 아닙니다. 이터레이트할 때 원하는 시퀀스 항목들을 
   순서대로 돌려주는 객체이지만, 실제로 리스트를 만들지 않아서 공간을 
   절약합니다.
 - 이런 객체를 이터러블 이라고 부릅니다. 공급이 소진될 때까지 일련의 
   항목들을 얻을 수 있는 무엇인가를 기대하는 함수와 구조물들의 타깃으로 
   적합합니다. 우리는 for 문이 그런 구조물임을 보았습니다. 이터러블을 취하는 함수의 예는 sum()입니다:
  >>>
  >>> sum(range(4))  # 0 + 1 + 2 + 3
  6
 - 나중에 이터러블을 돌려주고 이터러블을 인자로 받는 함수들을 더 보게 됩니다. 
   마지막으로, range에서 리스트를 얻는 방법에 대해 궁금할 것입니다. 
   이렇게 합니다:
  >>>
  >>> list(range(4))
  [0, 1, 2, 3]

 - break 문은, C처럼, 가장 가까이서 둘러싸는 for 나 while 루프로부터 빠져나가게 만듭니다.
 - 루프 문은 else 절을 가질 수 있습니다; 루프가 이터러블의 소진이나 (for의 경우) 조건이 
   거짓이 돼서 (while의 경우) 종료할 때 실행됩니다. 하지만 루프가 break 문으로 종료할 때는
   실행되지 않습니다. 소수를 찾는 루프를 통해 다음에서 예시합니다:
  >>> for n in range(2, 10):
  ...     for x in range(2, n):
  ...         if n % x == 0:
  ...             print(n, 'equals', x, '*', n//x)
  ...             break
  ...     else:
  ...         # loop fell through without finding a factor
  ...         print(n, 'is a prime number')
  ...
  2 is a prime number
  3 is a prime number
  4 equals 2 * 2
  5 is a prime number
  6 equals 2 * 3
  7 is a prime number
  8 equals 2 * 4
  9 equals 3 * 3

 - try 문의 else 절은 예외가 발생하지 않을 때 실행되고, 루프의 else 절은 break가 발생하지 않을 때 실행됩니다
 - continue 문은, 역시 C에서 빌렸습니다, 루프의 다음 이터레이션에서 계속하도록 만듭니다

○ pass 문
 - pass 문은 아무것도 하지 않습니다. 문법적으로 문장이 필요하지만, 프로그램이 특별히 
   할 일이 없을 때 사용할 수 있습니다
  >>> while True:
  ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
  ...
  
  >>> class MyEmptyClass:
  ...     pass
  ...
  
  >>> def initlog(*args):
  ...     pass   # Remember to implement this!
  ...

○ 함수 정의하기
  >>> def fib(n):    # write Fibonacci series up to n
  ...     """Print a Fibonacci series up to n."""
  ...     a, b = 0, 1
  ...     while a < n:
  ...         print(a, end=' ')
  ...         a, b = b, a+b
  ...     print()
  ...
  >>> # Now call the function we just defined:
  ... fib(2000)
  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
  
 - 함수의 실행은 함수의 지역 변수들을 위한 새 심볼 테이블을 만듭니다. 
   좀 더 구체적으로, 함수에서의 모든 변수 대입들은 값을 지역 심볼 테이블에 저장합니다; 
   반면에 변수 참조는 먼저 지역 심볼 테이블을 본 다음, 전역 심볼 테이블을 본 후, 
   마지막으로 내장 이름들의 테이블을 살핍니다. 그래서, 참조될 수는 있다 하더라도, 
   전역 변수들과 둘러싸는 함수의 변수들은 함수 내에서 직접 값이 대입될 수 없습니다 
   (전역 변수를 global 문으로 명시하거나 둘러싸는 함수의 변수를 nonlocal 문으로 명시하지 
   않는 이상).
 - 함수 호출로 전달되는 실제 매개변수들 (인자들)은 호출될 때 호출되는 함수의 지역 심볼 
   테이블에 만들어집니다; 그래서 인자들은 값에 의한 호출(call by value)로 전달됩니다 
   (값은 항상 객체의 값이 아니라 객체 참조입니다). 
   함수가 다른 함수를 호출할 때, 그 호출을 위한 새 지역 심볼 테이블이 만들어집니다.
 - 함수 정의는 현재 심볼 테이블에 함수 이름을 만듭니다. 
   함수 이름의 값은 인터프리터가 사용자 정의 함수로 인식하는 형입니다. 
   이 값은 다른 이름에 대입될 수 있는데, 이 역시 함수로 사용될 수 있습니다. 
   이것이 이름을 바꾸는 일반적인 방법입니다
  >>> fib
  <function fib at 10042ed0>
  >>> f = fib
  >>> f(100)
  0 1 1 2 3 5 8 13 21 34 55 89

  >>> def fib2(n):  # return Fibonacci series up to n
  ...     """Return a list containing the Fibonacci series up to n."""
  ...     result = []
  ...     a, b = 0, 1
  ...     while a < n:
  ...         result.append(a)    # see below
  ...         a, b = b, a+b
  ...     return result
  ...
  >>> f100 = fib2(100)    # call it
  >>> f100                # write the result
  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

 - return 문은 함수로부터 값을 갖고 복귀하게 만듭니다. 표현식 인자 없는 return 은 None을 돌려줍니다. 함수의 끝으로 떨어지면 역시 None을 돌려줍니다

○ 기본 인자 값
  def ask_ok(prompt, retries=4, reminder='Please try again!'):
      while True:
          ok = input(prompt)
          if ok in ('y', 'ye', 'yes'):
              return True
          if ok in ('n', 'no', 'nop', 'nope'):
              return False
          retries = retries - 1
          if retries < 0:
              raise ValueError('invalid user response')
          print(reminder)

 - 기본값은 함수 정의 시점에 정의되고 있는 스코프에서 구해집니다
  i = 5

  def f(arg=i):
      print(arg)
  i = 6
  f()
  는 5를 인쇄함

 - 기본값은 오직 한 번만 값이 구해집니다. 이것은 기본값이 리스트나 딕셔너리나 대부분 
   클래스의 인스턴스와 같은 가변 객체일 때 차이를 만듭니다. 예를 들어, 다음 함수는 
   계속되는 호출로 전달된 인자들을 누적합니다:

  def f(a, L=[]):
      L.append(a)
      return L

  print(f(1))
  print(f(2))
  print(f(3))
  다음과 같은 것을 인쇄합니다
  [1]
  [1, 2]
  [1, 2, 3]

 - 연속된 호출 간에 기본값이 공유되지 않기를 원한다면, 대신 함수를 이런 식으로 쓸 수 있습니다:

def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L

 - 함수는 kwarg=value 형식의 키워드 인자 를 사용해서 호출될 수 있습니다

 - **name 형식의 마지막 형식 매개변수가 존재하면, 형식 매개변수들에 대응하지 않는 
   모든 키워드 인자들을 담은 딕셔너리 (매핑 형 ? dict 를 보세요) 를 받습니다. 
   이것은 *name (다음 서브섹션에서 설명합니다) 형식의 형식 매개변수와 조합될 수 있는데, 
   형식 매개변수 목록 밖의 위치 인자들을 담은 튜플을 받습니다. 
   (*name은 **name 앞에 나와야 합니다.) 예를 들어, 이런 함수를 정의하면:
  def cheeseshop(kind, *arguments, **keywords):
      print("-- Do you have any", kind, "?")
      print("-- I'm sorry, we're all out of", kind)
      for arg in arguments:
          print(arg)
      print("-" * 40)
      for kw in keywords:
          print(kw, ":", keywords[kw])
   이런 식으로 호출될 수 있습니다:

  cheeseshop("Limburger", "It's very runny, sir.",
             "It's really very, VERY runny, sir.",
             shopkeeper="Michael Palin",
             client="John Cleese",
             sketch="Cheese Shop Sketch")
   그리고 당연히 이렇게 인쇄합니다:
  -- Do you have any Limburger ?
  -- I'm sorry, we're all out of Limburger
  It's very runny, sir.
  It's really very, VERY runny, sir.
  ----------------------------------------
  shopkeeper : Michael Palin
  client : John Cleese
  sketch : Cheese Shop Sketch
   인쇄되는 키워드 인자들의 순서 함수 호출로 전달된 순서와 일치함이 보장됨에 주목하세요.

○ 특수 매개 변수
  def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
        -----------    ----------     ----------
          |             |                  |
          |        Positional or keyword   |
          |                                - Keyword only
           -- Positional only
 - 함수 정의에 /와 *가 없으면, 인자를 위치나 키워드로 함수에 전달
 - 함수 정의에 /가 없으면, 위치 전용 매개 변수는 없습니다.
 - 첫번째 키워드 전용 매개 변수 바로 전에 인자 목록에 *를 넣음
 - 마지막으로, 위치 인자 name과 name을 키로 가지는 **kwds 사이에 잠재적인 충돌이 있는 
   이 함수 정의를 고려하십시오:
  def foo(name, **kwds):
      return 'name' in kwds
   'name' 키워드는 항상 첫 번째 매개 변수에 결합하므로 True를 반환할 수 있는 호출은 
   불가능합니다. 예를 들면:
  >>>
  >>> foo(1, **{'name': 2})
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: foo() got multiple values for argument 'name'
  >>>

 - 그러나 /(위치 전용 인자)를 사용하면, name을 위치 인자로, 
   동시에 'name'을 키워드 인자의 키로 사용할 수 있으므로 가능합니다:
  def foo(name, /, **kwds):
      return 'name' in kwds
  >>> foo(1, **{'name': 2})
  True
   즉, 위치 전용 매개 변수의 이름을 **kwds에서 모호함 없이 사용할 수 있습니다.

○ 임의의 인자 목록
  def write_multiple_items(file, separator, *args):
      file.write(separator.join(args))
 - 가변 길이 인자들은 형식 매개변수 목록의 마지막에 옵니다, 함수로 전달된 남은 입력 인자들
   전부를 그러모으기 때문입니다. *args 매개변수 뒤에 등장하는 형식 매개변수들은 모두 
   〈키워드-전용〉 인자들인데, 위치 인자 대신 키워드 인자로만 사용될 수 있다는 뜻입니다
  >>> def concat(*args, sep="/"):
  ...     return sep.join(args)
  ...
  >>> concat("earth", "mars", "venus")
  'earth/mars/venus'
  >>> concat("earth", "mars", "venus", sep=".")
  'earth.mars.venus'

○ 인자 목록 언 패킹
 - 리스트와 튜플로부터 인자를 언 패킹하기 위해 *-연산자를 사용해서 함수를 호출하면 됩니다
  >>> list(range(3, 6))            # normal call with separate arguments
  [3, 4, 5]
  >>> args = [3, 6]
  >>> list(range(*args))            # call with arguments unpacked from a list
  [3, 4, 5]

 - 같은 방식으로 딕셔너리도 **연산자를 써서 키워드 인자를 전달할 수 있음
  >>> def parrot(voltage, state='a stiff', action='voom'):
  ...     print("-- This parrot wouldn't", action, end=' ')
  ...     print("if you put", voltage, "volts through it.", end=' ')
  ...     print("E's", state, "!")
  ...
  >>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
  >>> parrot(**d)
  -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !

○ 람다 표현식
 - lambda 키워드들 사용해서 작고 이름 없는 함수를 만들 수 있습니다. 
 - 이 함수는 두 인자의 합을 돌려줍니다: lambda a, b: a+b. 함수 객체가 
   있어야 하는 곳이면 어디나 람다 함수가 사용될 수 있습니다. 문법적으로는 
   하나의 표현식으로 제한됩니다. 의미적으로는, 일반적인 함수 정의의 편의 
   문법일 뿐입니다. 중첩된 함수 정의처럼, 람다 함수는 둘러싸는 스코프에 있는 
   변수들을 참조할 수 있습니다:
  >>> def make_incrementor(n):
  ...     return lambda x: x + n
  ...
  >>> f = make_incrementor(42)
  >>> f(0)
  42
  >>> f(1)
  43
 - 위의 예는 함수를 돌려주기 위해 람다 표현식을 사용합니다. 또 다른 용도는 작은 함수를 인자로 전달하는 것입니다:

>>>
>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

○ 도큐멘테이션 문자열
 - 첫 줄은 항상 객체의 목적을 짧고, 간결하게 요약해야 합니다. 간결함을 위해, 객체의 이름이나 형을 명시적으로 언급하지 않아야 하는데, 이것들은 다른 방법으로 제공되기 때문입니다 (이름이 함수의 작업을 설명하는 동사라면 예외입니다). 이 줄은 대문자로 시작하고 마침표로 끝나야 합니다.
 - 도큐멘테이션 문자열에 여러 줄이 있다면, 두 번째 줄은 비어있어서, 시각적으로 요약과 나머지 설명을 분리해야 합니다. 뒤따르는 줄들은 하나나 그 이상의 문단으로, 객체의 호출 규약, 부작용 등을 설명해야 합니다.
 - 파이썬 파서는 여러 줄 문자열 리터럴에서 들여쓰기를 제거하지 않기 때문에, 설명서를 처리하는 도구들은 필요하면 들여쓰기를 제거합니다. 이것은 다음과 같은 관례를 사용합니다. 문자열의 첫줄 뒤에 오는 첫 번째 비어있지 않은 줄이 전체 도튜멘테이션 문자열의 들여쓰기 수준을 결정합니다. (우리는 첫 줄을 사용할 수 없는데, 일반적으로 문자열을 시작하는 따옴표에 붙어있어서 들여쓰기가 문자열 리터럴의 것을 반영하지 않기 때문입니다.) 이 들여쓰기와 《동등한》 공백이 문자열의 모든 줄의 시작 부분에서 제거됩니다. 덜 들여쓰기 된 줄이 나타나지는 말아야 하지만, 나타난다면 모든 앞부분의 공백이 제거됩니다. 공백의 동등성은 탭 확장 (보통 8개의 스페이스) 후에 검사됩니다.

>>> def my_function():
...     """Do nothing, but document it.
...
...     No, really, it doesn't do anything.
...     """
...     pass
...
>>> print(my_function.__doc__)
Do nothing, but document it.

    No, really, it doesn't do anything.

○ 함수 어노테이션
 - 함수 어노테이션 은 사용자 정의 함수가 사용하는 형들에 대한 완전히 선택적인 
   메타데이터 정보입니다
 - 어노테이션은 함수의 __annotations__ 어트리뷰트에 딕셔너리로 저장되고 
   함수의 다른 부분에는 아무런 영향을 미치지 않습니다. 
 - 매개변수 어노테이션은 매개변수 이름 뒤에 오는 콜론으로 정의되는데, 
   값을 구할 때 어노테이션의 값을 주는 표현식이 뒤따릅니다. 
 - 반환 값 어노테이션은 리터럴 -> 와 그 뒤를 따르는 표현식으로 정의되는데, 
   매개변수 목록과 def 문의 끝을 나타내는 콜론 사이에 놓입니다. 
 - 다음 예에서 위치 인자, 키워드 인자, 반환 값이 어노테이트 됩니다:
  >>> def f(ham: str, eggs: str = 'eggs') -> str:
  ...     print("Annotations:", f.__annotations__)
  ...     print("Arguments:", ham, eggs)
  ...     return ham + ' and ' + eggs
  ...
  >>> f('spam')
  Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
  Arguments: spam eggs
  'spam and eggs'

○ 코딩 스타일
 - 들려 쓰기에 4-스페이스를 사용하고, 탭을 사용하지 마세요.
 - 79자를 넘지 않도록 줄 넘김 하세요.
 - 함수, 클래스, 함수 내의 큰 코드 블록 사이에 빈 줄을 넣어 분리하세요.
 - 가능하다면, 주석은 별도의 줄로 넣으세요.
 - 독스트링을 사용하세요.
 - 연산자들 주변과 콤마 뒤에 스페이스를 넣고, 괄호 바로 안쪽에는 스페이스를 넣지 마세요: a = f(1, 2) + g(3, 4).
 - 클래스와 함수들에 일관성 있는 이름을 붙이세요; 관례는 클래스의 경우 UpperCamelCase, 함수와 메서드의 경우 lowercase_with_underscores입니다. 첫 번째 메서드 인자의 이름으로는 항상 self를 사용하세요 (클래스와 메서드에 대한 자세한 내용은 클래스와의 첫 만남 을 보세요).
 - 여러분의 코드를 국제적인 환경에서 사용하려고 한다면 특별한 인코딩을 사용하지 마세요. 어떤 경우에도 파이썬의 기본, UTF-8, 또는 단순 ASCII조차, 이 최선입니다.
 - 마찬가지로, 다른 언어를 사용하는 사람이 코드를 읽거나 유지할 약간의 가능성만 있더라도, 식별자에 ASCII 이외의 문자를 사용하지 마세요.


○ 리스트
 - insert, remove, sort 같은 메서드들이 리스트를 수정할 뿐 반환 값이 출력되지
   않는 것을 알아챘을 것입니다. 기본 None 을 돌려주고 있습니다.
   이것은 파이썬에서 모든 가변 자료 구조들에 적용되는 설계 원리입니다.
 - 정수를 문자열과 비교할 수 없고 None을 다른 형과 비교할 수 없기 때문에 
   [None, 'hello', 10]는 정렬되지 않습니다. 또한 정의된 대소 관계가 없는 형이 
   있습니다. 예를 들어, 3+4j < 5+7j는 올바른 비교가 아닙니다.
  >>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
  >>> fruits.count('apple')
  2
  >>> fruits.count('tangerine')
  0
  >>> fruits.index('banana')
  3
  >>> fruits.index('banana', 4)  # Find next banana starting a position 4
  6
  >>> fruits.reverse()
  >>> fruits
  ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
  >>> fruits.append('grape')
  >>> fruits
  ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
  >>> fruits.sort()
  >>> fruits
  ['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
  >>> fruits.pop()
  'pear'

 - 큐 사용하기
  >>> from collections import deque
  >>> queue = deque(["Eric", "John", "Michael"])
  >>> queue.append("Terry")           # Terry arrives
  >>> queue.append("Graham")          # Graham arrives
  >>> queue.popleft()                 # The first to arrive now leaves
  'Eric'
  >>> queue.popleft()                 # The second to arrive now leaves
  'John'
  >>> queue                           # Remaining queue in order of arrival
  deque(['Michael', 'Terry', 'Graham'])

 - 리스트 컴프리헨션
  >>> squares = []
  >>> for x in range(10):
  ...     squares.append(x**2)
  ...
  >>> squares
  [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  
  squares = list(map(lambda x: x**2, range(10)))
  
  squares = [x**2 for x in range(10)]
  
  >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
  [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
  
  >>> combs = []
  >>> for x in [1,2,3]:
  ...     for y in [3,1,4]:
  ...         if x != y:
  ...             combs.append((x, y))
  ...
  >>> combs
  [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
 - 표현식이 튜플이면 (즉 앞의 예에서 (x, y)), 반드시 괄호로 둘러싸야 합니다
  >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
  >>> [weapon.strip() for weapon in freshfruit]
  ['banana', 'loganberry', 'passion fruit']
  
  >>> # the tuple must be parenthesized, otherwise an error is raised
  >>> [x, x**2 for x in range(6)]
    File "<stdin>", line 1, in <module>
      [x, x**2 for x in range(6)]
               ^
  SyntaxError: invalid syntax
  >>> # flatten a list using a listcomp with two 'for'
  >>> vec = [[1,2,3], [4,5,6], [7,8,9]]
  >>> [num for elem in vec for num in elem]
  [1, 2, 3, 4, 5, 6, 7, 8, 9]
  >>> [num for num in elem for elem in vec]
  [7, 7, 7, 8, 8, 8, 9, 9, 9]

 - 리스트 컴프리헨션은 복잡한 표현식과 중첩된 함수들을 포함할 수 있습니다:
  >>> from math import pi
  >>> [str(round(pi, i)) for i in range(1, 6)]
  ['3.1', '3.14', '3.142', '3.1416', '3.14159']

  >>> matrix = [
  ...     [1, 2, 3, 4],
  ...     [5, 6, 7, 8],
  ...     [9, 10, 11, 12],
  ... ]

>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
 - 앞절에서 보았듯이, 중첩된 리스트 컴프리헨션은 뒤따르는 for 의 문맥에서 값이 
   구해집니다.
  >>> list(zip(*matrix))
  [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]

 - del 문은 리스트에서 슬라이스를 삭제하거나 전체 리스트를 비우는 데도 사용될 수 있습니다
  >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
  >>> del a[0]
  >>> a
  [1, 66.25, 333, 333, 1234.5]
  >>> del a[2:4]
  >>> a
  [1, 66.25, 1234.5]
  >>> del a[:]
  >>> a
  []

 - del 는 변 자체를 삭제하는데에도 사용될 수 있습니다:
  >>> del a

○ 튜플과 시퀀스
 - 리스트와 문자열이 인덱싱과 슬라이싱 연산과 같은 많은 성질을 공유함을 보았음
 - 시퀀스형 -- list, tuple, range
 - 튜플은 쉼표로 구분되는 여러 값으로 구성됩니다
  >>> t = 12345, 54321, 'hello!'
  >>> t[0]
  12345
  >>> t
  (12345, 54321, 'hello!')
  >>> # Tuples may be nested:
  ... u = t, (1, 2, 3, 4, 5)
  >>> u
  ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
  >>> # Tuples are immutable:
  ... t[0] = 88888
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: 'tuple' object does not support item assignment
  >>> # but they can contain mutable objects:
  ... v = ([1, 2, 3], [3, 2, 1])
  >>> v
  ([1, 2, 3], [3, 2, 1])
 - 튜플은 불변 이고, 보통 이질적인 요소들의 시퀀스를 포함합니다. 
   요소들은 언 패킹 (이 섹션의 뒤에 나온다) 이나 인덱싱 
   (또는 네임드 튜플 의 경우는 어트리뷰트로도) 으로 액세스합니다. 
   리스트는 가변 이고, 요소들은 보통 등질 적이고 리스트에 대한 
   이터레이션으로 액세스 됩니다.
 - 특별한 문제는 비었거나 하나의 항목을 갖는 튜플을 만드는 것입니다: 
   이 경우를 수용하기 위해 문법은 추가적인 예외 사항을 갖고 있습니다. 
   빈 튜플은 빈 괄호 쌍으로 만들어집니다; 
   하나의 항목으로 구성된 튜플은 값 뒤에 쉼표를 붙여서 만듭니다 
   (값 하나를 괄호로 둘러싸기만 하는 것으로는 충분하지 않습니다). 
   추합니다, 하지만 효과적입니다. 예를 들어:
  >>>
  >>> empty = ()
  >>> singleton = 'hello',    # <-- note trailing comma
  >>> len(empty)
  0
  >>> len(singleton)
  1
  >>> singleton
  ('hello',)
 - 문장 t = 12345, 54321, 'hello!' 는 튜플 패킹 의 예입니다: 
   값 12345, 54321, 'hello!' 는 함께 튜플로 패킹 됩니다. 
   반대 연산 또한 가능합니다:
  >>> x, y, z = t
   이것은, 충분히 적절하게도, 시퀀스 언 패킹 이라고 불리고 오른쪽에 어떤 시퀀스가
   와도 됩니다. 시퀀스 언 패킹은 등호의 좌변에 시퀀스에 있는 요소들과 같은 개수의
   변수들이 올 것을 요구합니다. 다중 대입은 사실 튜플 패킹과 시퀀스 언 패킹의 
   조합일뿐이라는 것에 유의하세요.

○ 집합(Set)
 - 집합은 중복되는 요소가 없는 순서 없는 컬렉션입니다.
 - 기본적인 용도는 멤버십 검사와 중복 엔트리 제거입니다. 집합 객체는 합집합, 
   교집합, 차집합, 대칭 차집합과 같은 수학적인 연산들도 지원합니다.
 - 집합을 만들 때는 중괄호나 set() 함수를 사용할 수 있습니다. 
   주의사항: 빈 집합을 만들려면 set() 을 사용해야 합니다. {} 가 아닙니다; 
   후자는 빈 딕셔너리를 만듬
  >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
  >>> print(basket)                      # show that duplicates have been removed
  {'orange', 'banana', 'pear', 'apple'}
  >>> 'orange' in basket                 # fast membership testing
  True
  >>> 'crabgrass' in basket
  False
  
  >>> # Demonstrate set operations on unique letters from two words
  ...
  >>> a = set('abracadabra')
  >>> b = set('alacazam')
  >>> a                                  # unique letters in a
  {'a', 'r', 'b', 'c', 'd'}
  >>> a - b                              # letters in a but not in b
  {'r', 'd', 'b'}
  >>> a | b                              # letters in a or b or both
  {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
  >>> a & b                              # letters in both a and b
  {'a', 'c'}
  >>> a ^ b                              # letters in a or b but not both
  {'r', 'd', 'b', 'm', 'z', 'l'}
 - 리스트 컴프리헨션과 유사하게, 집합 컴프리헨션도 지원됨
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}

○ 딕셔너리
 - 숫자들로 인덱싱되는 시퀀스와 달리, 딕셔너리는 키 로 인덱싱되는데, 모든 불변형을 사용할 수 있습니다
 - 문자열과 숫자들은 항상 키가 될 수 있습니다. 튜플이 문자열, 숫자, 튜플들만 포함하면, 키로 사용될 수 있습니다
 - 튜플이 직접적이나 간접적으로 가변 객체를 포함하면, 키로 사용될 수 없습니다. 리스트는 키로 사용할 수 없는데, 리스트는 인덱스 대입, 슬라이스 대입, append() 나 extend() 같은 메서드들로 값이 수정될 수 있기 때문입니다.
 - 딕셔너리를 (한 딕셔너리 안에서) 키가 중복되지 않는다는 제약 조건을 가진 키: 값 쌍의 집합으로 생각하는 것이 최선입니다
 - 중괄호 쌍은 빈 딕셔너리를 만듭니다: {}. 중괄호 안에 쉼표로 분리된 키:값 쌍들의 목록을 넣으면, 딕셔너리에 초기 키:값 쌍들을 제공합니다; 이것이 딕셔너리가 출력되는 방식이기도 합니다.
 - del 로 키:값 쌍을 삭제하는 것도 가능합니다. 이미 사용하고 있는 키로 저장하면, 그 키로 저장된 예전 값은 잊힙니다. 존재하지 않는 키로 값을 추출하는 것은 에러입니다.
 - 딕셔러리에 list(d) 를 수행하면 딕셔너리에서 사용되고 있는 모든 키의 리스트를 삽입 순서대로 돌려줍니다 (정렬을 원하면 대신 sorted(d) 를 사용하면 됩니다). 하나의 키가 딕셔너리에 있는지 검사하려면, in 키워드들 사용하세요.
  >>> tel = {'jack': 4098, 'sape': 4139}
  >>> tel['guido'] = 4127
  >>> tel
  {'jack': 4098, 'sape': 4139, 'guido': 4127}
  >>> tel['jack']
  4098
  >>> del tel['sape']
  >>> tel['irv'] = 4127
  >>> tel
  {'jack': 4098, 'guido': 4127, 'irv': 4127}
  >>> list(tel)
  ['jack', 'guido', 'irv']
  >>> sorted(tel)
  ['guido', 'irv', 'jack']
  >>> 'guido' in tel
  True
  >>> 'jack' not in tel
  False
 - dict() 생성자는 키-값 쌍들의 시퀀스로 부터 직접 딕셔너리를 구성합니다.
  >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
  {'sape': 4139, 'guido': 4127, 'jack': 4098}
 - 이에 더해, 딕셔너리 컴프리헨션은 임의의 키와 값 표현식들로 부터 딕셔너리를 만드는데 사용될 수 있습니다:
  >>> {x: x**2 for x in (2, 4, 6)}
  {2: 4, 4: 16, 6: 36}
 - 키가 간단한 문자열일 때, 때로 키워드 인자들을 사용해서 쌍을 지정하기가 쉽습니다:
  >>> dict(sape=4139, guido=4127, jack=4098)
  {'sape': 4139, 'guido': 4127, 'jack': 4098}

○ 루프 테크닉
 - 딕셔너리로 루핑할 때, items() 메서드를 사용하면 키와 거기에 대응하는 값을
   동시에 얻을 수 있습니다.
  >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
  >>> for k, v in knights.items():
  ...     print(k, v)
  ...
  gallahad the pure
  robin the brave
 - 시퀀스를 루핑할 때, enumerate() 함수를 사용하면 위치 인덱스와 대응하는 값을 
   동시에 얻을 수 있습니다.
  >>> for i, v in enumerate(['tic', 'tac', 'toe']):
  ...     print(i, v)
  ...
  0 tic
  1 tac
  2 toe
 - 둘이나 그 이상의 시퀀스를 동시에 루핑하려면, zip() 함수로 엔트리들의 쌍을 
   만들 수 있습니다.
  >>> questions = ['name', 'quest', 'favorite color']
  >>> answers = ['lancelot', 'the holy grail', 'blue']
  >>> for q, a in zip(questions, answers):
  ...     print('What is your {0}?  It is {1}.'.format(q, a))
  ...
  What is your name?  It is lancelot.
  What is your quest?  It is the holy grail.
  What is your favorite color?  It is blue.

 - 시퀀스를 거꾸로 루핑하려면, 먼저 정방향으로 시퀀스를 지정한 다음에 reversed() 함수를 호출하세요.
  >>> for i in reversed(range(1, 10, 2)):
  ...     print(i)
  ...
  9
  7
  5
  3
  1

 - 정렬된 순서로 시퀀스를 루핑하려면, sorted() 함수를 사용해서 소스를 변경하지
   않고도 정렬된 새 리스트를 받을 수 있습니다.
  >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
  >>> for f in sorted(set(basket)):
  ...     print(f)
  ...
  apple
  banana
  orange
  pear
 - 때로 루프를 돌고 있는 리스트를 변경하고픈 유혹을 느낍니다; 하지만, 종종, 
   대신 새 리스트를 만드는 것이 더 간단하고 더 안전합니다.
  >>> import math
  >>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
  >>> filtered_data = []
  >>> for value in raw_data:
  ...     if not math.isnan(value):
  ...         filtered_data.append(value)
  ...
  >>> filtered_data
  [56.2, 51.7, 55.3, 52.5, 47.8]
 - 비교 연산자 in 과 not in 은 값이 시퀀스에 있는지 (없는지) 검사합니다. 연산자 is 와 is not 은 두 객체가 진짜로 같은 객체인지 비교합니다; 이것은 리스트와 같은 가변 객체에서만 의미가 있습니다. 모든 비교 연산자들은 같은 우선순위를 갖는데, 모든 산술 연산자들보다 낮습니다.
 - 비교는 연쇄할 수 있습니다. 예를 들어, a < b == c 는, a 가 b 보다 작고, 동시에 b 가 c 와 같은지 검사합니다
 - 비교는 논리 연산자 and 와 or 를 사용해서 결합할 수 있고, 비교의 결과는 (또는 그 밖의 모든 논리 표현식은) not 으로 부정될 수 있습니다. 이것들은 비교 연산자보다 낮은 우선순위를 갖습니다. 이것 간에는 not 이 가장 높은 우선순위를 갖고, or 가 가장 낮습니다. 그래서 A and not B or C 는 (A and (not B)) or C 와 동등합니다.
 - 논리 연산자 and 와 or 는 소위 단락-회로(short-circuit) 연산자입니다: 인자들은 왼쪽에서 오른쪽으로 값이 구해지고, 결과가 결정되자마자 값 구하기는 중단됩니다. 예를 들어, A 와 C 가 참이고 B 가 거짓이면, A and B and C 는 표현식 C 의 값을 구하지 않습니다. 논리값이 아닌 일반 값으로 사용될 때, 단락-회로 연산자의 반환 값은 마지막으로 값이 구해진 인자입니다.
  >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
  >>> non_null = string1 or string2 or string3
  >>> non_null
  'Trondheim'
 - 파이썬에서, C와는 달리, 표현식 안에서의 대입은 바다코끼리 연산자 :=를 사용하여
   명시적으로 수행해야 합니다.
 - 먼저 첫 두 항목을 비교해서 다르면 이것이 비교의 결과를 결정합니다; 같으면, 
   다음 두 항목을 비교하고, 이런 식으로 어느 한 시퀀스가 소진될 때까지 계속합
   니다. 만약 비교되는 두 항목 자체가 같은 형의 시퀀스면, 사전식 비교가 
   재귀적으로 수행됩니다. 두 시퀀스의 모든 항목이 같다고 비교되면, 시퀀스들은 
   같은 것으로 취급됩니다. 한 시퀀스가 다른 하나의 머리 부분 서브 시퀀스면, 
   짧은 시퀀스가 작은 것입니다. 문자열의 사전식 배열은 개별 문자들의 순서를 
   정하는데 유니코드 코드 포인트 숫자를 사용합니다. 같은 형의 시퀀스들 간의 
   비교의 몇 가지 예는 이렇습니다:
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

○ 모듈
 - 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용할 
   수 있는 방법을 제공합니다. 그런 파일을 모듈 이라고 부릅니다
 - 메인 모듈은 최상위 수준에서 실행되는 스크립트나 계산기 모드에서 액세스하는 
   변수들의 컬렉션입니다
 - 모듈은 파이썬 정의와 문장들을 담고 있는 파일입니다. 파일의 이름은 모듈 이름에
   확장자 .py 를 붙입니다. 모듈 내에서, 모듈의 이름은 전역 변수 __name__ 으로 
   제공됩니다.
 - 모듈에 들어있는 이름들을 직접 임포트하는 모듈의 심볼 테이블로 임포트하는 import
   문의 변종이 있습니다
from fibo import fib, fib2
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
>>> from fibo import *
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
 - 이것은 밑줄 (_) 로 시작하는 것들을 제외한 모든 이름을 임포트 합니다
 - 모듈 이름 다음에 as 가 올 경우, as 다음의 이름을 임포트한 모듈에 직접 연결합니다.
>>> import fibo as fib
>>> fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 

from fibo import fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

○ 모듈을 스크립트로 실행하기
python fibo.py <arguments>
 - 모듈에 있는 코드는, 그것을 임포트할 때처럼 실행됩니다. 하지만 __name__ 은 "__main__" 로 설정됩니다. 이것은, 이 코드를 모듈의 끝에 붙여서:
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
 - 파일을 임포트할 수 있는 모듈뿐만 아니라 스크립트로도 사용할 수 있도록 만들 수 
   있음을 의미하는데, 오직 모듈이 《메인》 파일로 실행될 때만 명령행을 파싱하는 
   코드가 실행되기 때문입니다:

○ 모듈 검색 경로
 - 모듈이 임포트될 때, 인터프리터는 먼저 그 이름의 내장 모듈을 찾습니다.
 - 발견되지 않으면, 변수 sys.path 로 주어지는 디렉터리들에서 spam.py 라는 이름의
   파일을 찾습니다
 - sys.path는 이 위치들로 초기화됩니다:
   . 입력 스크립트를 포함하는 디렉터리 (또는 파일이 지정되지 않았을 때는 현재 디렉터리).
   . PYTHONPATH (디렉터리 이름들의 목록, 셸 변수 PATH 와 같은 문법)
   . 설치 의존적인 기본값
 - 초기화 후에, 파이썬 프로그램은 sys.path 를 수정할 수 있습니다. 스크립트를 
   포함하는 디렉터리는 검색 경로의 처음에, 표준 라이브러리 경로의 앞에 놓입니다.
   이것은 같은 이름일 경우 라이브러리 디렉터리에 있는 것 대신 스크립트를 포함하는
   디렉터리의 것이 로드된다는 뜻입니다. 이 치환이 의도된 것이 아니라면 에러입니다

○ 컴파일된 파이썬 파일
 - 모듈 로딩을 빠르게 하려고, 파이썬은 __pycache__ 디렉터리에 각 모듈의 컴파일된
   버전을 module.version.pyc 라는 이름으로 캐싱합니다. version 은 컴파일된 파일의
   형식을 지정합니다; 일반적으로 파이썬의 버전 번호를 포함합니다. 예를 들어, 
   CPython 배포 3.3 에서 spam.py 의 컴파일된 버전은 __pycache__/spam.cpython-33.pyc
   로 캐싱 됩니다. 
 - 파이썬은 소스의 수정 시간을 컴파일된 버전과 비교해서 시효가 지나 다시 
   컴파일해야 하는지 검사합니다. 이것은 완전히 자동화된 과정입니다. 또한, 
   컴파일된 모듈은 플랫폼 독립적이기 때문에, 같은 라이브러리를 서로 다른 
   아키텍처를 갖는 시스템들에서 공유할 수 있습니다.    
 - 파이썬은 두 가지 상황에서 캐시를 검사하지 않습니다. 첫째로, 명령행에서 직접 로드되는
   모듈들은 항상 재컴파일하고 그 결과를 저장하지 않습니다. 둘째로, 소스 모듈이 
   없으면 캐시를 검사하지 않습니다. 소스 없는 (컴파일된 파일만 있는) 배포를 
   지원하려면, 컴파일된 모듈이 소스 디렉터리에 있어야 하고, 소스 모듈이 없어야 
   합니다.
 - 컴파일된 모듈의 크기를 줄이려면 파이썬 명령에 -O 나 -OO 스위치를 사용할 수 
   있습니다. -O 스위치는 assert 문을 제거하고, -OO 스위치는 assert 문과 __doc__ 
   문자열을 모두 제거합니다. 어떤 프로그램들은 이것들에 의존하기 때문에, 무엇을 
   하고 있는지 아는 경우만 이 옵션을 사용해야 합니다. 《최적화된》 모듈은 opt- 
   태그를 갖고, 보통 더 작습니다. 미래의 배포에서는 최적화의 효과가 변경될 수 
   있습니다.
 - .py 파일에서 읽을 때보다 .pyc 파일에서 읽을 때 프로그램이 더 빨리 실행되지는 
   않습니다; .pyc 파일에서 더 빨라지는 것은 로드되는 속도뿐입니다.
 - 모듈 compileall 은 디렉터리에 있는 모든 모듈의 .pyc 파일들을 만들 수 있습니다.

○ 표준 모듈들
 - sys. 모든 파이썬 인터프리터에 내장됩니다. 변수 sys.ps1 와 sys.ps2 는 기본과 
   보조 프롬프트로 사용되는 문자열을 정의합니다:
 - 변수 sys.path 는 인터프리터의 모듈 검색 경로를 결정하는 문자열들의 리스트입니다. 
   환경 변수 PYTHONPATH 에서 취한 기본 경로나, PYTHONPATH 가 설정되지 않는 경우 
   내장 기본값으로 초기화됩니다. 표준 리스트 연산을 사용해서 수정할 수 있습니다:
>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')

○ dir() 함수
 - 내장 함수 dir() 은 모듈이 정의하는 이름들을 찾는 데 사용됩니다. 문자열들의 정렬된 리스트를 돌려줍니다
>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']

 - 인자가 없으면, dir() 는 현재 정의한 이름들을 나열합니다:
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
 - dir() 은 내장 함수와 변수들의 이름을 나열하지 않습니다. 그것들의 목록을 원한다면, 표준 모듈 builtins 에 정의되어 있습니다:
>>> import builtins
>>> dir(builtins)  
  
○ 패키지
 - 점으로 구분된 모듈 이름을 써서 파이썬의 모듈 이름 공간을 구조화하는 방법
 - 모듈들의 컬렉션
 sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
 - sys.path에 있는 디렉토리를 검색하면서 패키지 서브 디렉토리를 찾음
 - 파이썬이 디렉토리를 패키지로 취급하게 만들기 위해서 __init__.py 파일이 필요함
 - 패키지 사용자는 패키지로부터 개별 모듈을 임포트 할 수 있음
   . import sound.effects.echo
   . 전체 이름으로 참조되어야 함
   . sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
 - 또 다른 방법은 
   . from sound.effects import echo
   . 패키지 접두어 없이 사용할 수 있게 함. echo.echofilter(input, output, delay=0.7, atten=4)
 - 또 다른 방법은 원하는 함수나 변수를 직접 임포트하는 것
   . from sound.effects.echo import echofilter
   . echofilter(input, output, delay=0.7, atten=4)
 - from package import item 를 사용할 때, 
   . item은 패키지의 서브 모듈 (또는 서브 패키지)일 수도 있고 
   . 함수, 클래스, 변수 등 패키지에 정의된 다른 이름들일 수도 있음
   . import 문은 먼저 item이 패키지에 정의되어 있는지 검사하고, 
   . 그렇지 않으면 모듈이라고 가정하고 로드를 시도함
   . 찾지 못한다면, ImportError 예외를 일으킴
 - import item.subitem.subsubitem와 같은 문법을 사용할 때
   . 마지막 것을 제외한 각 항목은 반드시 패키지여야 함
   . 마지막 항목은 모듈인 패키지가 될 수 있지만,
   . 앞의 항목에서 정의된 클래스, 함수, 변수 등이 될 수는 없음   

○ 패키지에서 * 임포트하기
 - from sound.effects import *  가 모두를 임포트 하기를 원할 것임
   . 시간이 오래 걸리고 
   . 어떤 서브 모듈을 명시적으로 임포트할 경우만 일어나야만 하는 원하지 않는 
     부수적 효과가 발생할 수 있음
 - 유일한 해결책은 패키지 저자가 패키지의 색인을 명시적으로 제공하는 것
   . import 문은 다음과 같은 관례가 있습니다
   . 패키지의 __init__.py 코드가 __all__ 이라는 이름의 목록을 제공하면, 
   . 이것을 from package import * 를 만날 때 임포트 해야만 하는 모듈 이름들의 
     목록으로 받아들입니다. 
 - __all__ 이 정의되지 않으면, 
   . 문장 from sound.effects import * 은 패키지 sound.effects 의 모든 서브 모듈들을 
     현재 이름 공간으로 임포트 하지 않습니다
   . 이것은 오직 패키지 sound.effects 가 임포트 되도록 만들고 
     (__init__.py 에 있는 초기화 코드들이 수행될 수 있습니다), 
   . 그 패키지가 정의하는 이름들을 임포트 합니다. 이 이름들은 
     __init__.py 가 정의하는 모든 이름 (그리고 명시적으로 로드된 서브 모듈들)을 
     포함합니다. 이 이름들에는 사전에 import 문으로 명시적으로 로드된 패키지의 
     서브 모듈들 역시 포함됩니다.   

○ 패키지 내부 간의 참조
 - 이웃 패키지의 서브 모듈을 가리키는데 절대 임포트를 사용할 수 있음
 - 상대 임포트를 쓸 수도 있는데, from module import name 형태의 임포트 문을 사용함
   . from . import echo
   . from .. import formats
   . from ..filters import equalizer
 - 파이썬 응용 프로그램의 메인 모듈로 사용될 목적의 모듈들은 반드시 절대 임포트를 사용해야 함
 
○ 여러 디렉토리에 있는 패키지
 -  패키지는 특별한 어트리뷰트 하나를 더 지원합니다, 
 - __path__. 이것은 패키지의 __init__.py 파일을 실행하기 전에, 
 - 이 파일이 들어있는 디렉터리의 이름을 포함하는 리스트로 초기화됨
 
○ 모듈 수준의 함수 정의를 실행하면 함수의 이름이 전역 심볼 테이블에 들어갑니다.

○ 장식적인 출력 포매팅
 - 포맷 문자열 리터럴을 사용하려면, 시작 인용 부호 또는 삼중 인용 부호 앞에 f 또는 F 를 붙여 문자열을 시작
  >>> year = 2016
  >>> event = 'Referendum'
  >>> f'Results of the {year} {event}'
  'Results of the 2016 Referendum'
 - 문자열의 str.format() 메서드
 - 문자열 슬라이싱 및 이어붙이기 연산
 - repr() 또는 str() 함수를 사용하여 모든 값을 문자열로 변환할 수 있음

○ 포맷 문자열 리터럴
 - 포맷 문자열 리터럴(간단히 f-문자열이라고도 합니다)은 문자열에 f 또는 F 접두어를 붙이고 표현식을 {expression}로 
   작성하여 문자열에 파이썬 표현식의 값을 삽입할 수 있게 함
  >>> import math
  >>> print(f'The value of pi is approximately {math.pi:.3f}.')
  The value of pi is approximately 3.142.   
 - ':' 뒤에 정수를 전달하면 해당 필드의 최소 문자 폭이
  >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
  >>> for name, phone in table.items():
  ...     print(f'{name:10} ==> {phone:10d}')
  ...
  Sjoerd     ==>       4127
  Jack       ==>       4098
  Dcab       ==>       7678
 - version 2.7에서는 print '{0:10}'.format(phone)
 - 다른 수정자를 사용하면 포맷되기 전에 값을 변환할 수 있음
 - '!a'는 ascii()를, '!s'는 str()을, '!r'는 repr()을 적용함
  >>> animals = 'eels'
  >>> print(f'My hovercraft is full of {animals}.')
  My hovercraft is full of eels.
  >>> print(f'My hovercraft is full of {animals!r}.')
  My hovercraft is full of 'eels'. 

○ 7.1.2. 문자열 format() 메서드
 - str.format() 메서드 기본적인 사용법
  >>> print('We are the {} who say "{}!"'.format('knights', 'Ni')) 
  We are the knights who say "Ni!"
 - 중괄호 안의 숫자는 str.format() 메서드로 전달된 객체들의 위치를 가리키는데 사용됨
  >>> print('{1} and {0}'.format('spam', 'eggs'))
  eggs and spam 
 - str.format() 메서드에 키워드 인자가 사용되면, 그 값들은 인자의 이름을 사용해서 
   지정할 수 있음
  >>> print('This {food} is {adjective}.'.format(
  ...       food='spam', adjective='absolutely horrible'))
  This spam is absolutely horrible.   
 - 위치와 키워드 인자를 자유롭게 조합할 수 있음
  >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', other='Georg'))
  The story of Bill, Manfred, and Georg. 
 - 나누고 싶지 않은 정말 긴 포맷 문자열이 있을 때, 포맷할 변수들을 위치 대신에 이름으로 지정할 수 있음
 - 간단히 딕셔너리를 넘기고 키를 액세스하는데 대괄호 '[]' 를 사용하면 됨
  >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
  >>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
  ...       'Dcab: {0[Dcab]:d}'.format(table))
  Jack: 4098; Sjoerd: 4127; Dcab: 8637678 
 - 〈**〉 표기법을 사용해서 table을 키워드 인자로 전달해도 같은 결과를 얻을 수 있습니다.
  >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
  >>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
  Jack: 4098; Sjoerd: 4127; Dcab: 8637678 
 - 이 방법은 모든 지역 변수들을 담은 딕셔너리를 돌려주는 내장 함수 vars() 와 함께 사용할 때 특히 쓸모가 있습니다.
 - 다음 줄은 정수와 그 제곱과 세제곱을 제공하는 빽빽하게 정렬된 열 집합을 생성
  >>> for x in range(1, 11):
  ...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
  ... 

○ 수동 문자열 포매팅
 - 여기 같은 제곱수와 세제곱수 표를 수동으로 포매팅
  >>> for x in range(1, 11):
  ...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
  ...     # Note use of 'end' on previous line
  ...     print(repr(x*x*x).rjust(4))
  ... 
 - print() 의 동작 방식으로 인해 각 칼럼 사이에 스페이스 하나가 추가됨
 - 문자열 객체의 str.rjust() 메서드는 왼쪽에 스페이스를 채워서 주어진 폭으로 문자열을 우측 줄 맞춤함
 - 비슷한 메서드 str.ljust() 와 str.center() 도 있음
 - 이 메서드들은 어떤 것도 출력하지 않습니다, 단지 새 문자열을 돌려줍니다. 
   입력 문자열이 너무 길면, 자르지 않고, 변경 없이 그냥 돌려줍니다; 이것이 
   열 배치를 엉망으로 만들겠지만, 보통 값에 대해 거짓말을 하게 될 대안보다는 
   낫습니다. (정말로 잘라내기를 원한다면, 항상 슬라이스 연산을 추가할 수 있습니다, 
   x.ljust(n)[:n] 처럼.)
 - 다른 메서드도 있습니다, str.zfill(). 숫자 문자열의 왼쪽에 0을 채움
 - 플러스와 마이너스 부호도 이해함
  >>> '12'.zfill(5)
  '00012'
  >>> '-3.14'.zfill(7)
  '-003.14'
  >>> '3.14159265359'.zfill(5)
  '3.14159265359' 
 
○ 예전의 문자열 포매팅
 - % 연산자도 문자열 포매팅에 사용될 수 있습니다. 왼쪽 인자를 오른쪽 인자에 적용되는 sprintf()-스타일 포맷 문자열로 해석하고, 이 포매팅 연산의 결과로 얻어지는 문자열을 돌려줌
  >>> import math
  >>> print('The value of pi is approximately %5.3f.' % math.pi)
  The value of pi is approximately 3.142.  

○ 파일을 읽고 쓰기
 - open() 은 파일 객체 를 돌려주고, 두 개의 인자를 주는 방식이 가장 많이 사용됩니다: open(filename, mode).
  >>> f = open('workfile', 'w')
 - mode
   . r: 읽기(기본값), w: 쓰기, a: 덧붙이기, r+: 읽고 쓰기, b: 바이너리 모드, t: 텍스트모드(기본값), +: 갱신, x: 독점적인 파일 만들기용
   . 기본 모드는 'r' 입니다 (텍스트를 읽는 용으로 엽니다, 'rt' 의 동의어). 
   . 모드 'w+'와 'w+b' 는 파일을 열고 자릅니다(truncate). 
   . 모드 'r+'과 'r+b' 는 자르지 않고 파일을 엽니다.
 - open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
   . encoding 은 파일을 디코딩하거나 인코딩하는 데 사용되는 인코딩의 이름입니다. 
   . 텍스트 모드에서만 사용해야 합니다. 기본 인코딩은 플랫폼에 따라 다르지만 
     (locale.getpreferredencoding() 이 돌려주는 값), 
   . 파이썬에서 지원하는 텍스트 인코딩 은 모두 사용할 수 있습니다. 
   . 지원되는 인코딩 목록은 codecs 모듈을 보면 됩니다.
 - 텍스트 모드에서, 읽을 때의 기본 동작은 플랫폼 의존적인 줄 종료 
   (유닉스에서 \n, 윈도우에서 \r\n) 를 단지 \n 로 변경하는 것입니다
 - 텍스트 모드로 쓸 때, 기본 동작은 \n 를 다시 플랫폼 의존적인 줄 종료로 변환하는 것입니다.   
 - 이 파일 데이터에 대한 무대 뒤의 수정은 텍스트 파일의 경우는 문제가 안 되지만, 
   JPEG 이나 EXE 파일과 같은 바이너리 데이터를 망치게 됩니다. 그런 파일을 읽고 쓸 때 
   바이너리 모드를 사용하도록 주의하세요.
 - 파일 객체를 다룰 때 with 키워드를 사용하는 것은 좋은 습관입니다. 
   혜택은 도중 예외가 발생하더라도 스위트가 종료될 때 파일이 올바르게 
   닫힌다는 것입니다. with 를 사용하는 것은 동등한 try-finally 블록을 
   쓰는 것에 비교해 훨씬 짧기도 합니다
  >>> with open('workfile') as f:
  ...     read_data = f.read()
  
  >>> # We can check that the file has been automatically closed.
  >>> f.closed
  True 
 - with 키워드를 사용하지 않으면, f.close() 를 호출해서 파일을 닫고 사용된 
   시스템 자원을 즉시 반납해야 합니다. 명시적으로 파일을 닫지 않으면, 파이썬의 
   가비지 수거기가 결국에는 객체를 파괴하고 여러분을 대신해서 파일을 닫게 되지만, 
   파일이 한동안 열린 상태로 남아있게 됩니다. 또 다른 위험은 다른 파이썬 구현들은 
   이 뒷정리를 서로 다른 시점에 수행한다는 것입니다. 
 
○ 파일 객체의 메소드
 - f.read(size)
   . size 가 생략되거나 음수면 파일의 내용 전체를 읽어서 돌려줌
   . 파일의 끝에 도달하면, f.read() 는 빈 문자열 ('') 을 돌려줌
 - f.readline()
   . 파일에서 한 줄을 읽습니다; 개행 문자 (\n) 는 문자열의 끝에 보존되고, 파일이 개행문자로 끝나지 않는 때에만 파일의 마지막 줄에서만 생략됨
   . f.readline() 가 빈 문자열을 돌려주면, 파일의 끝에 도달한 것이지만, 빈 줄은 '\n', 즉 하나의 개행문자만을 포함하는 문자열로 표현됨    
 - 파일에서 줄들을 읽으려면, 파일 객체에 대해 루핑할 수 있습니다. 
   이것은 메모리 효율적이고, 빠르며 간단한 코드로 이어집니다:
  >>> f = open('C:/Data/Device/JobData/edge-manager/config/config.yml')
  >>> for line in f:
  	print(line, end='')
 - 파일의 모든 줄을 리스트로 읽어 들이려면 list(f) 나 f.readlines() 를 쓸 수 있음
 - f.tell()
   . 파일의 현재 위치를 가리키는 정수를 돌려주는데, 바이너리 모드의 경우 파일의 
     처음부터의 바이트 수로 표현되고 텍스트 모드의 경우는 불투명한 숫자임
 - f.seek(offset, whence)
   . 위치는 기준점에 offset 을 더해서 계산됩니다
   . 기준점은 whence 인자로 선택합니다. 
   . whence 값이 0이면 파일의 처음부터 측정하고, 
   . 1이면 현재 파일 위치를 사용하고, 
   . 2 는 파일의 끝을 기준점으로 사용합니다. 
   . whence 는 생략될 수 있고, 기본값은 0이라서 파일의 처음을 기준점으로 사용합니다.

○ json 구조적인 데이터 저장하기
 - int() 같은 함수로 전달해야만 하는데, '123' 같은 문자열을 받고 숫자 값 123을 돌려줌
 - 파이썬은 JSON (JavaScript Object Notation) 이라는 널리 쓰이는 데이터 교환 형식을 
   사용할 수 있게 합니다. json 이라는 표준 모듈은 파이썬 데이터 계층을 받아서 문자열 
   표현으로 바꿔줍니다; 이 절차를 직렬화 (serializing) 라고 부릅니다. 문자열 표현으로
   부터 데이터를 재구성하는 것은 역 직렬화 (deserializing) 라고 부릅니다.
 - 객체 x 가 있을 때, 간단한 한 줄의 코드로 그것의 JSON 문자열 표현을 볼 수 있음
  >>> import json
  >>> json.dumps([1, 'simple', 'list'])
  '[1, "simple", "list"]'
 - dump()라는 dumps() 함수의 변종은 객체를 텍스트 파일 로 직렬화합니다. 그래서 f 가 쓰기를 위해 열린 텍스트 파일 이면, 이렇게 할 수 있습니다:
  >>> json.dump(x, f)  
 - 객체를 다시 디코드하려면, f가 읽기를 위해 열린 텍스트 파일 객체일 때
  >>> x = json.load(f)
 - 이 간단한 직렬화 테크닉이 리스트와 딕셔너리를 다룰 수 있지만, 임의의 클래스 인스턴스를 JSON 으로 직렬화하기 위해서는 약간의 수고가 더 필요함
 
○ 문법 에러
 - 문법 에러는, 파싱 에러라고도 알려져 있음
  >>> while True print('Hello world')
    File "<stdin>", line 1
      while True print('Hello world')
                     ^
  SyntaxError: invalid syntax
 - 에러는 화살표 앞에 오는 토큰이 원인입니다 (또는 적어도 그곳에서 감지되었습니다)
 - 이 예에서, 에러는 함수 print() 에서 감지되었는데, 그 앞에 콜론 (':') 이 빠져있기 때문임
 
○ 예외
 - 실행 중에 감지되는 에러들을 예외 
 - 예외 형으로 인쇄된 문자열은 발생한 내장 예외의 이름
 - 표준 예외 이름은 내장 식별자입니다 (예약 키워드가 아닙니다).
 
○ 예외 처리하기
 - 선택한 예외를 처리하는 프로그램을 만드는 것이 가능합니다. 다음 예를 보면, 
   올바를 정수가 입력될 때까지 사용자에게 입력을 요청하지만, 사용자가 프로그램을 
   인터럽트 하는 것을 허용합니다 (Control-C 나 그 외에 운영 체제가 지원하는 것을 
   사용해서); 사용자가 만든 인터럽트는 KeyboardInterrupt 예외를 일으키는 형태로 나타남
  >>> while True:
  ...     try:
  ...         x = int(input("Please enter a number: "))
  ...         break
  ...     except ValueError:
  ...         print("Oops!  That was no valid number.  Try again...")
  ...
 - 먼저, try 절 (try 와 except 사이의 문장들) 이 실행됩니다.
 - 예외가 발생하지 않으면, except 절 을 건너뛰고 try 문의 실행은 종료됩니다.
 - try 절을 실행하는 동안 예외가 발생하면, 절의 남은 부분들을 건너뜁니다. 그런 
   다음 형이 except 키워드 뒤에 오는 예외 이름과 매치되면, 그 except 절이 실행되고, 
   그런 다음 실행은 try 문 뒤로 이어집니다.
 - except 절에 있는 예외 이름들과 매치되지 않는 예외가 발생하면, 외부에 있는 
   try 문으로 전달됩니다; 처리기가 발견되지 않으면, 처리되지 않은 예외 이고 
   위에서 보인 것과 같은 메시지를 출력하면서 실행이 멈춥니다.
 - except 절은 괄호가 있는 튜플로 여러 개의 예외를 지정할 수 있습니다, 예를 들어:
  ... except (RuntimeError, TypeError, NameError):
  ...     pass   
 - except 절에 있는 클래스는 예외와 같은 클래스이거나 베이스 클래스일 때 매치됩니다 (하지만 다른 방식으로는 매치되지 않습니다 ? 자식 클래스를 나열한 except 절은 베이스 클래스와 매치되지 않습니다).
  class B(Exception):
      pass
  
  class C(B):
      pass
  
  class D(C):
      pass
  
  for cls in [B, C, D]:
      try:
          raise cls()
      except D:
          print("D")
      except C:
          print("C")
      except B:
          print("B")      
 - except 절이 뒤집히면 (except B 가 처음에 오도록), B, B, B를 인쇄하게 됨에 주의
   하세요 ? 처음으로 매치되는 절이 실행됩니다.   
 - 마지막 except 절은 예외 이름을 생략할 수 있는데, 와일드카드 역할을 합니다. 이것을
   사용할 때는 극도의 주의를 필요로 합니다. 이런 식으로 실제 프로그래밍 에러를 가리기
   쉽기 때문입니다! 에러 메시지를 인쇄한 후에 예외를 다시 일으키는데 사용될 수도 있습니다 
   (호출자도 예외를 처리할 수 있도록):   
  import sys
  
  try:
      f = open('myfile.txt')
      s = f.readline()
      i = int(s.strip())
  except OSError as err:
      print("OS error: {0}".format(err))
  except ValueError:
      print("Could not convert data to an integer.")
  except:
      print("Unexpected error:", sys.exc_info()[0])
      raise   
 - try … except 문은 선택적인 else 절 을 갖는데, 
   있다면 모든 except 절 뒤에와야 합니다. 
   try 절이 예외를 일으키지 않을 때 실행되어야만 하는 코드에 유용합니다. 예를 들어:
  for arg in sys.argv[1:]:
      try:
          f = open(arg, 'r')
      except OSError:
          print('cannot open', arg)
      else:
          print(arg, 'has', len(f.readlines()), 'lines')
          f.close()  
 - else 절의 사용이 try 절에 코드를 추가하는 것보다 좋은데, try … except 문에 의해 
   보호되고 있는 코드가 일으키지 않은 예외를 우연히 잡게 되는 것을 방지하기 때문입니다. 
 - except 절은 예외 이름 뒤에 변수를 지정할 수 있습니다. 변수는 인자들이 
   instance.args 에 저장된 예외 인스턴스에 연결됩니다. 편의를 위해, 예외 
   인스턴스는 __str__() 를 정의해서, .args 를 참조하지 않고도 인자들을 직접 
   인쇄할 수 있습니다
  >>> try:
  ...     raise Exception('spam', 'eggs')
  ... except Exception as inst:
  ...     print(type(inst))    # the exception instance
  ...     print(inst.args)     # arguments stored in .args
  ...     print(inst)          # __str__ allows args to be printed directly,
  ...                          # but may be overridden in exception subclasses
  ...     x, y = inst.args     # unpack args
  ...     print('x =', x)
  ...     print('y =', y)
  ...
  <class 'Exception'>
  ('spam', 'eggs')
  ('spam', 'eggs')
  x = spam
  y = eggs   

○ 예외 일으키기
  >>> raise NameError('HiThere')
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  NameError: HiThere
 - 예외 인스턴스이거나 예외 클래스 (Exception 를 계승하는 클래스) 이어야 합니다. 
 - 예외 클래스가 전달되면, 묵시적으로 인자 없이 생성자를 호출해서 인스턴스를 만듭니다:
  raise ValueError  # shorthand for 'raise ValueError()' 
 - 만약 예외가 발생했는지는 알아야 하지만 처리하고 싶지는 않다면, 
   더 간단한 형태의 raise 문이 그 예외를 다시 일으킬 수 있게 합니다:
  >>> try:
  ...     raise NameError('HiThere')
  ... except NameError:
  ...     print('An exception flew by!')
  ...     raise
  ...
  An exception flew by!
  Traceback (most recent call last):
    File "<stdin>", line 2, in <module>
  NameError: HiThere   

○ 사용자 정의 예외
 - 예외는 보통 직접적으로나 간접적으로 Exception 클래스를 계승합니다.
  class Error(Exception):
      """Base class for exceptions in this module."""
      pass
  
  class InputError(Error):
      """Exception raised for errors in the input.
  
      Attributes:
          expression -- input expression in which the error occurred
          message -- explanation of the error
      """
  
      def __init__(self, expression, message):
          self.expression = expression
          self.message = message
  
  class TransitionError(Error):
      """Raised when an operation attempts a state transition that's not
      allowed.
  
      Attributes:
          previous -- state at beginning of transition
          next -- attempted new state
          message -- explanation of why the specific transition is not allowed
      """
  
      def __init__(self, previous, next, message):
          self.previous = previous
          self.next = next
          self.message = message 
 - 대부분의 예외는 표준 예외들의 이름들과 유사하게, 《Error》 로 끝나는 이름으로 정의됩니다.
 
○ 뒷정리 동작 정의하기
 - try 문은 또 다른 선택적 절을 가질 수 있는데 모든 상황에 실행되어야만 하는 뒷정리 동작을 정의하는 데 사용됨
  >>> try:
  ...     raise KeyboardInterrupt
  ... finally:
  ...     print('Goodbye, world!')
  ...
  Goodbye, world!
  KeyboardInterrupt
  Traceback (most recent call last):
    File "<stdin>", line 2, in <module>

 - try 절을 실행하는 동안 예외가 발생하면, except 절에서 예외를 처리할 수 있습니다. 
   예외가 except 절에서 처리되지 않으면, finally 절이 실행된 후 예외가 다시 발생합니다.
 - except나 else 절 실행 중에 예외가 발생할 수 있습니다. 
   다시, finally 절이 실행된 후 예외가 다시 발생합니다.
 - try 문이 break, continue 또는 return 문에 도달하면, 
   finally 절은 break, continue 또는 return 문 실행 직전에 실행됩니다.
   finally 절에 return 문이 포함되면, 반환 값은 try 절의 return 문이 주는 
   값이 아니라, finally 절의 return 문이 주는 값이 됩니다.
  >>> def divide(x, y):
  ...     try:
  ...         result = x / y
  ...     except ZeroDivisionError:
  ...         print("division by zero!")
  ...     else:
  ...         print("result is", result)
  ...     finally:
  ...         print("executing finally clause")
  ...
  >>> divide(2, 1)
  result is 2.0
  executing finally clause
  >>> divide(2, 0)
  division by zero!
  executing finally clause
  >>> divide("2", "1")
  executing finally clause
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<stdin>", line 3, in divide
  TypeError: unsupported operand type(s) for /: 'str' and 'str' 
 -  finally 절은 모든 경우에 실행됩니다. 두 문자열을 나눠서 발생한 TypeError 는 except 절에 의해 처리되지 않고 finally 절이 실행된 후에 다시 일어납니다.

○ 미리 정의된 뒷정리 동작들
 - 어떤 객체들은 객체가 더 필요 없을 때 개입하는 표준 뒷정리 동작을 정의합니다
  for line in open("myfile.txt"):
      print(line, end="")
 - with 문은 파일과 같은 객체들이 즉시 올바르게 뒷정리 되도록 보장하는 방법을 제공함
  with open("myfile.txt") as f:
      for line in f:
          print(line, end="")
 - 문장이 실행된 후에, 줄을 처리하는 데 문제가 발생하더라도, 파일 f 는 항상 닫힙니다. 
 - 파일과 같이, 미리 정의된 뒷정리 동작들을 제공하는 객체들은 그들의 설명서에서 이 사실을 설명합니다.
 
○ 클래스
 - 파이썬 클래스는 객체 지향형 프로그래밍의 모든 표준 기능들을 제공합니다: 
   클래스 상속 메커니즘은 다중 베이스 클래스를 허락하고, 자식 클래스는 베이스 
   클래스나 클래스들의 어떤 메서드도 재정의할 수 있으며, 메서드는 같은 이름의 
   베이스 클래스의 메서드를 호출할 수 있습니다. 
 - 클래스 멤버들은 (데이터 멤버를 포함해서) public하고, 모든 맴버 함수들은 
   virtual 입니다
 - 내장형도 사용자가 확장하기 위해 베이스 클래스로 사용할 수 있음
 - 특별한 문법을 갖는 대부분의 내장 연산자들은 (산술 연산자, 서브스크립팅, 등등)
   클래스 인스턴스에 대해 새로 정의될 수 있음
  
○ 파이썬 스코프와 이름 공간
 - 이름 공간 은 이름에서 객체로 가는 매핑입니다. 
 - 대부분의 이름 공간은 현재 파이썬 딕셔너리로 구현되어 있지만, 
   보통 다른 식으로는 알아차릴 수 없고 (성능은 예외입니다), 
   앞으로는 바뀔 수 있습니다. 
 - 어트리뷰트 라는 단어를 점 뒤에 오는 모든 이름에 사용합니다 ? 예를 들어, 
   표현식 z.real 에서, real 는 객체 z 의 어트리뷰트입니다. 엄밀하게 말해서, 
   모듈에 있는 이름들에 대한 참조는 어트리뷰트 참조입니다: 
   표현식 modname.funcname 에서, modname 은 모듈 객체고 funcname 는 그것의 
   어트리뷰트입니다.
 - 어트리뷰트는 읽기 전용 이거나 쓰기 가능할 수 있습니다. 후자의 경우, 
   어트리뷰트에 대한 대입이 가능합니다. 모듈 어트리뷰트는 쓰기 가능합니다: 
   modname.the_answer = 42 라고 쓸 수 있습니다. 쓰기 가능한 어트리뷰트는
   del 문으로 삭제할 수도 있습니다. 예를 들어, del modname.the_answer 는 
   modname 라는 이름의 객체에서 어트리뷰트 the_answer 를 제거합니다.
 - 이름 공간들은 서로 다른 순간에 만들어지고 서로 다른 수명을 갖습니다. 
   내장 이름들을 담는 이름 공간은 파이썬 인터프리터가 시작할 때 만들어지고 영원히
   지워지지 않습니다. 모듈의 전역 이름 공간은 모듈 정의를 읽는 동안 만들어집니다; 
   보통, 모듈 이름 공간은 인터프리터가 끝날 때까지 남습니다. 인터프리터의 최상위 
   호출 때문에 실행되는, 스크립트 파일이나 대화형으로 읽히는, 문장들은 __main__ 
   이라고 불리는 모듈 일부로 여겨져서 그 들 자신의 이름 공간을 갖습니다. 
   (내장 이름들 또한 모듈에 속하는데; 이것을 builtins 라 부릅니다.)
 - 함수의 지역 이름 공간은 함수가 호출될 때 만들어지고, 함수가 복귀하거나 함수 내에서 
   처리되지 않는 예외를 일으킬 때 삭제됩니다. 
 - 스코프는 이름 공간을 직접 액세스할 수 있는 파이썬 프로그램의 텍스트적인 영역
 - 스코프가 정적으로 결정됨에도 불구하고, 동적으로 사용됩니다. 실행 중 어느 시점에서건, 
   이름 공간을 직접 액세스 가능한, 적어도 세 개의 중첩된 스코프가 있습니다:
   . 가장 먼저 검색되는, 가장 내부의 스코프는 지역 이름들을 포함합니다
   . 가장 가까이서 둘러싸는 스코프로부터 검색이 시작됩니다, 비 지역(non-local) 이지만
     비 전역(non-global) 이름들을 포함 
   . 마지막 직전의 스코프는 현재 모듈의 전역 이름들을 포함합니다
   . (가장 나중에 검색되는) 가장 외부의 스코프는 내장 이름들을 포함하고 있는 이름 공간임
 - 이름을 global로 선언하면, 모든 참조와 대입은 모듈의 전역 이름들을 포함하는 
   중간 스코프로 바로 갑니다. 가장 내부의 스코프 바깥에서 발견되는 변수들을 
   재연결하려면, nonlocal 키워드를 사용할 수 있습니다;
 - nonlocal 로 선언되지 않으면, 그 변수들은 읽기 전용입니다
   (그런 변수에 쓰려고 하면 단순히 가장 내부의 스코프에 새 지역 변수를 만들게 
   되어, 같은 이름의 바깥 변수를 바꾸지 않고 남겨둡니다)
 - 보통, 지역 스코프는 현재 함수의 지역 이름들을 (텍스트 적으로) 참조합니다. 
   함수 바깥에서, 지역 스코프는 전역 스코프와 같은 이름 공간을 참조합니다: 
   모듈의 이름 공간. 클래스 정의들은 지역 스코프에 또 하나의 이름 공간을 
   배치합니다.
 - 파이썬의 특별한 특징은 global이나 nonlocal 문이 없을 때 이름에 대입하면 
   항상 가장 내부의 스코프로 간다는 것입니다. 대입은 데이터를 복사하지 않습니다
   이름을 단지 객체에 연결할 뿐입니다. 삭제도 마찬가지입니다: 문장 del x 는 
   지역 스코프가 참조하는 이름 공간에서 x 의 연결을 제거합니다. 사실, 새 
   이름을 소개하는 모든 연산은 지역 스코프를 사용합니다: 특히, import 문과 
   함수 정의는 모듈이나 함수 이름을 지역 스코프에 연결합니다.
 - global 문은 특정 변수가 전역 스코프에 있으며 그곳에 재연결되어야 함을 가리킬
   때 사용될 수 있습니다; nonlocal 문은 특정 변수가 둘러싸는 스코프에 있으며 
   그곳에 재연결되어야 함을 가리킵니다.

○ 스코프와 이름 공간 ㅖ
  def scope_test():
      def do_local():
          spam = "local spam"
  
      def do_nonlocal():
          nonlocal spam
          spam = "nonlocal spam"
  
      def do_global():
          global spam
          spam = "global spam"
  
      spam = "test spam"
      do_local()
      print("After local assignment:", spam)
      do_nonlocal()
      print("After nonlocal assignment:", spam)
      do_global()
      print("After global assignment:", spam)
  
  scope_test()
  print("In global scope:", spam) 

  After local assignment: test spam
  After nonlocal assignment: nonlocal spam
  After global assignment: nonlocal spam
  In global scope: global spam
 - 지역 대입이 (이것이 기본입니다) scope_test 의 spam 연결을 바꾸지 않는지에 
   유의하세요
 - nonlocal 대입은 scope_test 의 spam 연결을 바꾸고 global 대입은 모듈 수준의 
   연결을 바꿈
 - global 대입 전에는 spam의 연결이 없다는 것도 볼 수 있음
 
○ 클래스 정의 문법
  class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
 - 함수 정의(def 문)처럼, 클래스 정의는 어떤 효과가 생기기 위해서는 먼저 
   실행되어야 합니다. (상상컨대 클래스 정의를 if 문의 분기나 함수 내부에 놓을 
   수 있습니다)
 - 클래스 정의에 진입할 때, 새 이름 공간이 만들어지고 지역 스코프로 사용됩니다
   그래서, 모든 지역 변수들로의 대입은 이 새 이름 공간으로 갑니다. 특히, 함수 
   정의는 새 함수의 이름을 이곳에 연결합니다.
 - 클래스 정의가 (끝을 통해) 정상적으로 끝날 때, 클래스 객체 가 만들어집니다. 
   이것은 기본적으로 클래스 정의 때문에 만들어진 이름 공간의 내용물들을 감싸는 
   싸개입니다; 다음 섹션에서 클래스 객체에 대해 더 배우게 됩니다. 원래의 지역 
   스코프가 (클래스 정의에 들어가기 직전에 유효하던 것) 다시 사용되고, 클래스 
   객체는 클래스 정의 헤더에서 주어진 클래스 이름 (예에서 ClassName) 으로 여기에
   연결됩니다.

○ 클래스 객체
 - 클래스 객체는 두 종류의 연산을 지원함. 어트리뷰트 참조와 인스턴스 만들기
 - 올바른 어트리뷰트 이름은 클래스 객체가 만들어질 때 클래스의 이름 공간에 
   있던 모든 이름임
  class MyClass:
      """A simple example class"""
      i = 12345
  
      def f(self):
          return 'hello world'   

 - __doc__ 도 역시 올바른 어트리뷰트고, 클래스에 속하는 독스트링을 돌려줍니다: 
   "A simple example class".
 - 클래스 인스턴스 만들기 는 함수 표기법을 사용합니다. 클래스 객체가 클래스의 
   새 인스턴스를 돌려주는 매개변수 없는 함수인 체합니다.
  x = MyClass()
   는 클래스의 새 인스턴스를 만들고 이 객체를 지역변수 x에 대입함
 - 인스턴스 만들기 연산 (클래스 객체 《호출하기》) 은 빈 객체를 만듭니다. 많은 
   클래스는 특정한 초기 상태로 커스터마이즈된 인스턴스로 객체를 만드는 것을 
   좋아합니다. 그래서 클래스는 이런 식으로 __init__() 라는 이름의 특수 메서드 
   정의할 수 있습니다:   
  def __init__(self):
    self.data = []
 - 클래스가 __init__() 메서드를 정의할 때, 클래스 인스턴스 만들기는 새로 만들어진
   클래스 인스턴스에 대해 자동으로 __init__() 를 호출합니다.   
 - 클래스 인스턴스 만들기 연산자로 주어진 인자들은 __init__() 로 전달됩니다

○ 인스턴스 객체
 - 인스턴스 객체가 이해하는 오직 한가지 연산은 어트리뷰트 참조입니다. 
   두 가지 종류의 올바른 어트리뷰트 이름이 있습니다: 데이터 어트리뷰트와 메서드.
 - 데이터 어트리뷰트는 선언될 필요 없습니다; 지역 변수처럼, 처음 대입될 때 
   태어납니다. 예를 들어, x 가 위에서 만들어진 MyClass 의 인스턴스면, 
   다음과 같은 코드 조각은 트레이스 없이 값 16 을 인쇄합니다 
  x.counter = 1
  while x.counter < 10:
      x.counter = x.counter * 2
  print(x.counter)
  del x.counter
 - 메서드는 객체에 《속하는》 함수입니다.
 - (파이썬에서, 메서드 라는 용어는 클래스 인스턴스에만 사용되지 않습니다; 
   다른 객체 형들도 메서드를 가질 수 있습니다. 예를 들어, 리스트 객체는 append, 
   insert, remove, sort 등과 같은 메서드들을 갖습니다. 하지만, 앞으로의 논의에서,
   명시적으로 언급하지 않는 한, 메서드 라는 용어를 클래스 인스턴스 객체의
   메서드에만 사용할 것입니다.)
 - 함수 객체인 클래스의 모든 어트리뷰트들은 상응하는 인스턴스의 메서드들을 
   정의합니다
 - 우리의 예제에서, x.f 는 올바른 메서드 참조인데, MyClass.f 가 함수이기 
   때문입니다.
 - x.f 는 MyClass.f 와 같은 것이 아닙니다. 이것은 함수 객체가 아니라 메서드 
   객체임

○ 메서드 객체
 - f() 의 함수 정의가 인자를 지정했음에도 불구하고, 위에서 x.f() 는 인자 없이 
   호출된 것을 알아챘을 것입니다. 인자는 어떻게 된 걸까? 확실히 파이썬은 인자를 
   필요로 하는 함수를 인자 없이 호출하면 예외를 일으킵니다. 인자가 실제로는 
   사용되지 않는다 해도…    
 - 메서드의 특별함은 인스턴스 객체가 함수의 첫 번째 인자로 전달된다는 것입니다. 
   우리 예에서, 호출 x.f()은 정확히 MyClass.f(x) 와 동등함
 - n 개의 인자들의 목록으로 메서드를 호출하는 것은, 첫 번째 인자 앞에 메서드의 
   인스턴스 객체를 삽입해서 만든 인자 목록으로 상응하는 함수를 호출하는 것과 
   동등합니다.
 - 데이터 어트리뷰트가 아닌 인스턴스 어트리뷰트를 참조하면, 그것의 클래스가 검색됨
 - 만약 그 이름이 함수 객체인 올바른 클래스 어트리뷰트면, 인스턴스 객체와 방금
   발견된 함수 객체를 (가리키는 포인터들을) 추상 객체에 함께 묶어서 메서드 객체를
   만듭니다  
 - 메서드 객체가 인자 목록으로 호출되면, 인스턴스 객체와 인자 목록으로부터 
   새 인자 목록이 구성된 후, 함수 객체를 이 새 인자 목록으로 호출합니다.

○ 클래스와 인스턴스 변수
 - 인스턴스 변수는 인스턴스별 데이터를 위한 것이고 클래스 변수는 그 클래스의 
   모든 인스턴스에서 공유되는 어트리뷰트와 메서드를 위한 것임
  class Dog:
      kind = 'canine'         # class variable shared by all instances
      def __init__(self, name):
          self.name = name    # instance variable unique to each instance      

  >>> d = Dog('Fido')
  >>> e = Dog('Buddy')
  >>> d.kind                  # shared by all dogs
  'canine'
  >>> e.kind                  # shared by all dogs
  'canine'
  >>> d.name                  # unique to d
  'Fido'
  >>> e.name                  # unique to e
  'Buddy'

○ 기타 주의사항들
 - 인스턴스와 클래스 모두에서 같은 어트리뷰트 이름이 등장하면, 어트리뷰트 조회는
   인스턴스를 우선함
  >>> class Warehouse:
  	purpose = 'storage'
  	region = 'west'        
  >>> w1 = Warehouse()
  >>> print(w1.purpose, w1.region)
  storage west
  >>> w2 = Warehouse()
  >>> w2.region = 'east'
  >>> print(w2.purpose, w2.region)
  storage east
  >>> print(w1.purpose, w1.region)
  storage west
 - 데이터 어트리뷰트는 메서드 뿐만 아니라 객체의 일반적인 사용자 (《클라이언트》)
   에 의해서 참조될 수도 있습니다. 달리 표현하면, 클래스는 순수하게 추상적인 
   데이터형을 구현하는데 사용될 수 없습니다. 사실, 파이썬에서는 데이터 은닉을 
   강제할 방법이 없습니다 - 모두 관례에 의존합니다. 
 - 클라이언트는 데이터 어트리뷰트를 건드려서 메서드들에 의해 유지되는 불변성들을 
   망가뜨릴 수 있습니다. 클라이언트는 이름 충돌을 피하는 한 메서드들의 유효성을 
   손상하지 않고도 그들 자신의 데이터 어트리뷰트를 인스턴스 객체에 추가할 수도
   있음에 유의하세요 - 다시 한번, 명명 규칙은 여러 골칫거리를 피할 수 있게 합니다.
 - 종종, 메서드의 첫 번째 인자는 self 라고 불립니다. 이것은 관례일 뿐입니다: 
   이름 self 는 파이썬에서 아무런 특별한 의미를 갖지 않습니다. 하지만, 이 규칙을 
   따르지 않을 때 여러분의 코드가 다른 파이썬 프로그래머들이 읽기에 불편하고, 
   클래스 브라우저 프로그램도 이런 규칙에 의존하도록 작성되었다고 상상할 수 
   있음에 유의하세요.
 - 함수 정의가 클래스 정의에 텍스트 적으로 둘러싸일 필요는 없습니다: 함수 객체를 
   클래스의 지역 변수로 대입하는 것 역시 가능
  # Function defined outside the class
  def f1(self, x, y):
      return min(x, x+y)
  
  class C:
      f = f1
  
      def g(self):
          return 'hello world'
  
      h = g   

 - 메서드는 self 인자의 메서드 어트리뷰트를 사용해서 다른 메서드를 호출할 수 
   있음
  class Bag:
      def __init__(self):
          self.data = []
  
      def add(self, x):
          self.data.append(x)
  
      def addtwice(self, x):
          self.add(x)
          self.add(x)   
 - 메서드는 일반 함수들과 마찬가지로 전역 이름을 참조할 수 있습니다. 메서드에 
   결합한 전역 스코프는 그것의 정의를 포함하는 모듈입니다. (클래스는 결코 전역 
   스코프로 사용되지 않습니다.) 
 - 각 값은 객체고, 그러므로 클래스를 갖음, object.__class__ 에 저장되어 있음
  >>> i = 1
  >>> i.__class__
  <class 'int'> 

○ 상속
 - 파생 클래스 정의의 문법
  class DerivedClassName(BaseClassName):
      <statement-1>
      .
      .
      .
      <statement-N>   

 - 베이스 클래스 이름의 자리에 다른 임의의 표현식도 허락됩니다. 예를 들어, 
   베이스 클래스가 다른 모듈에 정의되어 있을 때 유용합니다:
  class DerivedClassName(modname.BaseClassName): 
 - 파생 클래스는 베이스 클래스의 메서드들을 재정의할 수 있음
 - 베이스 클래스에 정의된 다른 메서드를 호출하는 베이스 클래스의 메서드는 
   재정의된 파생 클래스의 메서드를 호출하게 됩니다. (C++ 프로그래머를 위한 
   표현으로: 파이썬의 모든 메서드는 실질적으로 virtual 입니다.)
 - 같은 이름의 베이스 클래스 메서드를 단순히 갈아치우기보다 사실은 확장하고 
   싶을 수 있습니다. 베이스 클래스의 메서드를 직접 호출하는 간단한 방법이 
   있습니다: 단지 BaseClassName.methodname(self, arguments) 를 호출하면 됩니다
   (이것은 베이스 클래스가 전역 스코프에서 BaseClassName 으로 액세스 될 수 있을
   때만 동작함에 주의하세요.)
 - 인스턴스의 형을 검사하려면 isinstance() 를 사용합니다: isinstance(obj, int)는
   obj.__class__ 가 int 거나 int 에서 파생된 클래스인 경우만 True 가 됩니다.
 - 클래스 상속을 검사하려면 issubclass() 를 사용합니다: issubclass(bool, int)는 
   True 인데, bool 이 int 의 서브 클래스이기 때문입니다. 하지만, 
   issubclass(float, int) 는 False 인데, float 는 int 의 서브 클래스가 아니기 
   때문입니다. 

○ 다중 상속
 - 여러 개의 베이스 클래스를 갖는 클래스 정의는 이런 식
  class DerivedClassName(Base1, Base2, Base3):
      <statement-1>
      .
      .
      .
      <statement-N> 
 - 메서드 결정 순서는 super() 로의 협력적인 호출을 지원하기 위해 동적으로 변경
   됩니다. 이 접근법은 몇몇 다른 다중 상속 언어들에서 call-next-method 라고 
   알려져 있고, 단일 상속 언어들에서 발견되는 super 호출보다 더 강력합니다.

○ 비공개 변수
 - 객체 내부에서만 액세스할 수 있는 《비공개》 인스턴스 변수는 파이썬에 존재하지
   않음
 - 하지만, 대부분의 파이썬 코드에서 따르고 있는 규약이 있습니다: 밑줄로 시작하는
   이름은 (예를 들어, _spam) API의 공개적이지 않은 부분으로 취급되어야 합니다 
   (그것이 함수, 메서드, 데이터 멤버중 무엇이건 간에). 구현 상세이고 통보 없이 
   변경되는 대상으로 취급되어야 합니다.
 - 이름 뒤섞기 (name mangling) 라고 불리는 메커니즘에 대한 제한된 지원이 
   있습니다. __spam 형태의 (최소 두 개의 밑줄로 시작하고, 최대 한 개의 밑줄로 
   끝납니다) 모든 식별자는 _classname__spam 로 텍스트 적으로 치환되는데, 
   classname 은 현재 클래스 이름에서 앞에 오는 밑줄을 제거한 것입니다. 이 
   뒤섞기는 클래스 정의에 등장하는 이상, 식별자의 문법적 위치와 무관하게 
   수행됩니다.
  class Mapping:
      def __init__(self, iterable):
          self.items_list = []
          self.__update(iterable)
  
      def update(self, iterable):
          for item in iterable:
              self.items_list.append(item)
  
      __update = update   # private copy of original update() method
  
  class MappingSubclass(Mapping):
  
      def update(self, keys, values):
          # provides new signature for update()
          # but does not break __init__()
          for item in zip(keys, values):
              self.items_list.append(item) 
  
 - 위의 예는 MappingSubclass가 __update 식별자를 도입하더라도 작동합니다. 
   Mapping 클래스에서는 _Mapping__update로 MappingSubclass 클래스에서는 
   _MappingSubclass__update로 각각 대체 되기 때문
 - exec() 나 eval() 로 전달된 코드는 호출하는 클래스의 클래스 이름을 현재 
   클래스로 여기지 않는다는 것에 주의하세요; 이것은 global 문의 효과와 유사한데, 
   효과가 함께 바이트-컴파일된 코드로 제한됩니다. 같은 제약이 __dict__ 를 직접 
   참조할 때뿐만 아니라, getattr(), setattr(), delattr() 에도 적용됩니다.
 
○ 잡동사니
 - 때로 몇몇 이름 붙은 데이터 항목들을 함께 묶어주는 파스칼의 《record》 나 
   C의 《struct》 와 유사한 데이터형을 갖는 것이 쓸모 있습니다. 빈 클래스 정의가
   훌륭히 할 수 있는 일입니다:
  class Employee:
      pass
  
  john = Employee()  # Create an empty employee record
  
  # Fill the fields of the record
  john.name = 'John Doe'
  john.dept = 'computer lab'
  john.salary = 1000 
 - 파일 객체로부터 데이터를 포맷하는 함수가 있을 때, 대신 문자열 버퍼에서 
   데이터를 읽는 메서드 read() 와 readline() 을 제공하는 클래스를 정의한 후 
   인자로 전달할 수 있습니다.
 - 인스턴스 메서드 객체도 어트리뷰트를 갖습니다: m.__self__ 는 메서드 m() 과 
   결합한 인스턴스 객체이고, m.__func__ 는 메서드에 상응하는 함수 객체입니다.

○ 이터레이터
 - 대부분의 컨테이너 객체들을 for 문으로 루핑
  for element in [1, 2, 3]:
      print(element)
  for element in (1, 2, 3):
      print(element)
  for key in {'one':1, 'two':2}:
      print(key)
  for char in "123":
      print(char)
  for line in open("myfile.txt"):
      print(line, end='') 
 - 무대 뒤에서, for 문은 컨테이너 객체에 대해 iter() 를 호출합니다
 - 이 함수는 메서드 __next__() 를 정의하는 이터레이터 객체를 돌려주는데, 이 
   메서드는 컨테이너의 요소들을 한 번에 하나씩 액세스합니다
 - 남은 요소가 없으면, __next__() 는 StopIteration 예외를 일으켜서 for 루프에 
   종료를 알립니다.
 - next() 내장 함수를 사용해서 __next__() 메서드를 호출할 수 있습니다;
  >>> s = 'abc'
  >>> it = iter(s)
  >>> it
  <str_iterator object at 0x000000000351BA00>
  >>> next(it)
  'a'
  >>> next(it)
  'b'
  >>> next(it)
  'c'
  >>> next(it)
  Traceback (most recent call last):
    File "<pyshell#34>", line 1, in <module>
      next(it)
  StopIteration
 - __next__() 메서드를 가진 객체를 돌려주는 __iter__() 메서드를 정의
 - 클래스가 __next__() 를 정의하면, __iter__() 는 그냥 self 를 돌려줄 수 있음
  class Reverse:
      """Iterator for looping over a sequence backwards."""
      def __init__(self, data):
          self.data = data
          self.index = len(data)
  
      def __iter__(self):
          return self
  
      def __next__(self):
          if self.index == 0:
              raise StopIteration
          self.index = self.index - 1
          return self.data[self.index] 
  
  >>> rev = Reverse('spam')
  >>> iter(rev)
  <__main__.Reverse object at 0x00A1DB50>
  >>> for char in rev:
  ...     print(char)
  ...
  m
  a
  p
  s
  
○ 제너레이터
 - 제너레이터는 이터레이터를 만드는 간단하고 강력한 도구임
 - 일반적인 함수처럼 작성되지만 값을 돌려주고 싶을 때마다 yield 문을 사용함
 - 제너레이터에 next() 가 호출될 때마다, 제너레이터는 떠난 곳에서 실행을 재개함
   (모든 데이터 값들과 어떤 문장이 마지막으로 실행되었는지 기억합니다). 
  def reverse(data):
      for index in range(len(data)-1, -1, -1):
          yield data[index]  
  
  >>> for char in reverse('golf'):
  ...     print(char)
  ...
  f
  l
  o
  g  
 - 제너레이터가 간단한 이유는 __iter__() 와 __next__() 메서드가 저절로 
   만들어지기 때문입니다.
 - 또 하나의 주요 기능은 지역 변수들과 실행 상태가 호출 간에 자동으로 보관된다는
   것입니다. 이것은 self.index 나 self.data 와 같은 인스턴스 변수를 사용하는 
   접근법에 비교해 함수를 쓰기 쉽고 명료하게 만듭니다.
 - 제너레이터가 종료할 때 자동으로 StopIteration 을 일으킵니다

○ 제너레이터 표현식
 - 간단한 제너레이터는 리스트 컴프리헨션과 비슷하지만, 대괄호 대신 괄호를 
   사용하는 문법을 사용한 표현식으로 간결하게 코딩할 수 있습니다. 이 표현식들은 
   둘러싸는 함수가 제너레이터를 즉시 사용하는 상황을 위해 설계되었습니다. 
   제너레이터 표현식은 완전한 제너레이터 정의보다 간결하지만, 융통성은 떨어지고,
   비슷한 리스트 컴프리헨션보다 메모리를 덜 쓰는 경향이 있습니다. 
  >>> sum(i*i for i in range(10))                 # sum of squares
  285
  
  >>> xvec = [10, 20, 30]
  >>> yvec = [7, 5, 3]
  >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
  260
  
  >>> unique_words = set(word for line in page  for word in line.split())
  
  >>> valedictorian = max((student.gpa, student.name) for student in graduates)
  
  >>> data = 'golf'
  >>> list(data[i] for i in range(len(data)-1, -1, -1))
  ['f', 'l', 'o', 'g'] 
 - 모듈 객체는 __dict__ 라고 불리는 비밀스러운 읽기 전용 어트리뷰트를 갖는데, 
   모듈의 이름 공간을 구현하는데 사용하는 딕셔너리를 돌려줍니다;
 - 이름 __dict__ 는 어트리뷰트 이지만 전역 이름은 아닙니다. 명백하게, 이것을 
   사용하는 것은 이름 공간 구현의 추상화를 파괴하는 것이고, 사후 디버거와 같은 
   것들로만 제한되어야 합니다.
   
○ 운영 체제 인터페이스
 - os 모듈은 운영 체제와 상호 작용하기 위한 수십 가지 함수들을 제공함
  >>> import os
  >>> os.getcwd()      # Return the current working directory
  'C:\\Python38'
  >>> os.chdir('/server/accesslogs')   # Change current working directory
  >>> os.system('mkdir today')   # Run the command mkdir in the system shell
  0   
 - from os import * 대신에 import os 스타일을 사용해야 함. 그래야 os.open()이
   내장 open()을 가리는 것을 피할 수 있는데, 두 함수는 아주 다르게 동작함
 - os 와 같은 큰 모듈과 작업할 때, 내장 dir() 과 help() 함수는 대화형 도우미로 
   쓸모가 있음
  >>> import os
  >>> dir(os)
  <returns a list of all module functions>
  >>> help(os)
  <returns an extensive manual page created from the module's docstrings>   
 - 일상적인 파일과 디렉터리 관리 작업을 위해, shutil 모듈은 사용하기 쉬운 더 
   고수준의 인터페이스를 제공
  >>> import shutil
  >>> shutil.copyfile('data.db', 'archive.db')
  'archive.db'
  >>> shutil.move('/build/executables', 'installdir')
  'installdir'   
 
○ 파일 와일드카드
 - glob 모듈은 디렉터리 와일드카드 검색으로 파일 목록을 만드는 함수를 제공
  >>> import glob
  >>> glob.glob('*.py')
  ['primes.py', 'random.py', 'quote.py'] 

○ 명령행 인자
 - 일반적인 유틸리티 스크립트는 종종 명령행 인자를 처리해야 할 필요가 있습니다.
   이 인자들은 sys 모듈의 argv 어트리뷰트에 리스트로 저장됩니다. 예를 들어, 
   명령행에서 python demo.py one two three 를 실행하면 다음과 같은 결과가 
   출력됩니다:
  >>>
  >>> import sys
  >>> print(sys.argv)
  ['demo.py', 'one', 'two', 'three']
 - argparse 모듈은 명령 줄 인자를 처리하는 더 정교한 메커니즘을 제공합니다. 
   다음 스크립트는 하나 이상의 파일명과 선택적으로 표시할 줄 수를 추출합니다:
  import argparse
  
  parser = argparse.ArgumentParser(prog = 'top',
      description = 'Show top lines from each file')
  parser.add_argument('filenames', nargs='+')
  parser.add_argument('-l', '--lines', type=int, default=10)
  args = parser.parse_args()
  print(args)
 - python top.py --lines=5 alpha.txt beta.txt를 사용하여 명령 줄에서 실행할 때,
   스크립트는 args.lines를 5로, args.filenames를 ['alpha.txt', 'beta.txt']로 
   설정합니다.

○ 에러 출력 리디렉션과 프로그램 종료
 - sys 모듈은 stdin, stdout, stderr 어트리뷰트도 갖고 있습니다. 가장 마지막 
   것은 stdout 이 리디렉트 되었을 때도 볼 수 있는 경고와 에러 메시지들을 
   출력하는데 쓸모가 있습니다:
  >>> sys.stderr.write('Warning, log file not found starting a new one\n')
  Warning, log file not found starting a new one
 - 스크립트를 종료하는 가장 직접적인 방법은 sys.exit() 를 쓰는 것입니다.

○ 문자열 패턴 매칭
 - re 모듈은 고급 문자열 처리를 위한 정규식 도구들을 제공합니다. 복잡한 매칭과 
   조작을 위해, 정규식은 간결하고 최적화된 솔루션을 제공합니다:
  >>> import re
  >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
  ['foot', 'fell', 'fastest']
  >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
  'cat in the hat'
 - 단지 간단한 기능만 필요한 경우에는, 문자열 메서드들이 선호되는데 읽기 쉽고 
   디버깅이 쉽기 때문입니다:
  >>> 'tea for too'.replace('too', 'two')
  'tea for two'  
  
○ 수학
 - math 모듈은 부동 소수점 연산을 위한 하부 C 라이브러리 함수들에 대한 액세스를 
   제공  
  >>> import math
  >>> math.cos(math.pi / 4)
  0.70710678118654757
  >>> math.log(1024, 2)
  10.0
 - random 모듈은 무작위 선택을 할 수 있는 도구들을 제공합니다:
  >>> random.choice(['apple', 'pear', 'banana'])
  'apple'
  >>> random.sample(range(100), 10)   # sampling without replacement
  [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
  >>> random.random()    # random float
  0.17970987693706186
  >>> random.randrange(6)    # random integer chosen from range(6)
  4   
  
 - statistics 모듈은 수치 데이터의 기본적인 통계적 특성들을 (평균, 중간값, 분산,
   등등) 계산합니다.
  >>> import statistics
  >>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
  >>> statistics.mean(data)
  1.6071428571428572
  >>> statistics.median(data)
  1.25
  >>> statistics.variance(data)
  1.3720238095238095  
 - SciPy 프로젝트 <https://scipy.org>는 다른 수치 계산용 모듈들을 많이 갖고 있음
 
○ 인터넷 액세스
 - 인터넷을 액세스하고 인터넷 프로토콜들을 처리하는 많은 모듈이 있음
 - 가장 간단한 두 개는 URL에서 데이터를 읽어오는 urllib.request 와 메일을 보내는
   smtplib 임
  >>> from urllib.request import urlopen
  >>> with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
  ...     for line in response:
  ...         line = line.decode('utf-8')  # Decoding the binary data to text.
  ...         if 'EST' in line or 'EDT' in line:  # look for Eastern Time
  ...             print(line)
  
  <BR>Nov. 25, 09:43:32 PM EST

  >>> import smtplib
  >>> server = smtplib.SMTP('localhost')
  >>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
  ... """To: jcaesar@example.org
  ... From: soothsayer@example.org
  ...
  ... Beware the Ides of March.
  ... """)
  >>> server.quit()  
 - 두 번째 예는 localhost 에서 메일 서버가 실행되고 있어야 함
 
○ 날짜와 시간
 - datetime 모듈은 날짜와 시간을 조작하는 클래스들을 제공하는데, 간단한 방법과 
   복잡한 방법 모두 제공합니다. 날짜와 시간 산술이 지원되지만, 구현의 초점은 
   출력 포매팅과 조작을 위해 효율적으로 멤버를 추출하는 데에 맞춰져 있습니다. 
   모듈은 시간대를 고려하는 객체들도 지원합니다.
  >>> # dates are easily constructed and formatted
  >>> from datetime import date
  >>> now = date.today()
  >>> now
  datetime.date(2003, 12, 2)
  >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
  '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'
  
  >>> # dates support calendar arithmetic
  >>> birthday = date(1964, 7, 31)
  >>> age = now - birthday
  >>> age.days
  14368  
  
○ 데이터 압축
 - 일반적인 데이터 보관 및 압축 형식들을 다음과 같은 모듈들이 직접 지원합니다: zlib, gzip, bz2, lzma, zipfile, tarfile.
  >>> import zlib
  >>> s = b'witch which has which witches wrist watch'
  >>> len(s)
  41
  >>> t = zlib.compress(s)
  >>> len(t)
  37
  >>> zlib.decompress(t)
  b'witch which has which witches wrist watch'
  >>> zlib.crc32(s)
  226805979

○ 성능 측정
 - timeit 모듈은 적당한 성능 이점을 신속하게 보여줌
  >>> from timeit import Timer
  >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
  0.57535828626024577
  >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
  0.54962537085770791 
 - timeit 의 정밀도와는 대조적으로, profile 과 pstats 모듈은 큰 블록의 코드에서
   시간 임계 섹션을 식별하기 위한 도구들을 제공함

○ 품질 관리
 - 고품질의 소프트웨어를 개발하는 한 가지 접근법은 개발되는 각 함수에 대한 
   테스트를 작성하고, 그것들을 개발 프로세스 중에 자주 실행하는 것임
 - doctest 모듈은 모듈을 훑어보고 프로그램의 독스트링들에 내장된 테스트들을 검사
   하는 도구를 제공함
 - 테스트 만들기는 평범한 호출을 그 결과와 함께 독스트링으로 복사해서 붙여넣기를
   하는 수준으로 간단해짐
 - 사용자에게 예제를 함께 제공해서 설명서를 개선하고, doctest 모듈이 설명서에서 
   코드가 여전히 사실인지 확인하도록 함
  def average(values):
      """Computes the arithmetic mean of a list of numbers.
  
      >>> print(average([20, 30, 70]))
      40.0
      """
      return sum(values) / len(values)
  
  import doctest
  doctest.testmod()   # automatically validate the embedded tests
 - unittest 모듈은 doctest 모듈만큼 쉬운 것은 아니지만, 더욱 포괄적인 테스트 
   집합을 별도의 파일로 관리할 수 있게 함
  import unittest
  
  class TestStatisticalFunctions(unittest.TestCase):
  
      def test_average(self):
          self.assertEqual(average([20, 30, 70]), 40.0)
          self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
          with self.assertRaises(ZeroDivisionError):
              average([])
          with self.assertRaises(TypeError):
              average(20, 30, 70)
  
  unittest.main()  # Calling from the command line invokes all tests   

○ 배터리가 포함됨
 - 파이썬은 《배터리가 포함됩니다》 철학을 갖고 있음
 - 이는 더 큰 패키지의 정교하고 강력한 기능을 통해 가장 잘 나타남
 - xmlrpc.client 와 xmlrpc.server 모듈은 원격 프로시저 호출을 구현하는 일을 
   거의 사소한 일로 만듭니다. 모듈의 이름에도 불구하고, XML에 대한 직접적인 
   지식이나 처리가 필요하지 않습니다.
 - email 패키지는 MIME 및 기타 RFC 2822 기반 메시지 문서를 포함하는 전자 메일 
   메시지를 관리하기 위한 라이브러리입니다. 실제로 메시지를 보내고 받는 
   smtplib 와 poplib 와는 달리, email 패키지는 복잡한 메시지 구조 
   (첨부 파일 포함) 를 작성하거나 해독하고 인터넷 인코딩과 헤더 프로토콜을 
   구현하기 위한 완벽한 도구 상자를 가지고 있습니다.
 - json 패키지는 널리 사용되는 데이터 교환 형식을 파싱하기위한 강력한 지원을 
   제공합니다. 
 - csv 모듈은 데이터베이스와 스프레드시트에서 일반적으로 지원되는 쉼표로 구분된
   값 형식으로 파일을 직접 읽고 쓸 수 있도록 지원합니다.
 - XML 처리는 xml.etree.ElementTree, xml.dom 및 xml.sax 패키지에 의해 지원됨
 - 이러한 모듈과 패키지를 함께 사용하면 파이썬 응용 프로그램과 다른 도구 간의 
   데이터 교환이 크게 단순해집니다.
 - sqlite3 모듈은 SQLite 데이터베이스 라이브러리의 래퍼인데, 약간 비표준 SQL 
   구문을 사용하여 업데이트되고 액세스 될 수 있는 퍼시스턴트 데이터베이스를 제공
 - 국제화는 gettext, locale, 그리고 codecs 패키지를 포함한 많은 모듈에 의해 지원    
     
○ 출력 포매팅
 - reprlib 모듈은 크거나 깊게 중첩된 컨테이너의 축약 된 디스플레이를 위해 
   커스터마이즈된 repr() 의 버전을 제공
  >>> import reprlib
  >>> reprlib.repr(set('supercalifragilisticexpialidocious'))
  "{'a', 'c', 'd', 'e', 'f', 'g', ...}"   
 - pprint 모듈은 인터프리터가 읽을 수 있는 방식으로 내장 객체나 사용자 정의 
   객체를 인쇄하는 것을 보다 정교하게 제어할 수 있게 함
 - 결과가 한 줄보다 길면 《예쁜 프린터》가 줄 바꿈과 들여쓰기를 추가하여 데이터 
   구조를 보다 명확하게 나타냄
  >>> import pprint
  >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
  ...     'yellow'], 'blue']]]
  ...
  >>> pprint.pprint(t, width=30)
  [[[['black', 'cyan'],
     'white',
     ['green', 'red']],
    [['magenta', 'yellow'],
     'blue']]]   

 - textwrap 모듈은 텍스트의 문단을 주어진 화면 너비에 맞게 포맷함
  >>> import textwrap
  >>> doc = """The wrap() method is just like fill() except that it returns
  ... a list of strings instead of one big string with newlines to separate
  ... the wrapped lines."""
  ...
  >>> print(textwrap.fill(doc, width=40))
  The wrap() method is just like fill()
  except that it returns a list of strings
  instead of one big string with newlines
  to separate the wrapped lines. 
 - locale 모듈은 문화권 특정 데이터 포맷의 데이터베이스에 액세스함
 - locale의 format 함수의 grouping 어트리뷰트는 그룹 구분 기호로 숫자를 
   포매팅하는 직접적인 방법을 제공
  >>> import locale
  >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
  'English_United States.1252'
  >>> conv = locale.localeconv()          # get a mapping of conventions
  >>> x = 1234567.8
  >>> locale.format("%d", x, grouping=True)
  '1,234,567'
  >>> locale.format_string("%s%.*f", (conv['currency_symbol'],
  ...                      conv['frac_digits'], x), grouping=True)
  '$1,234,567.80'   
 
○ 템플릿
 - string 모듈은 다재다능한 Template 클래스를 포함하고 있는데, 최종 사용자가 
   편집하기에 적절한 단순한 문법을 갖고 있습니다. 따라서 사용자는 응용 
   프로그램을 변경하지 않고도 응용 프로그램을 커스터마이즈할 수 있습니다.
 - 형식은 $ 와 유효한 파이썬 식별자 (영숫자와 밑줄)로 만들어진 자리표시자 이름을
   사용합니다. 중괄호를 사용하여 자리표시자를 둘러싸면 공백없이 영숫자가 
   뒤따르도록 할 수 있습니다. $$ 을 쓰면 하나의 이스케이프 된 $ 를 만듭니다
  >>> from string import Template
  >>> t = Template('${village}folk send $$10 to $cause.')
  >>> t.substitute(village='Nottingham', cause='the ditch fund')
  'Nottinghamfolk send $10 to the ditch fund.'
 - substitute() 메서드는 자리표시자가 딕셔너리나 키워드 인자로 제공되지 않을 때
   KeyError 를 일으킴
 - 메일 병합 스타일 응용 프로그램의 경우 사용자가 제공한 데이터가 불완전할 수 
   있으며 safe_substitute() 메서드가 더 적절할 수 있습니다. 데이터가 누락 된 
   경우 자리표시자를 변경하지 않음
  >>> t = Template('Return the $item to $owner.')
  >>> d = dict(item='unladen swallow')
  >>> t.substitute(d)
  Traceback (most recent call last):
    ...
  KeyError: 'owner'
  >>> t.safe_substitute(d)
  'Return the unladen swallow to $owner.'
 - Template 서브 클래스는 사용자 정의 구분자를 지정할 수 있습니다. 예를 들어 
   사진 브라우저를 위한 일괄 이름 바꾸기 유틸리티는 현재 날짜, 이미지 시퀀스 
   번호 또는 파일 형식과 같은 자리표시자에 백분율 기호를 사용하도록 선택할 수 
   있음
  >>> import time, os.path
  >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
  >>> class BatchRename(Template):
  ...     delimiter = '%'
  >>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
  Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f
  
  >>> t = BatchRename(fmt)
  >>> date = time.strftime('%d%b%y')
  >>> for i, filename in enumerate(photofiles):
  ...     base, ext = os.path.splitext(filename)
  ...     newname = t.substitute(d=date, n=i, f=ext)
  ...     print('{0} --> {1}'.format(filename, newname))
  
  img_1074.jpg --> Ashley_0.jpg
  img_1076.jpg --> Ashley_1.jpg
  img_1077.jpg --> Ashley_2.jpg   

○ 바이너리 데이터 레코드 배치 작업

          
