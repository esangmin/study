[edge-manager Dockerfile]

FROM maven:3-alpine as builder

# make source folder
RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app

# 소스를 작업폴더로 복사하고 빌드
COPY settings.xml /root/.m2/settings.xml
COPY . /usr/src/app
RUN mvn clean package -DskipTests


FROM openjdk:8-jre-alpine

# 위에서 생성한 앱의 빌드산출물을 nginx의 샘플 앱이 사용하던 폴더로 이동
COPY --from=builder /usr/src/app/target/edge-manager-1.0.0-SNAPSHOT.jar /app.jar

# 8080포트 오픈하고 실행
EXPOSE 8080
CMD ["/usr/bin/java", "-jar", "-Dspring.profiles.active=dev", "/app.jar"]


./settings.xml

<settings>
  <servers>
    <server>
      <id>nexus</id>
      <username>admin</username>
      <password>smcs</password>
    </server>
  </servers>  
  <mirrors>
    <mirror>
      <!--This sends everything else to /public -->
      <id>nexus</id>
      <mirrorOf>*</mirrorOf>
      <url>http://192.168.1.53:8081/repository/maven-public/</url>
    </mirror>
  </mirrors>
  <profiles>
    <profile>
      <id>nexus</id>
      <!--Enable snapshots for the built in central repo to direct -->
      <!--all requests to nexus via the mirror -->
      <repositories>
        <repository>
          <id>central</id>
          <url>http://central</url>
          <releases><enabled>true</enabled></releases>
          <snapshots>
          	<enabled>true</enabled>
						<updatePolicy>always</updatePolicy>
          </snapshots>
        </repository>
      </repositories>
      <pluginRepositories>
        <pluginRepository>
          <id>central</id>
          <url>http://central</url>
          <releases><enabled>true</enabled></releases>
          <snapshots>
          	<enabled>true</enabled>
						<updatePolicy>always</updatePolicy>
          </snapshots>
        </pluginRepository>
      </pluginRepositories>
    </profile>
  </profiles>
  <activeProfiles>
    <!--make the profile active all the time -->
    <activeProfile>nexus</activeProfile>
  </activeProfiles>
</settings>






[edge-manager-web Dockerfile]

FROM node as builder

# 작업 폴더를 만들고 npm 설치
RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app
ENV PATH /usr/src/app/node_modules/.bin:$PATH
COPY package.json /usr/src/app/package.json
RUN npm install

# 소스를 작업폴더로 복사하고 빌드
COPY . /usr/src/app
RUN npm run build


FROM nginx
# nginx의 기본 설정을 삭제하고 앱에서 설정한 파일을 복사
RUN rm -rf /etc/nginx/conf.d
COPY conf /etc/nginx

# 위에서 생성한 앱의 빌드산출물을 nginx의 샘플 앱이 사용하던 폴더로 이동
COPY --from=builder /usr/src/app/build /usr/share/nginx/html

# 3000포트 오픈하고 nginx 실행
EXPOSE 3000
CMD ["nginx", "-g", "daemon off;"]


./conf/conf.d/default.conf
   
server {
  listen 3000;
  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
  }
  error_page   500 502 503 504  /50x.html;
  location = /50x.html {
    root   /usr/share/nginx/html;
  }
}



[edge-agent 스택파일 compose yml]

version "3.7"
services:
  agent:
    image: ${REGISTRY_NAME}${REGISTRY_PORT}/biot${ARCH_POSTFIX}/edge-agent:${TAG}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /shared-volume:/shared-volume
      - ./config:/config
      - /proc/net/dev:/host/proc/net/dev/:ro
    networks:
      - hostnet
    deploy:
      restart_policy:
        condition: on-failure

networks:
  hostnet:
    external: true
    name: host
    
    
    
[kafka compose yml]

version: '2.1'

networks:
  test:

services:
  zookeeper:
    image: wurstmeister/zookeeper:3.4.6
    container_name: zookeeper
    ports:
      - "2181:2181"
    networks:
      - test

  kafka:
    image: wurstmeister/kafka:2.12-2.4.0
    environment:
      HOSTNAME_COMMAND: "echo $$HOSTNAME"
      PORT_COMMAND: "docker port $$HOSTNAME | cut -d: -f2"
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_LISTENERS: "INTERNAL://_{HOSTNAME_COMMAND}:9090,EXTERNAL://:9092"
#       KAFKA_ADVERTISED_LISTENERS: "INTERNAL://_{HOSTNAME_COMMAND}:9090,EXTERNAL://192.168.0.168:_{PORT_COMMAND}"
#       KAFKA_ADVERTISED_LISTENERS: "INTERNAL://_{HOSTNAME_COMMAND}:9090,EXTERNAL://192.168.43.158:_{PORT_COMMAND}"
#       KAFKA_ADVERTISED_LISTENERS: "INTERNAL://_{HOSTNAME_COMMAND}:9090,EXTERNAL://192.168.1.10:_{PORT_COMMAND}"
      KAFKA_ADVERTISED_LISTENERS: "INTERNAL://_{HOSTNAME_COMMAND}:9090,EXTERNAL://192.168.1.203:_{PORT_COMMAND}"
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: "INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT"
      KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL
#       KAFKA_ADVERTISED_HOST_NAME=127.0.0.1
#       KAFKA_ADVERTISED_PORT=9092
#       KAFKA_CREATE_TOPICS: javainuse-topic:1:1
      KAFKA_DELETE_TOPIC_ENABLE: "true"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    ports:
      - "9092-9094:9092"
    depends_on:
      - zookeeper
    networks:
      - test


○ Configuration 현황
 - dcol         : Rack별 / Pri/Sec별
   . name : SD_M1L_101
   . domain-name: sds.dcol.primary.com
   . operationType: PRIMARY
 - dcol-manager : Rack별 / Pri/Sec별
   . rack-id: SD_M1L_101
   . operation-type: PRIMARY
   . primary-dcol-outer-ip: 192.168.1.135
   . secondary-dcol-outer-ip: 192.168.1.65
   . network-connect-check-ip: 192.168.0.1
 - dcol-manager-web : 전체 동일



[dcol-manager-web 작성]
○ docker image 생성을 위한 폴더 생성
 - docker-ce가 설치된 linux 디바이스에 폴더 생성
 - 빌드된 파일 및 실행 관련 파일 복사

○ Dockerfile 작성
FROM nginx
# nginx의 기본 설정을 삭제하고 앱에서 설정한 파일을 복사
RUN rm -rf /etc/nginx/conf.d
COPY conf /etc/nginx

# 위에서 생성한 앱의 빌드산출물을 nginx의 샘플 앱이 사용하던 폴더로 이동
COPY build /usr/share/nginx/html

# VOLUME ["/usr/share/nginx/html"] -- 꼭 필요한 게 아님

# 3000포트 오픈하고 nginx 실행
EXPOSE 3000
CMD ["nginx", "-g", "daemon off;"]


○ 실행
$ docker build --tag dcol-manager-web:1.0.1.0 .
$ docker run --name dcol-manager-web -d -p 3000:3000 --restart unless-stopped -v /apps/dcol-manager-web/config/config.js:/usr/share/nginx/html/config.js -v /etc/localtime:/etc/localtime:ro dcol-manager-web:1.0.1.0

- -v 옵션에서 호스트 폴더에 해당 파일이 없으면 오류 발생
  . 파일을 폴더로 인식하고 폴더를 생성해줌
- -v 옵션에서 호스트 폴더가 없으면 자동으로 호스트에 폴더를 생성해줌
- -v 옵션을 위해 Dockerfile에 VOLUME을 명시할 필요 없음

$ vi /home/edge/dcol-manager-web/config.js
- 호스트에서 config.js 수정하면 container 다시 시작 필요

$ docker restart dcol-manager-web
$ docker exec dcol-manager-web cat /usr/share/nginx/html/config.js
- browser cache 삭제 필요한 경우가 있음

$ docker tag dcol-manager-web:1.0.1 192.168.0.173:5000/dcol-manager-web:1.0.1
$ docker push 192.168.0.173:5000/dcol-manager-web:1.0.1
- 오류 발생 
no basic auth credentials
  . docker registry는 로컬머신에서 사용하는 것이 아니라면 https만 지원
- 레지스트리에 먼저 로긴해야 함   
$ docker login https://192.168.0.173:5000
Username: edge2
Password: !234qwer



[edge-manager Dockerfile]
○ 기존 Dockerfile
FROM maven:3-alpine as builder

# make source folder
RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app

# 소스를 작업폴더로 복사하고 빌드
COPY settings.xml /root/.m2/settings.xml
COPY . /usr/src/app
RUN mvn clean package -DskipTests


FROM openjdk:8-jre-alpine

# 위에서 생성한 앱의 빌드산출물을 nginx의 샘플 앱이 사용하던 폴더로 이동
COPY --from=builder /usr/src/app/target/edge-manager-1.0.0-SNAPSHOT.jar /app.jar

# 8080포트 오픈하고 실행
EXPOSE 8080
CMD ["/usr/bin/java", "-jar", "-Dspring.profiles.active=dev", "/app.jar"]


○ docker image 생성을 위한 폴더 생성
 - docker-ce가 설치된 linux 디바이스에 폴더 생성
 - 빌드된 파일 및 실행 관련 파일 복사 (기존 SMCS rack 배포하는 폴더체계 그대로)

○ dcol-manager 작성
FROM openjdk:8-jre-alpine

# 빌드산출물을 앱이 사용하던 폴더로 이동
WORKDIR /app
COPY . .

ENV JAVA_OPTS "-Xms128m -Xmx256m -XX:+UseG1GC"
ENV JAVA_OPTS "${JAVA_OPTS} -Xloggc:./logs/gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=30m"
ENV JAVA_OPTS "${JAVA_OPTS} -Dlogging.config=./config/logback-spring.xml" 

#mvn package 시 추가 필요 (export 시는 불필요)
ENV JAVA_OPTS "${JAVA_OPTS} -Dspring.config.location=./config/config.yml" 

# 8080포트 오픈하고 실행
EXPOSE 8080
VOLUME ["/app/config", "/app/logs"]

CMD java $JAVA_OPTS -jar edge-manager-1.0.2-RELEASE.jar

○ .dockerignore 작성
# ignore files for Docker
Dockerfile
.dockerignore
# ignore files for service
*.service
# ignore .git folder
.git
# ignore files of shell script
*.sh

○ 실행
$ docker build --tag dcol-manager:1.0.2.0 .
$ docker run --name dcol-manager -d -p 8080:8080 --restart unless-stopped -v /apps/dcol-manager/config:/app/config -v /apps/dcol-manager/logs:/app/logs -v /etc/localtime:/etc/localtime:ro dcol-manager:1.0.2.0

$ docker run --name dcol-manager -d -p 8080:8080 -v /apps/dcol-manager/config:/app/config -v /apps/dcol-manager/logs:/app/logs -v /etc/localtime:/etc/localtime:ro dcol-manager:1.0.2.0


○ Private registry 이미지 List 조회 (Server에서 해야 함)
$ curl -X GET http://localhost:5000/v2/_catalog
$ curl -X GET http://locahost:5000/v2/hello-world/tags/list

$ curl -X GET http://192.168.0.173:5000/v2/_catalog
Warning: Binary output can mess up your terminal. Use "--output -" to tell
$ curl -X GET http://192.168.0.173:5000/v2/_catalog --output images
cat images -- 아무 것도 없음
$ curl -X GET https://192.168.0.173:5000/v2/_catalog
{"errors":[{"code":"UNAUTHORIZED","message":"authentication required","detail":[{"Type":"registry","Name":"catalog","Action":"*"}]}]}
$ curl --user edge2:'!234qwer' -X GET https://192.168.0.173:5000/v2/_catalog
{"repositories":["biot/edge-agent","biot/edge-central","biot/edge-shared","biot/edge-web","biot-arm32v7/edge-agent","biot-arm32v7/edge-shared","biot-arm64v8/alpine","biot-arm64v8/edge-agent","biot-arm64v8/edge-module","biot-arm64v8/edge-module-shared","biot-arm64v8/edge-runtime","biot-arm64v8/edge-shared","biot-arm64v8/handler-builder-python-onbuild","biot-arm64v8/processor","biot-arm64v8/uhttpc","dcol-manager-web"]}

$ curl --user edge2:'!234qwer' -X GET https://192.168.0.173:5000/v2/dcol-manager-web/tags/list
{"name":"dcol-manager-web","tags":["1.0.1"]}


○ Private registry 이미지 삭제
 - content digest(hash) 조회
$ curl --user edge2:'!234qwer' -v --silent -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -X GET https://192.168.0.173:5000/v2/dcol-manager-web/manifests/1.0.1 2>&1 | grep Docker-Content-Digest | awk '{print ($3)}' 
sha256:93c07a375db97f5e8c62de7baa8a08b05dde5c8a8ec667d8b8cafec8bc572f80

 - manifest 삭제
$ curl --user edge2:'!234qwer' -v --silent -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -X DELETE https://192.168.0.173:5000/v2/dcol-manager-web/manifests/sha256:93c07a375db97f5e8c62de7baa8a08b05dde5c8a8ec667d8b8cafec8bc572f80
{"errors":[{"code":"UNSUPPORTED","message":"The operation is unsupported."}]}
* Connection #0 to host 192.168.0.173 left intact
 - config 수정 후 재시작 후 다시 삭제하면 됨
$ docker exec registry sed -i 's/storage:/storage:\n  delete:\n    enabled: true/g' /etc/docker/registry/config.yml
$ docker restart registry 

 - GC 실행
$ docker exec -it registry  bin/registry garbage-collect  /etc/docker/registry/config.yml
 - 레지스트리 재시작
$ docker stop registry
$ docker start registry


○ Docker Image Tag 정책
 1안)
 [개발 빛 테스트 중일 때]
 - git revision 번호 7자리
   . expr substr $(git rev-parse --verify HEAD) 1 7
   . 커밋시 순차적으로 증가함
 - 어플리케이션의 버전정보는 Image 이름에 포함시키지 않음
   . 같은 버전으로 여러번 build할 경우가 많이 발생하기 때문
 - 예
   . dcol-manager-web:609058d
 - 현재 동탄 CI 개발 환경에서 해당 방법으로 이미지를 빌드하고 있음
    
 [운영 배포할 때]
 - 배포 버전
 - 어플리케이션의 버전정보는 Image 이름에 포함시키지 않음
 - 예
   . dcol-manager-web:1.0.1
 - 실수를 해서 다시 Image를 빌드하고 등록할 경우 
   먼저 레지스트리에서 삭제를 해야 함
      
 2안)
 - major.minor.patch[.build]
 
 [개발 빛 테스트 중일 때]
 - 기존 edge-manager-web:1.0.1에서 시작하기 때문에 build 버전만 증가 시킴
 - dcol-manager-web:1.0.1.0
 - dcol-manager-web:1.0.1.1
 - dcol-manager-web:1.0.1.2
 - dcol-manager-web:1.0.1.3
   ...
       
 [운영 배포할 때]
 - 기존 edge-manager-web:1.0.1에서 docker환경으로 변경됨에 따라 minor 버전을 증가 시킴
 - dcol-manager-web:1.1.0 (1.0.1을 기준으로 여러번 수정하여 build 후 최종 배포 시점)
 - dcol-manager-web:1.1.1 (1.1.0을 기준으로 여러번 수정하여 build 후 최종 배포 시점)
 - dcol-manager-web:1.1.2
   ...
 - dcol-manager-web:1.2.0


○ Device Naming 정책

TSTNTB1-DCOL-P
TSTNTB2-DCOL-P

DEVSVR1-DCOL-P
DEVSVR1-DCOL-S

TSTSVR1-DCOL-P
TSTSVR1-DCOL-S

TMPSVR1-DCOL-P
TMPSVR1-DCOL-S

TSTRBP1-DCOL-P


○ BrighticsEdge 적용절차
 - 디바이스 등록
 - 디바이스에서 web-broswer > EdgeManager접속 > 등록된 디바이스 선택 > Install Download 클릭
 - tar -xvf TSTRBP1-DCOL-P.tar
 - $ sudo ./install.sh

 - 앱 등록
   . 앱명 / 앱버전 / 앱파일그룹명 / 앱파일그룹버전 / 설명
   . 컨테이너 옵션 : --name dcol-manager-web -d -p 3000:3000 --restart unless-stopped -v /apps/dcol-manager-web/config/config.js:/usr/share/nginx/html/config.js -v /etc/localtime:/etc/localtime:ro dcol-manager-web:1.0.1.0

 - 앱 설치 관리
   . 미설치 디바이스 탭에서 선택 후 버전 선택, [설치] 클릭

 - 앱파일 관리
   . 파일경로 : /apps/[app-name]/config 는 고정 나머지 설정
   
 - 앱파일 작업 관리
   . 등록
     -- 앱명, 앱버전 선택, 앱파일그룹명, 앱파일그룹명버전 입력
     -- 디바이스 선택 후 완료
   . 재배포
     -- 앱파일그룹명, 엡파일그룹버전, 앱버전, 파일경로, 디바이스 라인 선택 후 [배포] 클릭




○ 배포 서버에 도커 이미지 등록 절차
 - build (개발 서버(linux))
   $ docker build -t dcol-manager:1.0.2.0 .
 - save (개발 서버(linux))
   $ docker save -o dcol-manager.tar dcol-manager:1.0.2.0
 - copy to 배포서버 (개발 서버(linux))
   $ scp dcol-manager.tar edge2@192.168.0.173:/home/edge2/
 - load (배포 서버)
   $ docker load -i dcol-manager.tar
 - push (배포 서버)
   $ docker tag dcol-manager:1.0.2.0 192.168.0.173:5000/dcol-manager:1.0.2.0 
   $ docker push 192.168.0.173:5000/dcol-manager
 - remove (배포 서버)   
   $ docker rmi 192.168.0.173:5000/dcol-manager:1.0.2.0
   $ docker rmi dcol-manager:1.0.2.0
   $ rm dcol-manager.tar


○ 이슈 및 문제점
 - 앱 설치를 먼저 해야만 앱 파일 작업 등록(등록 완료시 배포가 됨) 및 재배포가 가능하여, 앱 배포를 먼저 한 후 앱파일을 배포해야 하는데,
   config.js:config.js 처럼 파일 단위 volume을 적용하면 host경로에 해당하는 파일이 없으면 파일이름의 폴더가 생성되고 앱의 docker container가 오류가 나고 중지됨
   . 앱파일을 먼저 배포하고 앱 설치를 하면 위의 문제가 없지만....., 이는 연구소에 문의 필요
   . 현재로서는, 앱을 최초 설치 하기 전에 먼저 /apps/[app-name]/config 폴더에 공유하고자하는 메타파일 config.js를 작성해둠
     -- 폴더 및 파일은 root 권한으로 생성해야 함
     
   
 선택1)
 - 먼저 수작업으로 host에 폴더를 생성하고 화일을 복사
 - 그런 다음 앱을 배포
 - # mkdir -p /apps/dcol-manager-web/config
 - # cp config.js /apps/dcol-manager-web/config/
 
 선택2)
 - config파일 생성하지 않고 앱을 배포
   . config.js 폴더가 생성되고 앱 컨테이너는 생성되지만 중지됨
 - 앱파일을 배포
 - 앱을 upgrade(재배포)
    
   
 - 도커 Container의 실행 시간이 한국 시간이 아님
  선택1)
   Host 시스템의 시간과 Docker 컨테이너의 시간이 불일치 하는 경우가 있다.
  이런 경우 Host의 시간과 컨테이너의 시간을 동기화 시키는 방법에 대해서 알아보자.
  [Host가 Linux or MacOS인 경우]
  1) Host의 localtime을 설정한다 (올바르게 설정되어 있다면 바로 2번으로 넘어가자)
  ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime
  2) Host의 localtime 파일을 (ro)읽기전용으로 바인딩하고 Docker Container를 실행한다.
  docker run -v /etc/localtime:/etc/localtime:ro 기타옵션들 

  선택2)
  도커 파일 만들기
  FROM sitespeedio/sitespeed.io #이미지에 따라서 수정.
  ENV TZ=Asia/Seoul
  RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone


○ Docker in Docker
docker run -it --rm --name driver-agent -v /var/run/docker.sock:/var/run/docker.sock ubuntu /bin/bash   (X)
docker run -it --rm --name driver-agent jpetazzo/dind /bin/bash (X)

docker run -it --rm --name driver-agent -v /var/run/docker.sock:/var/run/docker.sock jpetazzo/dind /bin/bash (O)
-v /c/Users/SangMin/.ssh/authorized_keys:/.ssh/authorized_keys

docker run -it --rm --name driver-agent -v /var/run/docker.sock:/var/run/docker.sock
-v /c/Users/SangMin/.ssh/authorized_keys:/.ssh/authorized_keys jpetazzo/dind /bin/bash (O)


- apt-get update && apt-get -y install open-ssh-client 추가 필요


docker run -i --rm --privileged --network host -v /test.sh:/test.sh alpine:3.7 sh /test.sh

docker run -it --rm --network host -v /home/ubuntu/work/docker/test/test.sh:/test.sh alpine:3.7 sh /test.sh

docker run -i --rm --network host -v /test.sh:/test.sh ubuntu /test.sh


○ driver-agent Dockerfile
FROM jpetazzo/dind

RUN apt-get update
RUN apt-get install -y openssh-client

