
○ 도커란?
 - 도커는 컨테이너 기반의 오픈소스 가상화 플랫폼
 - 도커는 환경에 구애받지 않고 애플리케이션을 신속하게 
   구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼


○ DevOps
 - 데브옵스는 소프트웨어의 개발과 운영의 합성어로서, 
 - 소프트웨어 개발자와 정보기술 전문가 간의 소통, 협업과 통합을 강조하는 개발 환경이나 문화
 - 데브옵스는 개발조직과 운영조직간의 상호 의존적 대응이며 조직이 소프트웨어 제품과 서비를
   빠른 시간에 개발 및 배포하는 것을 목적으로 함
 - 툴체인
   1.코드 - 코드 개발 및 검토, 버전 관리 도구, 코드 병합
   2.빌드 - 지속적 통합(CI) 도구, 빌드 상태
   3.테스트 - 테스트 및 결과가 성능을 결정
   4.패키지 - 애플리케이션 디플로이 이전 단계
   5.릴리스 - 변경사항 관리, 릴리스 승인, 릴리스 자동화
   6.구성 - 인프라스트럭처 구성 및 관리, IaC(Infrastructure as Code) 도구
   7.모니터링 - 애플리케이션 성능 모니터링, 최종 사용자 경험

○ 컨테이너
 - 도커는 소프트웨어를 컨테이너라는 표준화된 유닛으로 패키징하며, 이 컨테이너에는 
   라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든 것이 포함
 - Docker는 컨테이너를 위한 운영 체제
 - 가상 머신이 서버 하드웨어를 가상화, 컨테이너는 서버 운영 체제를 가상화함

 - 프로세스를 격리하는 방식
 - 도커는 LXC를 기반으로 시작해서 0.9버전에서는 자체적인 libcontainer 기술을 사용하였고
   추후 runC  기술에 합쳐졌음


○ 컨트롤그룹
 - Linux의 Docker Engine은 cgroups라는 또 다른 기술을 사용함
 - 응용프로그램을 특정 자원 세트로 제한함
 - 컨트롤그룹을 통해 Docker Engine은 사용 가능한 하드웨어 리소스를 컨테이너에 공유하고
   선택적으로 제한 및 제약 조건을 적용 할 수 있ㅇ므


○ 네임 스페이스
 - Docker는 컨테이너 네임스페이스라는 격리된 작업 영역을 제공하기 위해 호출되는 기술을 사용
 - 컨테이너를 실행할 때 Docker는 해당 컨테이너에 대한 네임스페이스 집합을 만듬
 - pid : 프로세스 격리
 - net : 관리 네트워크 인터페이스
 - ipc : ipc 자원에 대한 액세스 관리
 - mnt : 관리 파일 시스템
 - uts : 커널과 버전 식별자 

○ UnionFS
 - 유니온파일시스템은 레이어를 생성하여 작동하는 파일시스템으로 매우 가볍고 빠름
 - Docker Engine은 UnionFS를 사용하여 컨테이너에 대한 빌딩 빌록을 제공함


○ 컨테이너 형식
 - Docker Engine은 네임스페이스, 컨트롤그룹 및 UnionFS를 컨테이너형식이라는 래퍼에 결합
 - 기본 컨테이너 형식은 libcontainer임


○ Docker 라이선싱 모델
 - Docker Community Editon(CE)
   . 무료
   . 오픈소스
   . Windows, Mac 및 Linux
 - Docker Enterprise Edition(EE)
   . Workflow 및 보안을 위한 기능이 추가

○ Docker를 사용해야 하는 이유
 - 더 많은 소프트웨어를 더 빨리 제공
   . 필요할 때 마다 격리된 서비스를 제공할 수 있음
 - 운영 표준화
   . 작은 컨테이너식 애플리케이션을 사용하면 손쉽게 배포하고, 
     문제를 파악하고, 수정을 위해 롤백할 수 있음
 - 원활하게 이전
   . 애플리케이션을 로컬 개발 시스템에서 프로적션 배포로 원활하게 이전할 수 있음
 - 비용 절감
   . 서버에서 좀 더 쉽게 더 많은 코드를 실행하여 사용률을 높이고 비용을 절감할 수 있음

○ Docker를 사용하는 경우
 - 마이크로 서비스
   . Docker 컨테이너를 통해 표준화된 코드 배포를 활용하여 분산 애플리케이션 아키텍처를 구축하고 확장함
 - 지속적인 통합 및 제공
   . 환경을 표준화하고 언어 스택 및 버전 간의 충돌을 제거함으로써 애플리케이션을 더욱 빠르게 제공함
 - 데이터 처리
   . 빅 데이터 처리를 서비스로 제공함. 데이터 및 분석 패키지를 기술자가 아닌 사용자도 실행
     할 수 있는 이동식 컨테이너로 패키징함
 - 서비스로서의 컨테이너
   . 안전한 IT 관리형 인프라와 콘텐츠로 분산 애플리케이션을 구축 및 제공함
   
○ Docker 컨테이너를 대량으로 실행하고자 하는 경우
 . Docker Swarm, Kubernetes, Amazon Elastic Container Service(ECS)와 같은
   오케스트레이션 도구를 사용하면 수천 개(또는 수백만 개)의 컨테이너를 시작, 
   중단 및 모니터링할 수 있음

○ 참고
 - 하이퍼 바이저는 호스트 컴퓨터 1대에서 다수의 운영체제를 동시에 실행할 수 
   있도록 해주는 가상 플랫폼 기술을 말합니다. 
 - 가상 머신 모니터(Virtual machine monitor)라고도 불림





○ 이미지(Image)
 - Docker 이미지는 컨테이너를 정의하는 읽기 전용 템플릿
 - Docker 컨테이넌는 인스턴스화된 Docker 이미지임
  
 - 이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것
 - 컨테이너는 이미지를 실행한 상태라고 볼 수 있고
 - 추가되거나 변하는 값은 컨테이너에 저장됨
 - ubuntu이미지는 ubuntu를 실행하기 위한 모든 파일을 가지고 있고 
   MySQL이미지는 debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 
   포트 정보등을 가지고 있습니다. 좀 더 복잡한 예로 Gitlab 이미지는 centos를 기반으로 
   ruby, go, database, redis, gitlab source, nginx등을 가지고 있음
 - 도커 이미지는 Docker hub에 등록하거나 Docker Registry 저장소를 직접 만들어 관리할 수 있음
   현재 공개된 도커 이미지는 50만개가 넘음

○ 레이어 저장방식
 - 레이어layer라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 
   하나의 파일시스템으로 사용할 수 있게 해줌
 - 이미지는 여러개의 읽기 전용read only 레이어로 구성되고 파일이 추가되거나 수정되면 
   새로운 레이어가 생성

○ Dockerfile
 - 도커는 이미지를 만들기 위해 Dockerfile이라는 파일에 자체 
   DSLDomain-specific language언어를 이용하여 이미지 생성 과정을 적음

○ Docker Hub
 - 도커는 Docker hub를 통해 공개 이미지를 무료로 관리해 줌

○ Command와 API
 - 대부분의 명령어는 직관적이고 사용하기 쉬우며 
   컨테이너의 복잡한 시스템 구성을 이해하지 못하더라도 편하게 사용할 수 있음
 - http기반의 Rest API도 지원하여 확장성이 굉장히 좋음

○ 훌륭한 생태계
 - 사실상 클라우드 컨테이너 세계의 de facto
 - 로깅, 모니터링, 스토리지, 네트워크, 컨테이너 관리, 배포등 다양한 분야에서 
   다양한 툴들 존재
 - 도커를 위한 OS(coreos->container linux)도 존재함


○ Docker Engine
 - daemon (dockerd 명령)
 - REST API
 - CLI (docker 명령)


○ 가상머신과 Docker Container 차이점
 - 가상머신은 Hypervisor(VMWare, VirtualBox,...)위에 GuestOS가 올라간 형태. x86 하드웨어가 그대로 가상화 된 것임.
 - 가상머신을 설치하고 메모리 영역을 확인해보면 호스트 메모리와 게스트 메모리를 볼 수 있음. 
 - Docker Engine 위에 Application이 올라감. Docker Engine을 통해 Host OS 위에서 컨테이너가 생성되는 것
 - 컨테이너는 리눅스 커널의 cgroups, namespace 등의 기능을 사용해 가상공간을 생성할 수 있도록 하는 기능임

○ 컨테이너가 가상머신보다 뛰어난 점
 - 가상머신을 사용하게 되면 상세 설정을 해주지 않는 한 메모리, CPU 코어, 프로세스 등 각종 성능 손실이 발생함
 - 컨테이너는 Host OS의 커널을 그대로 사용하고 일부분만 패키징 되기 때문에 용량이 크게 줄어들 뿐만 아니라, 
   프로세스 영역도 기존의 OS와 공유해서 사용함
 - 컨테이너는 하드웨어를 가상화하는 계층이 없기 때문에 메모리 접근, 파일시스템, 네트워크 속도가 가상머신에 비해
   월등히 빠름

○ Boot2Docker
 - Docker는 리눅스 커널의 컨테이너 기능을 기반으로 하기 때문에 Windows나 OS X 환경에서 실행 할 수 없음
 - 그래서 이를 지원하기 위해 나온 것이 Boot2Docker임
 - Boot2Docker는 가상머신 안에 리눅스를 설치하고 Docker를 실행하는 방식으로 이를 해결했음
 - 2015년 9월쯤 boot2docker-cli가 deprecated 되었음. toolbox를 이용하여 설치하는 방법을 권장하고 있음

○ OS X에서 Docker 설치
 - Docker for Mac : VirtualBox 사용
 - Docker Toolbox : macOS 사용

○ 기타 
 - Docker 컨테이너는 단지 명령만 실행하고 그 결과만 보여주는 기능을 수행
 - Docker에 애플리케이션 서버 실행하기
   . $ docker run -d --name ubuntu_test ubuntu /bin/bash -c "while true; do echo "still live"; sleep 100; done"
   . Docker 컨테이너에서 실행되는 애플리케이션 서버(DB 서버 포함)은 back ground 모드가 아니 fore ground 모드로 실행해야 함
   . Tomcat의 경우 예를 들면 일반적으로 다음과 같이 실행하여 백그라운드 모드로 동작하게 한다. 이유는 tomcat 서버를
     실행시킨 shell이 종료되더라도 tomcat 서버는 정상적으로 계속 동작하게 위함
     $ cd $CATALINA_HOME/bin; $ ./catalina.sh start;
   . 하지만 docker 환경에서 이렇게 하면 컨테이너가 바로 종료되어 Tomcat 서버가 죽는 것과 동일한 상황를 맞게 됨
     다음과 같이 fore ground로 실행해야 함
     $ cd $CATALINA_HOME/bin; $ ./catalina.sh run;
 - 환경설정을 바꾸고 다시 실행하면
   . fore ground로 실행되어 있기 때문에 Tomcat 서버가 재시작되면 해당 컨테이너가 종료됨.
   . 옵션 하나 바꾸는 것도 컨테이너에서 직접 바꾸면 안되고 Dockerfile을 이용해서 바꾼 후 이미지를 빌드하고,
     컨테이너를 시작해야만 적용할 수 있음. 
   . 개발 후 초기 동안, 애플리케이션 서버는 백그라운드로 실행, 애플리케이션 서버 실행 후 바로 shell script로 무한 반복
     bin/catalina.sh start
     while true;
       do echo "still live";
       sleep 600;
     done
   . 서비스 초기 어떤 옵션이 서비스에 맞는지 확인하는 용도로만 사용하고, 정상적인 운영환경에서는 사용하지 않는 것을 권장

 - docker는 새 OS환경과 일련의 기초 프로그램을 깔아버린 버전을 하나의 이미지로 제공
   . docker는 단순한 가상머신 대체물이 아니라 어느 플랫폼에서도 똑같이 재현가능한 어플리케이션 컨테이너를 만든다는 말이 이말이다
 - 사실 윈도우10에는 Hyper-V Manager가 기본 설치가 되어 있는데 이를 구동해보면 MobyLinuxVM 이라는 명으로 설치가 되어 있음
 - docker에서 게스트OS 와 호스트OS가 다르다는 것은 이론적으로 불가능하기 때문에, 윈도우즈나 맥에서는 일단
   가상머신으로 리눅스를 HOST OS로 이용하기 위해 할 수 없이 뒷단에 저렇게 깐다
 - Docker는 리눅스 컨테이너의 가장 대표적인 종류 중 하나
   . 리눅스 컨테이너이 때문에, Linux 이외의 운영체제는 설치/실행 할 수 없음
   . 또 리눅스 커널을 사용하기 때문에 가상 환경 또는 리눅스 외의 운영체제는 머신으로 생성할 수 없음
   . Host OS의 커널을 공유해서 사용하기 때문에 커널에 다소 차이가 있음(제한적임)
     -- 현재 Docker에서는 Kernel 부분(/proc)을 Read-only file system으로 지정해놓고, 패키지 부분도 따로 분리해 놓고 있음
 - Docker로 CentOS를 설치하면 해당 배포판의 CentOS가 완벽하게 설치되는 것으로 착각하는 분들이 계심.
   . 배포판은 CentOS가 맞기 때문에 명령어나 이런 부분은 당연히 CentOS의 명령어를 사용하지만 
   . 커널은 Host OS의 커널을 사용하기 때문에 Host OS가 만일 Ubuntu Linux라면 Docker로 설치한 CentOS의 커널은
     Ubuntu Linux의 커늘을 사용하기 때문에, 이 점 반드시 알아두시고 사용하시기 바람



○ Docker concepts
 - Docker is a platform for developers ans sysadmins to develop, deploy, and run application with containers.
 - Containerization : 어플리케이션을 배포하기 위해 Linux containers를 사용하는 것
 - Containers
   . Flexible
   . Lightweight
   . Interchangeable
   . Portable
   . Scalable
   . Stackable
 - image
   . an executable package that includes everythig needed to run an application--the code, a runtime, libraries,
     environment variables, and configuration files.
 - container
   . a runtime instance of an image
 
 - Containers and virtual machines
   . A container runs natively on Linux and shares the kernel of the host machine with other containers.
   . It runs a discrete process, taking no more memory than any other executable, making it lightweight.
   . A virual machine(VM) runs a full-blown "guest" OS with virtual access to host resources through a hypervisor.
   . VMs provide an environment with more resources than most applications need.

○ Test Docker installation
 - sudo docker pull hello-world
 - sudo docker image ls
 - sudo docker ps
 - sudo docker container ls --all
 - sudo docker container ls -aq
 - sudo docker run hello-world

○ Containerization makes CI/CD seamless
 - applications have no system dependencies
 - updates can be pushed to any part of a distributed applicaton
 - resource density can be optimized



○ docker에서 untagged(none) images를 한번에 삭제하기
 - $ docker rmi $(docker images -f "dangling=true" -q)
 

○ Dockerfile ADD 명령
 - ADD <복사할 파일 경로> <이미지에서 파일이 위치할 경로>
 - ADD <파일경로> <파일경로>
   . ADD ./hello /apps/hello/hello
   . ADD hello /apps/hello/hello 
   . Dockerfile이 있는 host의 현재 폴더(context)에 있는 hello파일을 이미지의 /apps/hello 폴더에 hello로 파일로 추가
 - ADD <파일경로> <폴더 경로>
   . ADD ./hello /apps/hello/ 
   . 폴더 경로는 마지막에 /로 끝나야 함
   . 이미지에서 파일이 위치할 경로의 마지막에 /가 있으면 그 디렉토리 아래에 복사됨   
 - ADD <폴더 경로> <폴더 경로>
   . <복사할 파일 경로>에 폴더를 지정하면 해당 폴더의 의 모든 파일을 복사함
   . <복사할 파일 경로>가 폴더이면 <이미지에서 파일이 위치할 경로>의 마지막에 /가
     없어도 폴더로 인식됨
   . ADD appdir /appdir 
   . Dockerfile이 있는 host의 현재 폴더(context) 아래의 appdir 폴더의 모든 파일을 이미지의 /appdir 폴더로 추가
   . 폴더를 추가하는 것은 아님
 ※ 이미지에서 파일이 위치할 경로의 폴더들이 존재하지 않으면 폴더를 자동 생성함


○ docker run 명령에서 실행할 파일을 설정하면
 - CMD는 무시되고 ENTRYPOINT는 무시되지 않고 실행할 파일 설정 자체를 매개 변수로 받아 처리함

○ docker run 명령에서 --entrypoint 옵션을 사용하면 Dockerfile의 ENTRYPOINT가 무시됨

○ Dockerfile EXPOSE는 포트를 호스트 포트와 연결할 뿐 외부에 노출은 되지 않음
 - 포트를 외부에 노출하려면 docker run 명령의 -p, -P 옵션을 사용해야 함
 - docker run 명령의 --expose 옵션과 동일함
 - docker run 명령의 -p 옵션을 위해 꼭 EXPOSE 안 해도 됨

○ Dockerfile ENV로 설정한 변수는 RUN, CMD, ENTRYPOINT에 적용됨
 - docker run 명령의 -e, --env 옵션과 동일
 - docker run 명령의 -e 옵션은 Dockerfile ENV로 설정한 변수를 변경해서 실행할 때 사용 

○ Dockerfile COPY 명령
 - ADD와는 달리 압축 파일을 추가할 때 압축 해제하지 않고, 파일 URL도 사용할 수 없음
 
○ Dockerfile VOLUME 명령
 - 디렉토리의 내용을 컨테이너에 저장하고 않고 호스트에 저장하도록 설정
 - 컨테이너가 삭제되더라도 호스트에 데이타가 남음
 - docker run 명령의 -v 옵션과 동일
   . Dockerfile VOLUME을 사용하지 않고 docker run 시 -v 옵션을 사용해도 됨
   . docker run -v <컨테이너 경로> 는 Dockerfile VOLUME <컨테이너 경로>와 동일함 
 - docker run 명령의 -v 옵션의 지정된 <컨테이너 경로>가 존재하지 않으면 자동으로 생성됨
 - docker run -v <호스트 경로>:<컨테이너 경로>
 - docker run 명령의 -v 옵션에 <호스트 경로>를 지정하지 않으면 docker가 임의의 경로에 생성함
 - docker run 명령의 -v 옵션의 <호스트 경로>는 호스트의 경로를 변경함
 - docker run 명령의 -v 옵션의 지정된 <호스트 경로>가 존재하지 않으면 자동으로 생성됨
 - docker run 명령의 -v 옵션의 지정된 <호스트 경로>에 폴더가 아니라 파일을 지정할 경우
   . <호스트 경로>로 해당하는 파일이 호스트에 없어면, 오류가 발생되고 해당 파을을 폴더로 인식하고 폴더가 생성됨


○ 중지 또는 삭제된 container volume 제거
 - docker volume rm $(docker volume ls -qf dangling=true)
 
 ○ 컨테이너 경로가 존재하지 않으면 자동으로 컨테이너에 생성
 - Dockerfile의 ADD, COPY, VOLUME, WORKDIR
 - docker run 옵션 -v <컨테이너 경로>

○ 호스트 경로가 존재하지 않으면 자동으로 호스트에 생성
 - docker run 옵션 -v <호스트 경로>:<컨테이너 경로>


○ Dockerfile WORKDIR 명령
 - RUN, CMD, ENTRYPOINT 명령이 실행될 디렉토리를 설정
 - 컨테이너에 해당 경로가 없을 경우 컨테이너에 해당 경로를 생성함
 


○ Docker Remote API (REST API)
 - 컨테이너 생성
   . $ curl -X POST -H "Content-Type:application/json" -d '{ "Image":"nginx:latest", "PortBindings": { "80/tcp": [{ "HostPort": "80"}]} }' http://127.0.0.1:4243/containers/create
 - 컨테이너 시작
   . $ curl -X POST -H "Content-Type: application/json" http://127.0.0.1:4243/containers/0e0f85d92c42/start   
 - Container List
   . $ curl http://127.0.0.1:4243/containers/json   
   . $ curl http://127.0.0.1:4243/containers/json?all=1
   
○ Docker Remote API (Python Low-level API)
 - 컨테이너 생성 및 시작
import docker

client = docker.Client(base_url='unix://var/run/docker.sock')
container_id = client.create_container(
    image='nginx:latest',
    ports=[80],
    volumes=['/data'],
    host_config=client.create_host_config(
      port_bindings={ '80/tcp': 80 },
      binds={
        '/root/data': {
            'bind': '/data',
            'mode': 'rw'
        }
      }
    ), 
    name='hello'
)
client.start(container_id)

ㅁ 이미지 받기
 - $ sudo docker pull hello-world:latest

ㅁ 이미지 목록 출력
 - $ sudo docker images

ㅁ 컨테이너 생성하기
 - $ sudo docker run -i -t --name hello hello-world

ㅁ 컨테이너 목록 확인
 - $ sudo docker ps -a

ㅁ 컨테이너 시작하기
 - $ sudo docker start hello
 - 컨테이너 정지
   . 셸에서 exit 또는 Ctrl+D
   . Ctrl+P, Ctrl+Q
 
ㅁ 컨테이너 재시작하기
 - $ sudo docker restart hello

ㅁ 컨테이너 접속하기
 - $ sudo docker attach hello

ㅁ 외부에서 컨테이너 안의 명령 실행하기
 - $ sudo docker exec hello echo "Hello World"
 - docker exec 명령은 이미 실행된 컨테이너에 apt-get, yum 명령으로 패키지를 설치하거나, 
   각종 데몬을 실행할 때 활용할 수 있음

ㅁ 컨테이너 중지하기
 - $ sudo docker stop hello

ㅁ 컨테이너 삭제하기
 - $ sudo docker rm hello

ㅁ 이미지 삭제하기
 - $ sudo docker rmi hello-world
 - $ sudo docker images


ㅁ Dockerfile 작성하기
 - example/Dockerfile
FROM ubuntu:18.04
MAiNTAINER Foo Bar <foo@bar.com>

RUN apt-get update
RUN apt-get install -y nginx
RUN echo "\ndaemon off;" >> /etc/nginx/nginx.conf
RUN chown -R www-data:www-data /var/lib/nginx

VOLUME ["/data", "/etc/nginx/site-enabled", "/var/log/nginx"]

WORKDIR /etc/nginx

CMD ["nginx"]

EXPOSE 80
EXPOSE 443

ㅁ 이미지 생성하기
 - $ sudo docker build --tag hello:0.1
 - $ sudo docker images
 - $ sudo docker run --name hello-ngix -d -p 80:80 -v /root/data:/data hello:0.1
 - $ sudo docker ps
 - 웹 브라우저 실행, http://<호스트 IP>:80 접속

ㅁ 이미지 히스토리 살펴보기
 - $ sudo docker history hello:0.1

ㅁ 컨테이너에서 파일 꺼내기
 - $ sudo docker cp hello-nginx:/etc/nginx/nginx.conf ./

ㅁ 컨테이너 변경사항을 이미지로 생성하기
 - $ sudo docker commit -a "Foo Bar <foo@bar.com>" -m "add hello.txt" hello-nginx hello:0.2

ㅁ 컨테이너에서 변경된 파일 확인하기
 - $ sudo docker diff hello-nginx

ㅁ 컨테이너 세부 정보 확인하기
 - docker inspect <이미지 또는 컨테이너 이름>
 - $ sudo docker inspect hello-nginx

ㅁ 개인 저장소 구축하기
 - $ sudo service docker stop
 - $ sudo docker -d --insecure-registry localhost:5000

 - /etc/init.d/docker
   DOCKER_OPTS=--insecure-registry localhost:5000
 - $ sudo service docker restart


○ 로컬에 이미지 데이터 저장
 - docker registry 서버 이미지 받기
   . $ sudo docker pull registry:latest
 - registry:latest  이미지를 컨테이너로 실행
   . $ sudo docker run -d -p 5000:5000 --name hello-registry -v /tmp/registry:/tmp/registry registry

○ push로 이미지 올리기
 - $ sudo docker tag hello:0.1 localhost:5000/hello:0.1
 - $ sudo docker push localhost:5000/hello:0.1

○ 다른 서버에서 pull로 이미지 받기
 - $ sudo vi /etc/docker/daemon.json
   . { "insecure-registries":["192.168.1.217:5000"] }
 - $ sudo service docker restart
 - $ sudo docker pull 192.168.1.217:5000/hello:0.1

○ rmi로 이미지 삭제
 - $ sudo docker rmi  192.168.1.217:5000/hello:0.1

○ 기본 인증 사용하기
 - 도메인 추가
   . $ sudo vi /etc/hosts 
   <레지스트리 서버 IP 주소>	registry.example.com

 - 개인 키 파일 생성
   . $ openssl genrsa -out server.key 2048
 - 인증서 서명 요청 파일 생성
   . $ openssl req -new -key server.key -out server.csr
 - 서버 인증서 파일을 생성
   . $  openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt

 - 인증서 파일을 시스템에 설치
   . $ sudo cp server.crt /usr/share/ca-certificates/
   . $ echo "server.crt" | sudo tee -a /etc/ca-certificates.conf
   . $ sudo update-ca-certificates
   . $ sudo service docker restart

 - .htpasswd 파일 생성
   . $ sudo apt-get install apache2-utils
   . $ htpasswd -c .htpasswd hellouser
     <비밀번호 입력> -->smcs2019
 - nginx.conf 화일 작성
worker_processes        1;

events {
        worker_connections      1024;
}

http {
        server {
                listen  443;
                server_name     registry.example.com;

                ssl on;
                ssl_certificate /etc/server.crt;
                ssl_certificate_key /etc/server.key;

                proxy_set_header Host   $http_host;
                proxy_set_header X-Real_IP      $remote_addr;
                proxy_set_header Authorization  "";

                client_max_body_size 0;

                chunked_transfer_encoding on;

                location / {
                        proxy_pass      http://docker-registry:5000;
                        proxy_set_header        Host    $host;
                        proxy_read_timeout      900;

                        auth_basic              "Restricted";
                        auth_basic_user_file    .htpasswd;
                }
        }
}
 - Docker 레지스트리 컨테이너를 생성
   . sudo docker run -d --name docker-registry -v /tmp/registry:/tmp/registry registry:latest
 - nginx 공식 이미지 1.7.5 버전으로 컨테이너 생성하고 docker-registry 컨테이너와 연결
   . $ sudo docker run -d --name nginx-registry \
       -v ~/nginx.conf:/etc/nginx/nginx.conf \
       -v ~/.htpasswd:/etc/nginx/.htpasswd \
       -v ~/server.key:/etc/server.key \
       -v ~/server.crt:/etc/server.crt \
       --link docker-registry:docker_registry \
       -p 443:443 \
       nginx:latest
 - https://registry.example.com에 로그인
   . $ sudo docker login https://registry.example.com

 - 이미지를 개인저장소에 올리기
   . $ sudo docker tag hello:0.1 registry.example.com/hello:0.1
   . $ sudo docker push registry.example.com/hello:0.1
 - 다른 서버에서 이미지 받기
   . $ sudo docker pull registry.example.com/hello:0.1

○ Docker 컨테이너 연결하기
 - Docker 이미지를 생성할 때 웹 서버, DB 등 필요한 프로그램을 모두 설치할 수도 있지만 보통 프로그램별로 이미지를 생성함
 - Docker 컨테이너끼리 연결할 때는 docker run 명령에서 --link 옵션을 사용함
   . $ sudo docker run --name db -d mongo
   . $ sudo docker run --name web -d -p 80:80 --link db:db nginx
   . $ sudo cat `sudo docker inspect -f "{{ .HostsPath }}" web`
   . 컨테이너를 연결하면 hosts 파일에 IP 주소가 자동으로 설정되기 때문에 별칭을 통해 연결한 컨테이너에 접속할 수 있음
○ 다른 서버의 Docker 컨테이너에 연결하기
 - 엠버서버 컨테이너 이용하여 다른 서버에 있는 컨테이너에 연결
 - socat 이라는 프로그램을 이용하여 TCP 연결을 다른 곳으로 전달하도록 구성
 - Redis 서버로 쓸 컴퓨터에서 Redis 컨테이너를 생성
   . $ sudo docker pull redis:latest
   . $ sudo docker run -d --name redis redis:latest
 - 앰배서더 컨테이너 생성
   . $ sudo docker run -d --link redis:redis --name redis_ambassador -p 6379:6379 svendowideit/ambassador
 - Redis 클라이언트 컴퓨터에서 앰베서더 컨테이너 생성
   . $ sudo docker run -d --name redis_ambassador --expose 6379 -e REDIS_PORT_6379_TCP=tcp://192.168.1.217:6379 svendowideit/ambassador
 - Redis 클라이언트 컨테이너 생성
   . $  sudo docker run -i -t --rm --link redis_ambassador:redis relateiq/redis-cli
   . redis 172.17.0.4:6379> ping
     PONG
   . redis 172.17.0.4:6379>
   
○ Docker Container Log 확인
 - $ sudo docker logs nginx-registry
 
○ arch
 - x86_64 가 나중에 amd64로 변경되었음 (AMD 사에서 개발)   

○ Use a restart policy
To configure the restart policy for a container, use the --restart flag when using the docker run command. The value of the --restart flag can be any of the following:

Flag	Description
no	Do not automatically restart the container. (the default)
on-failure	Restart the container if it exits due to an error, which manifests as a non-zero exit code.
always	Always restart the container if it stops. If it is manually stopped, it is restarted only when Docker daemon restarts or the container itself is manually restarted. (See the second bullet listed in restart policy details)
unless-stopped	Similar to always, except that when the container is stopped (manually or otherwise), it is not restarted even after Docker daemon restarts.
The following example starts a Redis container and configures it to always restart unless it is explicitly stopped or Docker is restarted.

$ docker run -d --restart unless-stopped redis 

○ Docker를 완전히 제거하는 방법
 - dpkg -l | grep -i docker
 - sudo apt-get purge -y docker-engine docker docker.io docker-ce  
 - sudo apt-get autoremove -y --purge docker-engine docker docker.io docker-ce  
   위의 명령은 호스트에서 이미지, 컨테이너, 볼륨 또는 사용자 생성 구성 파일을 제거하지 않습니다.  => 삭제됨
   모든 이미지, 컨테이너 및 볼륨을 삭제하려면 다음 명령을 실행하십시오.
 - sudo rm -rf /var/lib/docker /etc/docker
   sudo rm /etc/apparmor.d/docker
   sudo groupdel docker
   sudo rm -rf /var/run/docker.sock
 - Docker Compose 삭제
   rm /usr/local/bin/docker-compose
   pip uninstall docker-compose   


