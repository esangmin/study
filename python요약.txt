<< Python 요약>>

○ 파이션의 특징
 - 파이썬은 C보다 훨씬 많은 에러 검사를 제공하고, 유연한 배열과 딕셔너리같은 
   고수준의 자료형들을 내장
 - 대규모의 표준 모듈들이 따라오는데 파일 입출력, 시스템 호출, 소켓들이 
   포함되는데, 심지어 Tk 와 같은 GUI 도구상자에 대한 인터페이스도 들어있음
 - C, C++, Java 프로그램들에 비교해 간결함
   . 고수준의 자료형 때문에 복잡한 연산을 한 문장으로 표현할 수 있음
   . 문장의 묶음은 괄호 대신에 들여쓰기를 통해 이루어짐
   . 변수나 인자의 선언이 필요 없음
 
 ○ 파이썬 인터프리터
  - py.exe
  - python -c command [arg] ...
  - python -m module [arg] ...
  - 기본 프롬프트에서 EOF(end-of-file) 문자(유닉스에서는 Control-D, 
    윈도우에서는 Control-Z)를 입력하면 인터프리터가 종료하고, 종료 상태 코드는 
    0 이 됩니다. 이 방법이 통하지 않는다면 quit() 명령을 입력해서 인터프리터를 
    종료시킬 수 있습니다.
    ※ exit() 명령을 입력해도 동일함
  - 대화형 모드 -i
  - -c command 가 사용되면 sys.argv[0] 는 '-c' 로 설정됨
    ※ command는 " 로 둘러싸야 안전함 
       예, python -c "print(2 ** 3)" 또는 py -c "print('Hi!')",
       py -c "print(""Hi!"")"
  - -m module 이 사용되면 sys.argv[0] 는 모듈의 절대 경로명이 됨

○ 소스코드 인코딩
 - 기본적으로, 파이썬 소스 파일들은 UTF-8으로 인코드 된 것으로 취급됨
   이 인코딩에서는 대부분 언어에서 사용되는 문자들을 문자열 상수, 식별자, 주석 
   등에서 함께 사용할 수 있음
   . 하지만 표준 라이브러리는 오직 ASCII 문자만 식별자로 사용하고 있는데, 
     범용 코드에서는 이 관례를 따르는 것이 좋음
 - 유닉스에서, 파이썬 3.x 인터프리터는 보통 python 이라는 이름의 실행 파일로 
   설치되지 않는데, 동시에 설치되는 파이썬 2.x 실행 파일과 충돌하지 않도록 하기
   위해섭니다. (예: python3)
   ※ 윈도우즈에서는 python 은 2.x, py 는 3.x 인터프리터가 실행됨

○ 파이썬의 소개
 - 주석은 해시 문자, #, 로 시작하고 줄의 끝까지 이어짐
 - 나눗셈 (/) 은 항상 float를 돌려줌
 - 정수 나눗셈으로 (소수부 없이) 정수 결과를 얻으려면 // 연산자를 사용하면 됨
   나머지를 얻으려면 % 를 사용할 수 있음
 - 정수 (예를 들어 2, 4, 20)는 int 형임
 - 소수부가 있는 것들 (예를 들어 5.0, 1.6)은 float 형임
 - 대화형 모드에서는, 마지막에 인쇄된 표현식은 변수 _ 에 대입됨
 - 파이썬은 Decimal 이나 Fraction(분수) 등의 다른 형의 숫자들도 지원함
 - 파이썬은 복소수에 대한 지원도 내장하고 있는데, 허수부를 가리키는데 j 나 J 
   접미사를 사용함 (예를 들어 3+5j)
 - 대화형 인터프리터에서, 출력 문자열은 따옴표로 둘러싸여 있고, 특수 문자들은 
   역 슬래시로 이스케이핑 됨
   . 문자열이 작은따옴표를 포함하고 큰따옴표를 포함하지 않으면 큰따옴표가 사용, 
   . 그 외의 경우는 작은따옴표가 사용됨
   . print() 함수는 따옴표를 생략하고, 이스케이핑된 특수 문자를 출력해서 
     더 읽기 쉬운 출력을 만들어냄
 - \ 뒤에 나오는 문자가 특수 문자로 취급되게 하고 싶지 않다면, 
   첫 따옴표 앞에 r 을 붙여서 날 문자열 (raw string) 을 만들 수 있음
 - 문자열 리터럴은 여러 줄로 확장될 수 있음
   . 한 가지 방법은 삼중 따옴표를 사용하는 것임: """...""" 또는 '''...'''. 
   . 줄 넘김 문자는 자동으로 문자열에 포함됨. 하지만 줄 끝에 \ 를 붙여 
     이를 방지할 수도 있음
 - 문자열은 + 연산자로 이어붙이고, * 연산자로 반복시킬 수 있음
 - 두 개 이상의 문자열 리터럴 (즉, 따옴표로 둘러싸인 것들) 가 연속해서 나타나면
   자동으로 이어 붙여짐
   . 이것은 오직 두 개의 리터럴에만 적용될 뿐 변수나 표현식에는 해당하지 않음
     ※ a = 'aa' 'bb' (OK)   b = 'bb'; ab = a b (X)  ab = a + b (OK)
 - 변수들끼리 혹은 변수와 문자열 리터럴을 이어붙이려면 + 를 사용해야 함
 - 문자열은 인덱스 (서브 스크립트) 될 수 있음. 첫 번째 문자가 인덱스 0에 대응됨
 - 음의 인덱스는 -1에서 시작함
   ※ >>> temp = 'abcd'
      >>> temp[0]
      'a'
      >>> temp[-1]
      'd'
 - 슬라이싱(slicing)도 지원
   ※ >>>temp[0:3]
      'abc'
 - 시작 위치의 문자는 항상 포함되는 반면, 종료 위치의 문자는 항상 포함되지 않는 것에 
   주의하세요.
   +---+---+---+---+---+---+
   | P | y | t | h | o | n |
   +---+---+---+---+---+---+
   0   1   2   3   4   5   6
  -6  -5  -4  -3  -2  -1
 - 너무 큰 값을 인덱스로 사용하는 것은 에러, 하지만, 범위를 벗어나는 슬라이스 
   인덱스는 슬라이싱할 때 부드럽게 처리됨
   >>> temp[:6]
   'abcd'
   >>> temp[5:8]
   ''
 - 파이썬 문자열은 변경할 수 없음(불변)
   >> temp = 'edgh' # temp 변수를 다시 정의할 수는 있으나
   >> temp[0] = 'a' # 내부의 값을 변경할 수 없음
 - 내장 함수 len() 은 문자열의 길이를 돌려줌
   >> len(temp)
   4
   
○ 리스트
 - 대괄호 사이에 쉼표로 구분된 값(항목)들의 목록으로 표현될 수 있음
 - 리스트는 서로 다른 형의 항목들을 포함할 수 있지만, 항목들이 모두 같은 형인 
   경우가 많음
 - 문자열(다른 모든 내장 시퀀스 형들)처럼 리스트는 인덱싱하고 슬라이싱 가능
 - 모든 슬라이스 연산은 요청한 항목들을 포함하는 새 리스트를 돌려줌
 - 리스트는 이어붙이기 같은 연산도 지원함
   >>> squares = [1, 2, 3]
   >>> squares + [36, 49, 64, 81, 100]
   [1, 2, 3, 36, 49, 64, 81, 100]
 - 리스트는 가변임. 즉 내용을 변경할 수 있음
 - append() 메서드를 사용하면 리스트의 끝에 새 항목을 추가할 수 있음
 - 슬라이스에 대입하는 것도 가능한데, 리스트의 길이를 변경할 수 있고, 
   모든 항목을 삭제할 수조차 있음
  >>> letters = ['A', 'B']
  >>> letters = ['A', 'A', 'A', 'A', 'A', 'A']
  >>> letters[2:5] = ['C', 'D', 'E']
  >>> letters
  ['A', 'A', 'C', 'D', 'E', 'A']
  >>> letters[:] = []
  >>> letters
  []
 - 내장 함수 len() 은 리스트에도 적용됨
  >>> len(letters)
  0   
 - 리스트를 중첩할 수도 있음
  >>> a = ['a', 'b', 'c']
  >>> n = [1, 2, 3]
  >>> x = [a, n]
  >>> x
  [['a', 'b', 'c'], [1, 2, 3]]
  >>> x[0]
  ['a', 'b', 'c']
  >>> x[0][1]
  'b'
 - print() 함수는 주어진 인자들의 값을 인쇄함
 - 키워드 인자 end 는 출력 끝에 포함되는 개행문자를 제거하거나 출력을 다른 
   문자열로 끝나게 하고 싶을 때 사용됨
  >>> a, b = 0, 1
  >>> while a < 1000:
  ...     print(a, end=',')
  ...     a, b = b, a+b
  ...
  0,1,1,2,3,5,8,13,21,34,55,89,>>>
 - 다른 언어들과는 달리, `` `` 과 같은 특수 문자들은 작은따옴표('...')와 
   큰따옴표("...")에서 같은 의미가 있음
   . 둘 간의 유일한 차이는 작은따옴표 안에서 " 를 이스케이핑할 필요가 없고 
     (하지만 \' 는 이스케이핑 시켜야 함), 그 역도 성립한다는 것임

○ if 문
  >>> if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x == 0:
  ...     print('Zero')
  ... elif x == 1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...
  More

○ for 문
 - for 문은 임의의 시퀀스 (리스트나 문자열)의 항목들을 그 시퀀스에 들어있는 
   순서대로 이터레이션함
  >>> # Measure some strings:
  >>> words = ['cat', 'window', 'defenestrate']
  >>> for w in words:
  ...     print(w, len(w))
  ...
  cat 3
  window 6
  defenestrate 12
 - 숫자들의 시퀀스로 이터레이트할 필요가 있으면, 내장 함수 range()가 편리함
  >>> for i in range(5):
  ...     print(i)
  ...
  0
  1
  2
  3
  4

  range(5, 10)
     5, 6, 7, 8, 9

  range(0, 10, 3)
     0, 3, 6, 9

  range(-10, -100, -30)
    -10, -40, -70

 - 시퀀스의 인덱스들로 이터레이트 하려면, 다음처럼 range()와 len() 을 결합
  >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
  >>> for i in range(len(a)):
  ...     print(i, a[i])
  ...
  0 Mary
  1 had
  2 a
  3 little
  4 lamb

  >>> for i, v in enumerate(['tic', 'tac', 'toe']):
  ...     print(i, v)
  ...
  0 tic
  1 tac
  2 toe

 - 많은 경우에 range()가 돌려준 객체는 리스트인 것처럼 동작하지만, 
   사실 리스트가 아님
   . 이터레이트할 때 원하는 시퀀스 항목들을 순서대로 돌려주는 객체이지만, 
     실제로 리스트를 만들지 않아서 공간을 절약함
   . 이런 객체를 이터러블 이라고 부름
   . 공급이 소진될 때까지 일련의 항목들을 얻을 수 있는 무엇인가를 기대하는 
     함수와 구조물들의 타깃으로 적합
   . 우리는 for 문이 그런 구조물임을 보았음
   . 이터러블을 취하는 함수의 예는 sum()
  >>> sum(range(4))  # 0 + 1 + 2 + 3
  6
 - 마지막으로, range에서 리스트를 얻는 방법
  >>> list(range(4))
  [0, 1, 2, 3]

 - break 문은, C처럼, 가장 가까이서 둘러싸는 for 나 while 루프로부터 빠져나가게
   만듬
 - 루프 문은 else 절을 가질 수 있음
   . 루프가 이터러블의 소진이나 (for의 경우)
     조건이 거짓이 돼서 (while의 경우) 종료할 때 실행됨
   . 하지만 루프가 break 문으로 종료할 때는 실행되지 않음
   . 소수를 찾는 루프를 통해 다음에서 예시
  >>> for n in range(2, 10):
  ...     for x in range(2, n):
  ...         if n % x == 0:
  ...             print(n, 'equals', x, '*', n//x)
  ...             break
  ...     else:
  ...         # loop fell through without finding a factor
  ...         print(n, 'is a prime number')
  ...
  2 is a prime number
  3 is a prime number
  4 equals 2 * 2
  5 is a prime number
  6 equals 2 * 3
  7 is a prime number
  8 equals 2 * 4
  9 equals 3 * 3

 - try 문의 else 절은 예외가 발생하지 않을 때 실행되고, 루프의 else 절은 
   break가 발생하지 않을 때 실행됨
 - continue 문은, 역시 C에서 빌렸음, 루프의 다음 이터레이션에서 계속하도록 만듬

○ pass 문
 - pass 문은 아무것도 하지 않음
 - 문법적으로 문장이 필요하지만, 프로그램이 특별히 할 일이 없을 때 사용
  >>> while True:
  ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
  ...
  
  >>> class MyEmptyClass:
  ...     pass
  ...
  
  >>> def initlog(*args):
  ...     pass   # Remember to implement this!
  ...

○ 함수 정의하기
  >>> def fib(n):    # write Fibonacci series up to n
  ...     """Print a Fibonacci series up to n."""
  ...     a, b = 0, 1
  ...     while a < n:
  ...         print(a, end=' ')
  ...         a, b = b, a+b
  ...     print()
  ...
  >>> fib(2000)
  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
  
 - 함수의 실행은 함수의 지역 변수들을 위한 새 심볼 테이블을 만듬
   . 함수에서의 모든 변수 대입들은 값을 지역 심볼 테이블에 저장함
     ※ 모든 대입은 모두 지역 변수로 본다는 말
   . 반면에 변수 참조는 
     1) 먼저 지역 심볼 테이블을 본 다음, 
     2) 전역 심볼 테이블을 본 후, 
     3) 마지막으로 내장 이름들의 테이블을 살핌
   . 그래서, 참조될 수는 있다 하더라도, 
     전역 변수들과 둘러싸는 함수의 변수들은 함수 내에서 직접 값이 대입될 수 없음
     (전역 변수를 global문으로 명시하거나 둘러싸는 함수의 변수를 nonlocal문으로
      명시하지 않는 이상).
 - 함수 호출로 전달되는 실제 매개변수들 (인자들)은 호출될 때 호출되는 함수의 
   지역 심볼 테이블에 만들어짐
   . 그래서 인자들은 값에 의한 호출(call by value)로 전달됨 
     (값은 항상 객체의 값이 아니라 객체 참조) 
   . 함수가 다른 함수를 호출할 때, 그 호출을 위한 새 지역 심볼 테이블이 만들어짐
 - 함수 정의는 현재 심볼 테이블에 함수 이름을 만듬 
   . 함수 이름의 값은 인터프리터가 사용자 정의 함수로 인식하는 형임 
   . 이 값은 다른 이름에 대입될 수 있는데, 이 역시 함수로 사용될 수 있음 
   . 이것이 이름을 바꾸는 일반적인 방법임
  >>> fib
  <function fib at 10042ed0>
  >>> f = fib
  >>> f(100)
  0 1 1 2 3 5 8 13 21 34 55 89

  >>> def fib2(n):  # return Fibonacci series up to n
  ...     """Return a list containing the Fibonacci series up to n."""
  ...     result = []
  ...     a, b = 0, 1
  ...     while a < n:
  ...         result.append(a)    # see below
  ...         a, b = b, a+b
  ...     return result
  ...
  >>> f100 = fib2(100)    # call it
  >>> f100                # write the result
  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

 - return 문은 함수로부터 값을 갖고 복귀하게 만듬
   . 표현식 인자 없는 return 은 None을 돌려줌
   . 함수의 끝으로 떨어지면 역시 None을 돌려줌

○ 기본 인자 값
  def ask_ok(prompt, retries=4, reminder='Please try again!'):
      while True:
          ok = input(prompt)
          if ok in ('y', 'ye', 'yes'):
              return True
          if ok in ('n', 'no', 'nop', 'nope'):
              return False
          retries = retries - 1
          if retries < 0:
              raise ValueError('invalid user response')
          print(reminder)

 - 기본값은 함수 정의 시점에 정의되고 있는 스코프에서 구해짐
  i = 5
  def f(arg=i):
      print(arg)
  i = 6
  f()
  는 5를 인쇄함

 - 기본값은 오직 한 번만 값이 구해짐
   . 이것은 기본값이 리스트나 딕셔너리나 대부분 클래스의 인스턴스와 같은 
     가변 객체일 때 차이를 만듬
   . 예를 들어, 다음 함수는 계속되는 호출로 전달된 인자들을 누적함

  def f(a, L=[]):
      L.append(a)
      return L

  print(f(1))
  print(f(2))
  print(f(3))
  다음과 같은 것을 인쇄함
  [1]
  [1, 2]
  [1, 2, 3]

 - 연속된 호출 간에 기본값이 공유되지 않기를 원한다면, 대신 이런 식으로 씀

  def f(a, L=None):
      if L is None:
          L = []
      L.append(a)
      return L

 - 함수는 kwarg=value 형식의 키워드 인자를 사용해서 호출될 수 있음

 - **name 형식의 마지막 형식 매개변수가 존재하면, 형식 매개변수들에 대응하지 
   않는 모든 키워드 인자들을 담은 딕셔너리 (매핑 형 : dict 를 보세요) 를 받음
   . 이것은 *name (다음 서브섹션에서 설명함) 형식의 형식 매개변수와 조합될 수 
     있는데, 형식 매개변수 목록 밖의 위치 인자들을 담은 튜플을 받음
     (*name은 **name 앞에 나와야 합니다.)
   . 예를 들어, 이런 함수를 정의하면
  def cheeseshop(kind, *arguments, **keywords):
      print("-- Do you have any", kind, "?")
      print("-- I'm sorry, we're all out of", kind)
      for arg in arguments:
          print(arg)
      print("-" * 40)
      for kw in keywords:
          print(kw, ":", keywords[kw])

   이런 식으로 호출될 수 있습니다:

  cheeseshop("Limburger", 
             "It's very runny, sir.",
             "It's really very, VERY runny, sir.",
             shopkeeper="Michael Palin",
             client="John Cleese",
             sketch="Cheese Shop Sketch")
   그리고 당연히 이렇게 인쇄합니다:
  -- Do you have any Limburger ?
  -- I'm sorry, we're all out of Limburger
  It's very runny, sir.
  It's really very, VERY runny, sir.
  ----------------------------------------
  shopkeeper : Michael Palin
  client : John Cleese
  sketch : Cheese Shop Sketch
   . 인쇄되는 키워드 인자들의 순서가 함수 호출로 전달된 순서와 일치함이 
     보장됨에 주목

○ 특수 매개 변수
  def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
        -----------    ----------     ----------
          |             |                  |
          |        Positional or keyword   |
          |                                - Keyword only
           -- Positional only
 - 함수 정의에 /와 *가 없으면, 인자를 위치나 키워드로 함수에 전달
   ※ 호출 시 f(1)와 f(a=1), f(L=[1,2], a=3) 모두 가능
 - 함수 정의에 /가 없으면, 위치 전용 매개 변수는 없음
 - 첫번째 키워드 전용 매개 변수 바로 전에 인자 목록에 *를 넣음
 - 위치 인자 name과 name을 키로 가지는 **kwds 사이에 잠재적인 충돌이 있는 
   이 함수 정의를 고려하십시오:
   
  def foo(name, **kwds):
      return 'name' in kwds

   . 'name' 키워드는 항상 첫 번째 매개 변수에 결합하므로 True를 반환할 수 있는 
     호출은 불가능함. 예를 들면:
  >>> foo(1, **{'name': 2})
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: foo() got multiple values for argument 'name'
  >>>
  
  ※ foo(1, **{'name': 2})는 foo(1, name = 2) 와 같음
  
 - 그러나 /(위치 전용 인자)를 사용하면, name을 위치 인자로, 
   동시에 'name'을 키워드 인자의 키로 사용할 수 있으므로 가능함
  def foo(name, /, **kwds):
      return 'name' in kwds
  >>> foo(1, **{'name': 2})
  True
   . 즉, 위치 전용 매개 변수의 이름을 **kwds에서 모호함 없이 사용할 수 있음

○ 임의의 인자 목록
  def write_multiple_items(file, separator, *args):
      file.write(separator.join(args))

 - 가변 길이 인자들은 형식 매개변수 목록의 마지막에 옴
   . 함수로 전달된 남은 입력 인자들 전부를 그러모으기 때문
   . 하지만, *args 매개변수 뒤에 등장하는 형식 매개변수들은 모두 <키워드-전용〉
     인자이며, 위치 인자 대신 키워드 인자로만 사용될 수 있음
  >>> def concat(*args, sep="/"):
  ...     return sep.join(args)
  ...
  >>> concat("earth", "mars", "venus")
  'earth/mars/venus'
  >>> concat("earth", "mars", "venus", sep=",")
  'earth,mars,venus'
  >>> concat("earth", "mars", "venus", ",")
  'earth/mars/venus/,'
  
○ 인자 목록 언 패킹
 - 리스트와 튜플로부터 인자를 언 패킹하기 위해 *-연산자를 사용해서 함수를 호출
  >>> list(range(3, 6))            # normal call with separate arguments
  [3, 4, 5]
  >>> args = [3, 6]
  >>> list(range(*args))           # call with arguments unpacked from a list
  [3, 4, 5]
  >>> L = ['a','b','c']
  >>> concat(*L)
  'a/b/c'

 - 같은 방식으로 딕셔너리도 **연산자를 써서 키워드 인자를 전달할 수 있음
  >>> def parrot(voltage, state='a stiff', action='voom'):
  ...     print("-- This parrot wouldn't", action, end=' ')
  ...     print("if you put", voltage, "volts through it.", end=' ')
  ...     print("E's", state, "!")
  ...
  >>> d = {"voltage":"four million","state":"bleedin' demised","action": "VOOM"}
  >>> parrot(**d)
  -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !

○ 람다 표현식
 - lambda 키워드들 사용해서 작고 이름 없는 함수를 만들 수 있음
 - 이 함수는 두 인자의 합을 돌려줌: lambda a, b: a+b. 
 - 함수 객체가 있어야 하는 곳이면 어디나 람다 함수가 사용될 수 있음
 - 문법적으로는 하나의 표현식으로 제한됨
 - 의미적으로는, 일반적인 함수 정의의 편의 문법일 뿐임
 - 중첩된 함수 정의처럼, 람다 함수는 둘러싸는 스코프에 있는 
   변수들을 참조할 수 있음
  >>> def make_incrementor(n):
  ...     return lambda x: x + n
  ...
  >>> f = make_incrementor(42)
  >>> f(0)
  42
  >>> f(1)
  43
 - 위의 예는 함수를 돌려주기 위해 람다 표현식을 사용함
   . 또 다른 용도는 작은 함수를 인자로 전달하는 것임
>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

○ 도큐멘테이션 문자열
 - 첫 줄은 항상 객체의 목적을 짧고, 간결하게 요약해야 함
 - 간결함을 위해, 객체의 이름이나 형을 명시적으로 언급하지 않아야 하는데, 
   이것들은 다른 방법으로 제공되기 때문임
   . 이름이 함수의 작업을 설명하는 동사라면 예외임
   . 이 줄은 대문자로 시작하고 마침표로 끝나야 함
 - 도큐멘테이션 문자열에 여러 줄이 있다면, 두 번째 줄은 비어있어서, 
   시각적으로 요약과 나머지 설명을 분리해야 함
   뒤따르는 줄들은 하나나 그 이상의 문단으로, 객체의 호출 규약, 부작용 등을 
   설명해야 함
 - 파이썬 파서는 여러 줄 문자열 리터럴에서 들여쓰기를 제거하지 않기 때문에, 
   설명서를 처리하는 도구들은 필요하면 들여쓰기를 제거함
   . 이것은 다음과 같은 관례를 사용함
   . 문자열의 첫줄 뒤에 오는 첫 번째 비어있지 않은 줄이 전체 도튜멘테이션 
     문자열의 들여쓰기 수준을 결정함
   . 우리는 첫 줄을 사용할 수 없는데, 일반적으로 문자열을 시작하는 따옴표에 
     붙어있어서 들여쓰기가 문자열 리터럴의 것을 반영하지 않기 때문임
   . 이 들여쓰기와 《동등한》 공백이 문자열의 모든 줄의 시작 부분에서 제거됨
   . 덜 들여쓰기 된 줄이 나타나지는 말아야 하지만, 나타난다면 모든 앞부분의 
     공백이 제거됩니다. 공백의 동등성은 탭 확장 (보통 8개의 스페이스)후에 검사됨

  >>> def my_function():
  ...     """Do nothing, but document it.
  ...
  ...     No, really, it doesn't do anything.
  ...     """
  ...     pass
  ...
  >>> print(my_function.__doc__)
  Do nothing, but document it.
  
      No, really, it doesn't do anything.
  
○ 함수 어노테이션
 - 함수 어노테이션은 사용자 정의 함수가 사용하는 형들에 대한 완전히 선택적인 
   메타데이터 정보임
 - 어노테이션은 함수의 __annotations__ 어트리뷰트에 딕셔너리로 저장되고 
   함수의 다른 부분에는 아무런 영향을 미치지 않음
 - 매개변수 어노테이션은 매개변수 이름 뒤에 오는 콜론으로 정의되는데, 
   값을 지정할 때는 어노테이션 뒤에 값을 주는 표현식이 뒤따름
 - 반환 값 어노테이션은 리터럴 -> 와 그 뒤를 따르는 표현식으로 정의되는데, 
   매개변수 목록과 def 문의 끝을 나타내는 콜론 사이에 놓임
 - 다음 예에서 위치 인자, 키워드 인자, 반환 값이 어노테이트 됨
  >>> def f(ham: str, eggs: str = 'eggs') -> str:
  ...     print("Annotations:", f.__annotations__)
  ...     print("Arguments:", ham, eggs)
  ...     return ham + ' and ' + eggs
  ...
  >>> f('spam')
  Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
  Arguments: spam eggs
  'spam and eggs'
  
  ※ 메타데이터 정보는 내장 데이타 타입명 또는 function명, class명, None이어야 함
  ※ 내장 데이타 타입명
    . Text Type:	str
    . Numeric Types:	int, float, complex
    . Sequence Types:	list, tuple, range
    . Mapping Type:	dict
    . Set Types:	set, frozenset
    . Boolean Type:	bool
    . Binary Types:	bytes, bytearray, memoryview

○ 코딩 스타일
 - 들려 쓰기에 4-스페이스를 사용하고, 탭을 사용하지 마세요.
 - 79자를 넘지 않도록 줄 넘김 하세요.
 - 함수, 클래스, 함수 내의 큰 코드 블록 사이에 빈 줄을 넣어 분리하세요.
 - 가능하다면, 주석은 별도의 줄로 넣으세요.
 - 독스트링을 사용하세요.
 - 연산자들 주변과 콤마 뒤에 스페이스를 넣고, 괄호 바로 안쪽에는 스페이스를 
   넣지 마세요: a = f(1, 2) + g(3, 4)
 - 클래스와 함수들에 일관성 있는 이름을 붙이세요; 관례는 클래스의 경우 
   UpperCamelCase, 함수와 메서드의 경우 lowercase_with_underscores입니다. 
   첫 번째 메서드 인자의 이름으로는 항상 self를 사용하세요 
   (클래스와 메서드에 대한 자세한 내용은 클래스와의 첫 만남 을 보세요)
 - 여러분의 코드를 국제적인 환경에서 사용하려고 한다면 특별한 인코딩을 사용하지
   마세요. 어떤 경우에도 파이썬의 기본, UTF-8, 또는 단순 ASCII조차, 
   이 최선입니다.
 - 마찬가지로, 다른 언어를 사용하는 사람이 코드를 읽거나 유지할 약간의 가능성만 
   있더라도, 식별자에 ASCII 이외의 문자를 사용하지 마세요.

○ 리스트(list)
 - insert, remove, sort 같은 메서드들이 리스트를 수정할 뿐 반환 값이 출력되지
   않는 것을 알아챘을 것입니다. 기본 None 을 돌려주고 있습니다.
   이것은 파이썬에서 모든 가변 자료 구조들에 적용되는 설계 원리입니다.
 - 정수를 문자열과 비교할 수 없고 None을 다른 형과 비교할 수 없기 때문에 
   [None, 'hello', 10]는 정렬되지 않습니다. 또한 정의된 대소 관계가 없는 형이 
   있습니다. 예를 들어, 3+4j < 5+7j는 올바른 비교가 아닙니다.
   
  >>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
  >>> fruits.count('apple')
  2
  >>> fruits.count('tangerine')
  0
  >>> fruits.index('banana')
  3
  >>> fruits.index('banana', 4)  # Find next banana starting a position 4
  6
  >>> fruits.reverse()
  >>> fruits
  ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
  >>> fruits.append('grape')
  >>> fruits
  ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
  >>> fruits.sort()
  >>> fruits
  ['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
  >>> fruits.pop()
  'pear'

 - 큐 사용하기
  >>> from collections import deque
  >>> queue = deque(["Eric", "John", "Michael"])
  >>> queue.append("Terry")           # Terry arrives
  >>> queue.append("Graham")          # Graham arrives
  >>> queue.popleft()                 # The first to arrive now leaves
  'Eric'
  >>> queue.popleft()                 # The second to arrive now leaves
  'John'
  >>> queue                           # Remaining queue in order of arrival
  deque(['Michael', 'Terry', 'Graham'])

 - 리스트 컴프리헨션
  >>> squares = []
  >>> for x in range(10):
  ...     squares.append(x**2)
  ...
  >>> squares
  [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  
  squares = list(map(lambda x: x**2, range(10)))
  
  squares = [x**2 for x in range(10)]
  
  >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
  [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
  
  >>> combs = []
  >>> for x in [1,2,3]:
  ...     for y in [3,1,4]:
  ...         if x != y:
  ...             combs.append((x, y))
  ...
  >>> combs
  [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
 - 표현식이 튜플이면 (즉 앞의 예에서 (x, y)), 반드시 괄호로 둘러싸야 함
  >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
  >>> [weapon.strip() for weapon in freshfruit]
  ['banana', 'loganberry', 'passion fruit']
  
  >>> # the tuple must be parenthesized, otherwise an error is raised
  >>> [x, x**2 for x in range(6)]
    File "<stdin>", line 1, in <module>
      [x, x**2 for x in range(6)]
               ^
  SyntaxError: invalid syntax
  >>> # flatten a list using a listcomp with two 'for'
  >>> vec = [[1,2,3], [4,5,6], [7,8,9]]
  >>> [num for elem in vec for num in elem]
  [1, 2, 3, 4, 5, 6, 7, 8, 9]
  >>> [num for num in elem for elem in vec]
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  NameError: name 'elem' is not defined

 - 리스트 컴프리헨션은 복잡한 표현식과 중첩된 함수들을 포함할 수 있음
  >>> from math import pi
  >>> [str(round(pi, i)) for i in range(1, 6)]
  ['3.1', '3.14', '3.142', '3.1416', '3.14159']

  >>> matrix = [
  ...     [1, 2, 3, 4],
  ...     [5, 6, 7, 8],
  ...     [9, 10, 11, 12],
  ... ]

  >>> [[row[i] for row in matrix] for i in range(3)]
  [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
 - 앞절에서 보았듯이, 중첩된 리스트 컴프리헨션은 뒤따르는 for 의 문맥에서 값이 
   구해짐
  >>> list(zip(*matrix))
  [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]

 - del 문은 리스트에서 슬라이스를 삭제하거나 전체 리스트를 비우는 데도 사용됨
  >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
  >>> del a[0]
  >>> a
  [1, 66.25, 333, 333, 1234.5]
  >>> del a[2:4]
  >>> a
  [1, 66.25, 1234.5]
  >>> del a[:]
  >>> a
  []

 - del 는 변수 자체를 삭제하는데에도 사용될 수 있음
  >>> del a

○ 튜플과 시퀀스
 - 리스트와 문자열이 인덱싱과 슬라이싱 연산과 같은 많은 성질을 공유함을 보았음
 - 시퀀스형 -- list, tuple, range
 - 튜플은 쉼표로 구분되는 여러 값으로 구성됨
  >>> t = 12345, 54321, 'hello!'
  >>> t[0]
  12345
  >>> t
  (12345, 54321, 'hello!')
  >>> # Tuples may be nested:
  ... u = t, (1, 2, 3, 4, 5)
  >>> u
  ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
  >>> # Tuples are immutable:
  ... t[0] = 88888
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: 'tuple' object does not support item assignment
  >>> # but they can contain mutable objects:
  ... v = ([1, 2, 3], [3, 2, 1])
  >>> v
  ([1, 2, 3], [3, 2, 1])
 - 튜플은 불변 이고, 보통 이질적인 요소들의 시퀀스를 포함함
   요소들은 언 패킹 (이 섹션의 뒤에 나옴) 이나 인덱싱 
   (또는 네임드 튜플의 경우는 어트리뷰트로도) 으로 액세스함
   리스트는 가변이고, 요소들은 보통 등질적이고 리스트에 대한 
   이터레이션으로 액세스됨
 - 특별한 문제는 비었거나 하나의 항목을 갖는 튜플을 만드는 것임
   이 경우를 수용하기 위해 문법은 추가적인 예외 사항을 갖고 있음
   빈 튜플은 빈 괄호 쌍으로 만들어짐
   하나의 항목으로 구성된 튜플은 값 뒤에 쉼표를 붙여서 만듬
   (값 하나를 괄호로 둘러싸기만 하는 것으로는 충분하지 않음) 
   추합니다, 하지만 효과적임. 예를 들어:
  >>> empty = ()
  >>> singleton = 'hello',    # <-- note trailing comma
  >>> len(empty)
  0
  >>> len(singleton)
  1
  >>> singleton
  ('hello',)
 - 문장 t = 12345, 54321, 'hello!' 는 튜플 패킹의 예
   값 12345, 54321, 'hello!' 는 함께 튜플로 패킹됨
   반대 연산 또한 가능함
  >>> x, y, z = t
   . 이것은, 충분히 적절하게도, 시퀀스 언 패킹 이라고 불리고 
   . 오른쪽에 어떤 시퀀스가 와도 됨
   . 시퀀스 언 패킹은 등호의 좌변에 시퀀스에 있는 요소들과 같은 개수의 
     변수들이 올 것을 요구함
   . 다중 대입은 사실 튜플 패킹과 시퀀스 언 패킹의 조합일뿐이라는 것에 유의

  >>> s = [1, 2, 3]
  >>> x, y, z = s
  >>> x
  1
  >>> y
  2
  >>> z
  3
  >>> x, y, z = range(0, 3)
  >>> x
  0
  >>> y
  1
  >>> z
  2

○ 집합(Set)
 - 집합은 중복되는 요소가 없는 순서 없는 컬렉션임
 - 기본적인 용도는 멤버십 검사와 중복 엔트리 제거임
 - 집합 객체는 합집합, 교집합, 차집합, 대칭 차집합과 같은 수학적인 연산들도 지원
 - 집합을 만들 때는 중괄호나 set() 함수를 사용할 수 있음
   . 주의사항: 빈 집합을 만들려면 set()을 사용해야 함. 
               {} 가 아님. 후자는 빈 딕셔너리를 만듬
  >>> b = {1,4, 5}
  >>> c = {}
  >>> type(c)
  <class 'dict'>
  >>> type(b)
  <class 'set'>
               
  >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
  >>> print(basket)               # show that duplicates have been removed
  {'orange', 'banana', 'pear', 'apple'}
  >>> 'orange' in basket          # fast membership testing
  True
  >>> 'crabgrass' in basket
  False
  
  >>> # Demonstrate set operations on unique letters from two words
  ...
  >>> a = set('abracadabra')
  >>> b = set('alacazam')
  >>> a                                  # unique letters in a
  {'a', 'r', 'b', 'c', 'd'}
  >>> a - b                              # letters in a but not in b
  {'r', 'd', 'b'}
  >>> a | b                              # letters in a or b or both
  {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
  >>> a & b                              # letters in both a and b
  {'a', 'c'}
  >>> a ^ b                              # letters in a or b but not both
  {'r', 'd', 'b', 'm', 'z', 'l'}
 - 리스트 컴프리헨션과 유사하게, 집합 컴프리헨션도 지원됨
  >>> a = {x for x in 'abracadabra' if x not in 'abc'}
  >>> a
  {'r', 'd'}

○ 딕셔너리
 - 숫자들로 인덱싱되는 시퀀스와 달리, 딕셔너리는 키로 인덱싱되는데, 
   모든 불변형을 사용할 수 있음 
   ※ 키로 set, list, dict형은 안됨
 - 문자열과 숫자들은 항상 키가 될 수 있음
   튜플이 문자열, 숫자, 튜플들만 포함하면, 키로 사용될 수 있음
 - 튜플이 직접적이나 간접적으로 가변 객체를 포함하면, 키로 사용될 수 없음
   . 리스트는 키로 사용할 수 없는데, 리스트는 인덱스 대입, 슬라이스 대입, 
     append() 나 extend() 같은 메서드들로 값이 수정될 수 있기 때문임
 - 딕셔너리를 (한 딕셔너리 안에서) 키가 중복되지 않는다는 제약 조건을 가진 
   키: 값 쌍의 집합(set)으로 생각하는 것이 최선임
 - 중괄호 쌍은 빈 딕셔너리를 만듬: {} 
   . 중괄호 안에 쉼표로 분리된 키:값 쌍들의 목록을 넣으면, 
     딕셔너리에 초기 키:값 쌍들을 제공함
   . 이것이 딕셔너리가 출력되는 방식이기도 함
 - del 로 키:값 쌍을 삭제하는 것도 가능함
   . 이미 사용하고 있는 키로 저장하면, 그 키로 저장된 예전 값은 잊힘
   . 존재하지 않는 키로 값을 추출하는 것은 에러임
 - 딕셔러리에 list(d) 를 수행하면 딕셔너리에서 사용되고 있는 모든 키의 리스트를
   삽입 순서대로 돌려줌
   . (정렬을 원하면 대신 sorted(d) 를 사용하면 됨)
   . 하나의 키가 딕셔너리에 있는지 검사하려면, in 키워드들 사용

  >>> va = {1:'a',2:'b',3:'c',3:'d'}
  >>> va
  {1: 'a', 2: 'b', 3: 'd'}

  >>> tel = {'jack': 4098, 'sape': 4139}
  >>> tel['guido'] = 4127
  >>> tel
  {'jack': 4098, 'sape': 4139, 'guido': 4127}
  >>> tel['jack']
  4098
  >>> del tel['sape']
  >>> tel['irv'] = 4127
  >>> tel
  {'jack': 4098, 'guido': 4127, 'irv': 4127}
  >>> list(tel)
  ['jack', 'guido', 'irv']
  >>> sorted(tel)
  ['guido', 'irv', 'jack']
  >>> 'guido' in tel
  True
  >>> 'jack' not in tel
  False
  
 - dict() 생성자는 키-값 쌍들의 시퀀스로 부터 직접 딕셔너리를 구성합니다.

  >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
  {'sape': 4139, 'guido': 4127, 'jack': 4098}

 - 이에 더해, 딕셔너리 컴프리헨션은 임의의 키와 값 표현식들로 부터 딕셔너리를 
   만드는데 사용될 수 있음

  >>> {x: x**2 for x in (2, 4, 6)}
  {2: 4, 4: 16, 6: 36}

 - 키가 간단한 문자열일 때, 때로 키워드 인자들을 사용해서 쌍을 지정하기가 쉽슴
  >>> dict(sape=4139, guido=4127, jack=4098)
  {'sape': 4139, 'guido': 4127, 'jack': 4098}

○ 루프 테크닉
 - 딕셔너리로 루핑할 때, items() 메서드를 사용하면 키와 거기에 대응하는 값을
   동시에 얻을 수 있음
  >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
  >>> for k, v in knights.items():
  ...     print(k, v)
  ...
  gallahad the pure
  robin the brave
 - 시퀀스를 루핑할 때, enumerate() 함수를 사용하면 위치 인덱스와 대응하는 값을 
   동시에 얻을 수 있음
  >>> for i, v in enumerate(['tic', 'tac', 'toe']):
  ...     print(i, v)
  ...
  0 tic
  1 tac
  2 toe
 - 둘이나 그 이상의 시퀀스를 동시에 루핑하려면, zip() 함수로 엔트리들의 쌍을 
   만들 수 있음
  >>> questions = ['name', 'quest', 'favorite color']
  >>> answers = ['lancelot', 'the holy grail', 'blue']
  >>> for q, a in zip(questions, answers):
  ...     print('What is your {0}?  It is {1}.'.format(q, a))
  ...
  What is your name?  It is lancelot.
  What is your quest?  It is the holy grail.
  What is your favorite color?  It is blue.

 - 시퀀스를 거꾸로 루핑하려면, 먼저 정방향으로 시퀀스를 지정한 다음에 
   reversed() 함수를 호출
  >>> for i in reversed(range(1, 10, 2)):
  ...     print(i)
  ...
  9
  7
  5
  3
  1

 - 정렬된 순서로 시퀀스를 루핑하려면, sorted() 함수를 사용해서 소스를 변경하지
   않고도 정렬된 새 리스트를 받을 수 있습니다.
  >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
  >>> for f in sorted(set(basket)):
  ...     print(f)
  ...
  apple
  banana
  orange
  pear
  
 - 때로 루프를 돌고 있는 리스트를 변경하고픈 유혹을 느낍니다; 하지만, 종종, 
   대신 새 리스트를 만드는 것이 더 간단하고 더 안전합니다.
   
  >>> import math
  >>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
  >>> filtered_data = []
  >>> for value in raw_data:
  ...     if not math.isnan(value):
  ...         filtered_data.append(value)
  ...
  >>> filtered_data
  [56.2, 51.7, 55.3, 52.5, 47.8]
  
 - 비교 연산자 in 과 not in 은 값이 시퀀스에 있는지 (없는지) 검사함
 - 연산자 is 와 is not 은 두 객체가 진짜로 같은 객체인지 비교함
   . 이것은 리스트와 같은 가변 객체에서만 의미가 있음
   . 모든 비교 연산자들은 같은 우선순위를 갖는데, 모든 산술 연산자들보다 낮음
 - 비교는 연쇄할 수 있음
   . 예를 들어, a < b == c 는, a 가 b 보다 작고, 동시에 b 가 c 와 같은지 검사함
 - 비교는 논리 연산자 and 와 or 를 사용해서 결합할 수 있고, 비교의 결과는 
   (또는 그 밖의 모든 논리 표현식은) not 으로 부정될 수 있음
   . 이것들은 비교 연산자보다 낮은 우선순위를 갖음
   . 이것 간에는 not 이 가장 높은 우선순위를 갖고, or 가 가장 낮음
   . 그래서 A and not B or C 는 (A and (not B)) or C 와 동등함
 - 논리 연산자 and 와 or 는 소위 단락-회로(short-circuit) 연산자임
   . 인자들은 왼쪽에서 오른쪽으로 값이 구해지고, 결과가 결정되자마자 값 구하기는
     중단됨
   . 예를 들어, A 와 C 가 참이고 B 가 거짓이면, A and B and C 는 표현식 C 의 
     값을 구하지 않음
   . 논리값이 아닌 일반 값으로 사용될 때, 단락-회로 연산자의 반환 값은 
     마지막으로 값이 구해진 인자임
  >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
  >>> non_null = string1 or string2 or string3
  >>> non_null
  'Trondheim'
 - 파이썬에서, C와는 달리, 표현식안에서의 대입은 바다코끼리 연산자 :=를 사용하여
   명시적으로 수행해야 함
 - 시퀀스 간의 비교는 
   . 먼저 첫 두 항목을 비교해서 다르면 이것이 비교의 결과를 결정함
   . 같으면, 다음 두 항목을 비교하고, 이런 식으로 어느 한 시퀀스가 소진될 
     때까지 계속함
   . 만약 비교되는 두 항목 자체가 같은 형의 시퀀스면, 사전식 비교가 
     재귀적으로 수행됨
   . 두 시퀀스의 모든 항목이 같다고 비교되면, 시퀀스들은 같은 것으로 취급됨
   . 한 시퀀스가 다른 하나의 머리 부분 서브 시퀀스면, 짧은 시퀀스가 작은 것임
   . 문자열의 사전식 배열은 개별 문자들의 순서를 정하는데 유니코드 코드 포인트 
     숫자를 사용함
   . 같은 형의 시퀀스들 간의 비교의 몇 가지 예
  (1, 2, 3)              < (1, 2, 4)
  [1, 2, 3]              < [1, 2, 4]
  'ABC' < 'C' < 'Pascal' < 'Python'
  (1, 2, 3, 4)           < (1, 2, 4)
  (1, 2)                 < (1, 2, -1)
  (1, 2, 3)             == (1.0, 2.0, 3.0)
  (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

○ 모듈
 - 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용할 
   수 있는 방법을 제공하는데, 그런 파일을 모듈이라고 부름
 - 메인 모듈은 최상위 수준에서 실행되는 스크립트나 계산기 모드에서 액세스하는 
   변수들의 컬렉션임
 - 모듈은 파이썬 정의와 문장들을 담고 있는 파일임
   . 파일의 이름은 모듈 이름에  확장자 .py 를 붙임
   . 모듈 내에서, 모듈의 이름은 전역 변수 __name__ 으로 제공됨
 - 모듈에 들어있는 이름들을 직접 임포트하는 모듈의 심볼 테이블로 임포트하는 
   import문의 변종이 있음

  >>> from fibo import fib, fib2
  >>> fib(500)
  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
  >>> from fibo import *
  >>> fib(500)
  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

 - 이것은 밑줄 (_) 로 시작하는 것들을 제외한 모든 이름을 임포트함
 - 모듈 이름 다음에 as 가 올 경우, as 다음의 이름을 임포트한 모듈에 직접 연결함
  >>> import fibo as fib
  >>> fib.fib(500)
  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 

  from fibo import fib as fibonacci
  >>> fibonacci(500)
  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377

○ 모듈을 스크립트로 실행하기

  python fibo.py <arguments>
  
 - 모듈에 있는 코드는, 그것을 임포트할 때처럼 실행됨
   . 하지만 __name__ 은 "__main__" 로 설정됨
   . 이것은, 이 코드를 모듈의 끝에 붙여서:

  if __name__ == "__main__":
      import sys
      fib(int(sys.argv[1]))

 - 파일을 임포트할 수 있는 모듈뿐만 아니라 스크립트로도 사용할 수 있도록 만들 수 
   있음을 의미하는데, 오직 모듈이 《메인》 파일로 실행될 때만 명령행을 파싱하는 
   코드가 실행되기 때문임

○ 모듈 검색 경로
 - 모듈이 임포트될 때, 인터프리터는 먼저 그 이름의 내장 모듈을 찾음
 - 발견되지 않으면, 변수 sys.path 로 주어지는 디렉터리들에서 
   spam.py 라는 이름의 파일을 찾음
 - sys.path는 이 위치들로 초기화됨
   . 입력 스크립트를 포함하는 디렉터리 (또는 파일이 지정되지 않았을 때는 
     현재 디렉터리).
   . PYTHONPATH (디렉터리 이름들의 목록, 셸 변수 PATH 와 같은 문법)
   . 설치 의존적인 기본값
 - 초기화 후에, 파이썬 프로그램은 sys.path 를 수정할 수 있음
   . 스크립트를 포함하는 디렉터리는 검색 경로의 처음에, 
     표준 라이브러리 경로의 앞에 놓임
   . 이것은 같은 이름일 경우 라이브러리 디렉터리에 있는 것 대신 스크립트를 
     포함하는 디렉터리의 것이 로드된다는 뜻임
   . 이 치환이 의도된 것이 아니라면 에러임

○ 컴파일된 파이썬 파일
 - 모듈 로딩을 빠르게 하려고, 파이썬은 __pycache__ 디렉터리에 각 모듈의 컴파일된
   버전을 module.version.pyc 라는 이름으로 캐싱
   . version 은 컴파일된 파일의 형식을 지정함
   . 일반적으로 파이썬의 버전 번호를 포함함
   . 예를 들어, CPython 배포 3.3 에서 spam.py 의 컴파일된 버전은 
     __pycache__/spam.cpython-33.pyc로 캐싱 됨
 - 파이썬은 소스의 수정 시간을 컴파일된 버전과 비교해서 시효가 지나 다시 
   컴파일해야 하는지 검사함
   . 이것은 완전히 자동화된 과정임
   . 또한, 컴파일된 모듈은 플랫폼 독립적이기 때문에, 같은 라이브러리를 서로 
     다른 아키텍처를 갖는 시스템들에서 공유할 수 있음
 - 파이썬은 두 가지 상황에서 캐시를 검사하지 않음
   . 첫째로, 명령행에서 직접 로드되는 모듈들은 항상 재컴파일하고 그 결과를 
     저장하지 않음
   . 둘째로, 소스 모듈이 없으면 캐시를 검사하지 않음
   . 소스 없는 (컴파일된 파일만 있는) 배포를 지원하려면, 컴파일된 모듈이 
     소스 디렉터리에 있어야 하고, 소스 모듈이 없어야 함
 - 컴파일된 모듈의 크기를 줄이려면 파이썬 명령에 -O 나 -OO 스위치를 사용할 수 
   있음
   . -O 스위치는 assert 문을 제거하고, 
   . -OO 스위치는 assert 문과 __doc__ 문자열을 모두 제거함
   . 어떤 프로그램들은 이것들에 의존하기 때문에, 무엇을 하고 있는 지 아는 경우만
     이 옵션을 사용해야 함
   . 《최적화된》 모듈은 opt- 태그를 갖고, 보통 더 작음
   . 미래의 배포에서는 최적화의 효과가 변경될 수 있음
 - .py 파일에서 읽을 때보다 .pyc 파일에서 읽을 때 프로그램이 더 빨리 실행되지는 
   않음
   . .pyc 파일에서 더 빨라지는 것은 로드되는 속도뿐임
 - 모듈 compileall은 디렉터리에 있는 모든 모듈의 .pyc 파일들을 만들 수 있음

○ 표준 모듈들
 - sys. 모든 파이썬 인터프리터에 내장됨
   . 변수 sys.ps1 와 sys.ps2 는 기본과 보조 프롬프트로 사용되는 문자열을 정의함
 - 변수 sys.path 는 인터프리터의 모듈 검색 경로를 결정하는 문자열들의 리스트임
   . 환경 변수 PYTHONPATH에서 취한 기본 경로나, PYTHONPATH가 설정되지 않는 경우
     내장 기본값으로 초기화됨 
   . 표준 리스트 연산을 사용해서 수정할 수 있음

  >>> import sys
  >>> sys.path.append('/ufs/guido/lib/python')

○ dir() 함수
 - 내장 함수 dir() 은 모듈이 정의하는 이름들을 찾는 데 사용됨
   . 문자열들의 정렬된 리스트를 돌려줌

  >>> import fibo, sys
  >>> dir(fibo)
  ['__name__', 'fib', 'fib2']

 - 인자가 없으면, dir() 는 현재 정의한 이름들을 나열합니다:

  >>> a = [1, 2, 3, 4, 5]
  >>> import fibo
  >>> fib = fibo.fib
  >>> dir()
  ['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']

 - dir() 은 내장 함수와 변수들의 이름을 나열하지 않음
   . 그것들의 목록을 원한다면, 표준 모듈 builtins 에 정의되어 있음

  >>> import builtins
  >>> dir(builtins)  
  
○ 패키지
 - 점으로 구분된 모듈 이름을 써서 파이썬의 모듈 이름 공간을 구조화하는 방법
 - 모듈들의 컬렉션
 sound/                         Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
 - sys.path에 있는 디렉토리를 검색하면서 패키지 서브 디렉토리를 찾음
 - 파이썬이 디렉토리를 패키지로 취급하게 만들기 위해서 __init__.py 파일이 필요함
 - 패키지 사용자는 패키지로부터 개별 모듈을 임포트 할 수 있음
   . import sound.effects.echo
   . 전체 이름으로 참조되어야 함
   . sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
 - 또 다른 방법은 
   . from sound.effects import echo
   . 패키지 접두어 없이 사용할 수 있게 함
   . echo.echofilter(input, output, delay=0.7, atten=4)
 - 또 다른 방법은 원하는 함수나 변수를 직접 임포트하는 것
   . from sound.effects.echo import echofilter
   . echofilter(input, output, delay=0.7, atten=4)
 - from package import item 를 사용할 때, 
   . item은 패키지의 서브 모듈 (또는 서브 패키지)일 수도 있고 
   . 함수, 클래스, 변수 등 패키지에 정의된 다른 이름들일 수도 있음
   . import 문은 먼저 item이 패키지에 정의되어 있는지 검사하고, 
   . 그렇지 않으면 모듈이라고 가정하고 로드를 시도함
   . 찾지 못한다면, ImportError 예외를 일으킴
 - import item.subitem.subsubitem와 같은 문법을 사용할 때
   . 마지막 것을 제외한 각 항목은 반드시 패키지여야 함
   . 마지막 항목은 모듈인 패키지가 될 수 있지만,
   . 앞의 항목에서 정의된 클래스, 함수, 변수 등이 될 수는 없음   

○ 패키지에서 * 임포트하기
 - from sound.effects import * 가 모두를 임포트 하기를 원할 것임
   . 시간이 오래 걸리고 
   . 어떤 서브 모듈을 명시적으로 임포트할 경우만 일어나야만 하는 원하지 않는 
     부수적 효과가 발생할 수 있음
 - 유일한 해결책은 패키지 저자가 패키지의 색인을 명시적으로 제공하는 것
   . import 문은 다음과 같은 관례가 있음
   . 패키지의 __init__.py 코드가 __all__ 이라는 이름의 목록을 제공하면, 
   . 이것을 from package import * 를 만날 때 임포트 해야만 하는 모듈 이름들의 
     목록으로 받아들임
 - __all__ 이 정의되지 않으면, 
   . 문장 from sound.effects import * 은 패키지 sound.effects 의 모든 서브 
     모듈들을 현재 이름 공간으로 임포트 하지 않음
   . 이것은 오직 패키지 sound.effects 가 임포트 되도록 만들고 
     (__init__.py 에 있는 초기화 코드들이 수행될 수 있음), 
   . 그 패키지가 정의하는 이름들을 임포트 함. 이 이름들은 
     __init__.py 가 정의하는 모든 이름 (그리고 명시적으로 로드된 서브 모듈들)을 
     포함함. 이 이름들에는 사전에 import 문으로 명시적으로 로드된 패키지의 
     서브 모듈들 역시 포함됨 

○ 패키지 내부 간의 참조
 - 이웃 패키지의 서브 모듈을 가리키는데 절대 임포트를 사용할 수 있고,
 - 상대 임포트를 쓸 수도 있는데, from module import name 형태의 임포트 문을 사용
   . from . import echo
   . from .. import formats
   . from ..filters import equalizer
 - 파이썬 응용 프로그램의 메인 모듈로 사용될 목적의 모듈들은 반드시 절대 
   임포트를 사용해야 함
 
○ 여러 디렉토리에 있는 패키지
 -  패키지는 특별한 어트리뷰트 하나를 더 지원합니다, 
 - __path__. 이것은 패키지의 __init__.py 파일을 실행하기 전에, 
 - 이 파일이 들어있는 디렉터리의 이름을 포함하는 리스트로 초기화됨
 
○ 모듈 수준의 함수 정의를 실행하면 함수의 이름이 전역 심볼 테이블에 들어감



○ 장식적인 출력 포매팅
 - 포맷 문자열 리터럴을 사용하려면, 시작 인용 부호 또는 삼중 인용 부호 앞에 
   f 또는 F 를 붙여 문자열을 시작
  >>> year = 2016
  >>> event = 'Referendum'
  >>> f'Results of the {year} {event}'
  'Results of the 2016 Referendum'
 - 문자열의 str.format() 메서드
 - 문자열 슬라이싱 및 이어붙이기 연산
 - repr() 또는 str() 함수를 사용하여 모든 값을 문자열로 변환할 수 있음

○ 포맷 문자열 리터럴
 - 포맷 문자열 리터럴(간단히 f-문자열이라고도 합니다)은 문자열에 f 또는 
   F 접두어를 붙이고 표현식을 {expression}로 작성하여 문자열에 파이썬 
   표현식의 값을 삽입할 수 있게 함
  >>> import math
  >>> print(f'The value of pi is approximately {math.pi:.3f}.')
  The value of pi is approximately 3.142.   
 - ':' 뒤에 정수를 전달하면 해당 필드의 최소 문자 폭이
  >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
  >>> for name, phone in table.items():
  ...     print(f'{name:10} ==> {phone:10d}')
  ...
  Sjoerd     ==>       4127
  Jack       ==>       4098
  Dcab       ==>       7678
 - 다른 수정자를 사용하면 포맷되기 전에 값을 변환할 수 있음
 - '!a'는 ascii()를, '!s'는 str()을, '!r'는 repr()을 적용함
  >>> animals = 'eels'
  >>> print(f'My hovercraft is full of {animals}.')
  My hovercraft is full of eels.
  >>> print(f'My hovercraft is full of {animals!r}.')
  My hovercraft is full of 'eels'. 

○ 7.1.2. 문자열 format() 메서드
 - str.format() 메서드 기본적인 사용법
  >>> print('We are the {} who say "{}!"'.format('knights', 'Ni')) 
  We are the knights who say "Ni!"
 - 중괄호 안의 숫자는 str.format() 메서드로 전달된 객체들의 위치를 가리키는데 
   사용됨
  >>> print('{1} and {0}'.format('spam', 'eggs'))
  eggs and spam 
 - str.format() 메서드에 키워드 인자가 사용되면, 그 값들은 인자의 이름을 
   사용해서 지정할 수 있음
  >>> print('This {food} is {adjective}.'.format(
  ...       food='spam', adjective='absolutely horrible'))
  This spam is absolutely horrible.   
 - 위치와 키워드 인자를 자유롭게 조합할 수 있음
  >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', other='Georg'))
  The story of Bill, Manfred, and Georg. 
  . 나누고 싶지 않은 정말 긴 포맷 문자열이 있을 때, 포맷할 변수들을 위치 대신에
    이름으로 지정할 수 있음
 - 간단히 딕셔너리를 넘기고 키를 액세스하는데 대괄호 '[]' 를 사용하면 됨
  >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
  >>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
  ...       'Dcab: {0[Dcab]:d}'.format(table))
  Jack: 4098; Sjoerd: 4127; Dcab: 8637678 
 - 〈**〉 표기법을 사용해서 table을 키워드 인자로 전달해도 같은 결과를 
   얻을 수 있음
  >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
  >>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
  Jack: 4098; Sjoerd: 4127; Dcab: 8637678 
 - 이 방법은 모든 지역 변수들을 담은 딕셔너리를 돌려주는 내장 함수 vars()와 
   함께 사용할 때 특히 쓸모가 있음
 - 다음 줄은 정수와 그 제곱과 세제곱을 제공하는 빽빽하게 정렬된 열 집합을 생성
  >>> for x in range(1, 11):
  ...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
  ... 

○ 수동 문자열 포매팅
 - 여기 같은 제곱수와 세제곱수 표를 수동으로 포매팅
  >>> for x in range(1, 11):
  ...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
  ...     # Note use of 'end' on previous line
  ...     print(repr(x*x*x).rjust(4))
  ... 
 - print()의 동작 방식으로 인해 각 칼럼 사이에 스페이스 하나가 추가됨
 - 문자열 객체의 str.rjust() 메서드는 왼쪽에 스페이스를 채워서 주어진 폭으로 
   문자열을 우측 줄 맞춤함
 - 비슷한 메서드 str.ljust() 와 str.center()도 있음
 - 이 메서드들은 어떤 것도 출력하지 않고, 단지 새 문자열을 돌려줌
   . 입력 문자열이 너무 길면, 자르지 않고, 변경 없이 그냥 돌려줌
   . 이것이 열 배치를 엉망으로 만들겠지만, 보통 값에 대해 거짓말을 하게 될 
     대안보다는 낫습니다. 
     (정말로 잘라내기를 원한다면, 항상 슬라이스 연산을 추가할 수 있음
      x.ljust(n)[:n] 처럼)
 - str.zfill()는 숫자 문자열의 왼쪽에 0을 채움
   . 플러스와 마이너스 부호도 이해함
  >>> '12'.zfill(5)
  '00012'
  >>> '-3.14'.zfill(7)
  '-003.14'
  >>> '3.14159265359'.zfill(5)
  '3.14159265359' 
 
○ 예전의 문자열 포매팅
 - % 연산자도 문자열 포매팅에 사용될 수 있음
   . 왼쪽 인자를 오른쪽 인자에 적용되는 sprintf()-스타일 포맷 문자열로 해석하고,
     이 포매팅 연산의 결과로 얻어지는 문자열을 돌려줌
  >>> import math
  >>> print('The value of pi is approximately %5.3f.' % math.pi)
  The value of pi is approximately 3.142.  



○ 파일을 읽고 쓰기
 - open(filename, mode)은 파일 객체를 돌려주고, 두 개의 인자를 주는 방식이 
   가장 많이 사용됨
   
  >>> f = open('workfile', 'w')
 - mode
   . r: 읽기(기본값)
   . w: 쓰기(먼저 truncating)
   . a: 덧붙이기
   . r+: 읽고 쓰기
   . b: 바이너리 모드
   . t: 텍스트모드(기본값)
   . +: 갱신
   . x: 독점적인 파일 만들기용
   . 기본 모드는 'r' 임 (텍스트를 읽는 용으로 염, 'rt' 의 동의어)
   . 모드 'w+'와 'w+b' 는 파일을 열고 자름(truncate) 
   . 모드 'r+'과 'r+b' 는 자르지 않고 파일을 염
 - open(file, mode='r', buffering=-1, encoding=None, errors=None, 
        newline=None, closefd=True, opener=None)
   . encoding은 파일을 디코딩하거나 인코딩하는 데 사용되는 인코딩의 이름
   . 텍스트 모드에서만 사용해야 하며, 기본 인코딩은 플랫폼에 따라 다르지만 
     (locale.getpreferredencoding() 이 돌려주는 값), 
   . 파이썬에서 지원하는 텍스트 인코딩은 모두 사용할 수 있음
   . 지원되는 인코딩 목록은 codecs 모듈을 보면 됩니다.
 - 텍스트 모드에서, 읽을 때의 기본 동작은 플랫폼 의존적인 줄 종료 
   (유닉스에서 \n, 윈도우에서 \r\n)를 단지 \n 로 변경하는 것임
 - 텍스트 모드로 쓸 때, 기본 동작은 \n를 다시 플랫폼 의존적인 줄 종료로 
   변환하는 것임
 - 이 파일 데이터에 대한 무대 뒤의 수정은 텍스트 파일의 경우는 문제가 안 되지만, 
   JPEG 이나 EXE 파일과 같은 바이너리 데이터를 망치게 됨
   . 그런 파일을 읽고 쓸 때 바이너리 모드를 사용하도록 주의해야 함
 - 파일 객체를 다룰 때 with 키워드를 사용하는 것은 좋은 습관임
   . 혜택은 도중 예외가 발생하더라도 스위트가 종료될 때 파일이 올바르게 
     닫힌다는 것임
   . with 를 사용하는 것은 동등한 try-finally 블록을 쓰는 것에 비교해 
     훨씬 짧기도 함
  >>> with open('workfile') as f:
  ...     read_data = f.read()
  
  >>> # We can check that the file has been automatically closed.
  >>> f.closed
  True 
 - with 키워드를 사용하지 않으면, f.close() 를 호출해서 파일을 닫고 사용된 
   시스템 자원을 즉시 반납해야 함
   . 명시적으로 파일을 닫지 않으면, 파이썬의 가비지 수거기가 결국에는 객체를 
     파괴하고 여러분을 대신해서 파일을 닫게 되지만, 파일이 한동안 열린 상태로 
     남아있게 됨
   . 또 다른 위험은 다른 파이썬 구현들은 이 뒷정리를 서로 다른 시점에 수행한다는
     것임
 ※ 스위트(suite)
    . 복합문은 하나나 그 이상의 〈절’로 구성됩니다. 절은 헤더와 
     〈스위트(suite)〉로 구성됩니다. 특정 복합문의 절 헤더들은 
      모두 같은 들여쓰기 수준을 갖습니다. 각 절 헤더는 특별하게 
      식별되는 키워드로 시작하고 콜론으로 끝납니다. 스위트는 
      절에 의해 제어되는 문장들의 그룹입니다. 스위트는 헤더의 
      콜론 뒤에서 같은 줄에 세미콜론으로 분리된 하나나 그 이상의 
      단순문일 수 있습니다. 또는 그다음 줄에 들여쓰기 된 하나나 
      그 이상의 문장들일 수도 있습니다. 오직 후자의 형태만 중첩된 
      복합문을 포함할 수 있습니다
 
○ 파일 객체의 메소드
 - f.read(size)
   . size 가 생략되거나 음수면 파일의 내용 전체를 읽어서 돌려줌
   . 파일의 끝에 도달하면, f.read() 는 빈 문자열 ('') 을 돌려줌
 - f.readline()
   . 파일에서 한 줄을 읽으며, 개행 문자 (\n)는 문자열의 끝에 보존되고, 
     파일이 개행문자로 끝나지 않는 때에만 파일의 마지막 줄에서만 생략됨
   . f.readline() 가 빈 문자열을 돌려주면, 파일의 끝에 도달한 것이지만, 
     빈 줄은 '\n', 즉 하나의 개행문자만을 포함하는 문자열로 표현됨    
 - 파일에서 줄들을 읽으려면, 파일 객체에 대해 루핑할 수 있음
   . 이것은 메모리 효율적이고, 빠르며 간단한 코드로 이어짐
  >>> f = open('C:/Data/Device/JobData/edge-manager/config/config.yml')
  >>> for line in f:
  	print(line, end='')
 - 파일의 모든 줄을 리스트로 읽어 들이려면 list(f)나 f.readlines()를 쓸 수 있음
 - f.tell()
   . 파일의 현재 위치를 가리키는 정수를 돌려주는데, 바이너리 모드의 경우 파일의 
     처음부터의 바이트 수로 표현되고 텍스트 모드의 경우는 불투명한 숫자임
 - f.seek(offset, whence)
   . 위치는 기준점에 offset 을 더해서 계산됨
   . 기준점은 whence 인자로 선택합니다. 
   . whence 값이 0이면 파일의 처음부터 측정하고, 
   . 1이면 현재 파일 위치를 사용하고, 
   . 2 는 파일의 끝을 기준점으로 사용함
   . whence 는 생략될 수 있고, 기본값은 0이라서 파일의 처음을 기준점으로 사용함



○ json 구조적인 데이터 저장하기
 - int() 같은 함수로 전달해야만 하는데, '123' 같은 문자열을 받고 숫자 값 123을
   돌려줌
 - 파이썬은 JSON (JavaScript Object Notation)이라는 널리 쓰이는 데이터 교환 
   형식을 사용할 수 있게 함
   . json 이라는 표준 모듈은 파이썬 데이터 계층을 받아서 문자열 표현으로 바꿔줌
   . 이 절차를 직렬화 (serializing) 라고 부름
   . 문자열 표현으로 부터 데이터를 재구성하는 것은 역 직렬화 (deserializing) 
     라고 부름
 - 객체 x 가 있을 때, 간단한 한 줄의 코드로 그것의 JSON 문자열 표현을 볼 수 있음
  >>> import json
  >>> json.dumps([1, 'simple', 'list'])
  '[1, "simple", "list"]'
 - dump()라는 dumps() 함수의 변종은 객체를 텍스트 파일로 직렬화함
   . 그래서 f 가 쓰기를 위해 열린 텍스트 파일이면, 이렇게 할 수 있음
  >>> json.dump(x, f)  
 - 객체를 다시 디코드하려면, f가 읽기를 위해 열린 텍스트 파일 객체일 때
  >>> x = json.load(f)
 - 이 간단한 직렬화 테크닉이 리스트와 딕셔너리를 다룰 수 있지만, 임의의 클래스 
   인스턴스를 JSON 으로 직렬화하기 위해서는 약간의 수고가 더 필요함
 
 
○ 문법 에러
 - 문법 에러는, 파싱 에러라고도 알려져 있음
  >>> while True print('Hello world')
    File "<stdin>", line 1
      while True print('Hello world')
                     ^
  SyntaxError: invalid syntax
 - 에러는 화살표 앞에 오는 토큰이 원인임 (또는 적어도 그곳에서 감지되었음)
 - 이 예에서, 에러는 함수 print() 에서 감지되었는데, 그 앞에 콜론 (':') 이 
   빠져있기 때문임
 
○ 예외
 - 실행 중에 감지되는 에러들을 예외라고 함 
 - 예외 형으로 인쇄된 문자열은 발생한 내장 예외의 이름
 - 표준 예외 이름은 내장 식별자임 (예약 키워드가 아님)
 
○ 예외 처리하기
 - 선택한 예외를 처리하는 프로그램을 만드는 것이 가능하며, 다음 예를 보면, 
   올바른 정수가 입력될 때까지 사용자에게 입력을 요청하지만, 사용자가 프로그램을 
   인터럽트 하는 것을 허용함 (Control-C 나 그 외에 운영 체제가 지원하는 것을 
   사용해서)
 - 사용자가 만든 인터럽트는 KeyboardInterrupt 예외를 일으키는 형태로 나타남
  >>> while True:
  ...     try:
  ...         x = int(input("Please enter a number: "))
  ...         break
  ...     except ValueError:
  ...         print("Oops!  That was no valid number.  Try again...")
  ...
 - 먼저, try 절 (try 와 except 사이의 문장들) 이 실행됨
 - 예외가 발생하지 않으면, except 절 을 건너뛰고 try 문의 실행은 종료됨
 - try 절을 실행하는 동안 예외가 발생하면, 절의 남은 부분들을 건너뛰며, 
   그런 다음 형이 except 키워드 뒤에 오는 예외 이름과 매치되면, 그 except 절이 
   실행되고, 그런 다음 실행은 try 문 뒤로 이어짐
 - except 절에 있는 예외 이름들과 매치되지 않는 예외가 발생하면, 외부에 있는 
   try 문으로 전달되며, 처리기가 발견되지 않으면, 처리되지 않은 예외이고 
   위에서 보인 것과 같은 메시지를 출력하면서 실행이 멈춤
 - except 절은 괄호가 있는 튜플로 여러 개의 예외를 지정할 수 있습니다, 예를 들어:
  ... except (RuntimeError, TypeError, NameError):
  ...     pass   
 - except 절에 있는 클래스는 예외와 같은 클래스이거나 베이스 클래스일 때 매치됨
   . 자식 클래스를 나열한 except 절은 베이스 클래스와 매치되지 않음
  class B(Exception):
      pass
  
  class C(B):
      pass
  
  class D(C):
      pass
  
  for cls in [B, C, D]:
      try:
          raise cls()
      except D:
          print("D")
      except C:
          print("C")
      except B:
          print("B")      
 - except 절이 뒤집히면 (except B 가 처음에 오도록), B, B, B를 인쇄하게 됨에 
   주의해야 하며, 처음으로 매치되는 절이 실행됨
 - 마지막 except 절은 예외 이름을 생략할 수 있는데, 와일드카드 역할을 함
   . 이것을 사용할 때는 극도의 주의를 필요로 함
   . 이런 식으로 실제 프로그래밍 에러를 가리기 쉽기 때문임
   . 에러 메시지를 인쇄한 후에 예외를 다시 일으키는데 사용될 수도 있음
     (호출자도 예외를 처리할 수 있도록):   
  import sys
  
  try:
      f = open('myfile.txt')
      s = f.readline()
      i = int(s.strip())
  except OSError as err:
      print("OS error: {0}".format(err))
  except ValueError:
      print("Could not convert data to an integer.")
  except:
      print("Unexpected error:", sys.exc_info()[0])
      raise   

 - try … except 문은 선택적인 else 절 을 갖는데, 
   있다면 모든 except 절 뒤에와야 함
   . try 절이 예외를 일으키지 않을 때 실행되어야만 하는 코드에 유용함
   . 예를 들어:
  for arg in sys.argv[1:]:
      try:
          f = open(arg, 'r')
      except OSError:
          print('cannot open', arg)
      else:
          print(arg, 'has', len(f.readlines()), 'lines')
          f.close()  

 - else 절의 사용이 try 절에 코드를 추가하는 것보다 좋은데, try … except 문에 
   의해 보호되고 있는 코드가 일으키지 않은 예외를 우연히 잡게 되는 것을 방지하기
   때문임
 - except 절은 예외 이름 뒤에 변수를 지정할 수 있음
   . 변수는 인자들이 instance.args 에 저장된 예외 인스턴스에 연결됨
   . 편의를 위해, 예외 인스턴스는 __str__() 를 정의해서, 
     .args 를 참조하지 않고도 인자들을 직접 인쇄할 수 있음
  >>> try:
  ...     raise Exception('spam', 'eggs')
  ... except Exception as inst:
  ...     print(type(inst))    # the exception instance
  ...     print(inst.args)     # arguments stored in .args
  ...     print(inst)          # __str__ allows args to be printed directly,
  ...                          # but may be overridden in exception subclasses
  ...     x, y = inst.args     # unpack args
  ...     print('x =', x)
  ...     print('y =', y)
  ...     print(inst.__str__())
  ...
  <class 'Exception'>
  ('spam', 'eggs')
  ('spam', 'eggs')
  x = spam
  y = eggs   
  ('spam', 'eggs')

○ 예외 일으키기
  >>> raise NameError('HiThere')
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  NameError: HiThere
  
 - 예외 인스턴스이거나 예외 클래스 (Exception를 계승하는 클래스) 이어야 함
 - 예외 클래스가 전달되면, 묵시적으로 인자없이 생성자를 호출해서 인스턴스를 만듬

  raise ValueError  # shorthand for 'raise ValueError()' 

 - 만약 예외가 발생했는지는 알아야 하지만 처리하고 싶지는 않다면, 
   더 간단한 형태의 raise 문이 그 예외를 다시 일으킬 수 있게 함
  >>> try:
  ...     raise NameError('HiThere')
  ... except NameError:
  ...     print('An exception flew by!')
  ...     raise
  ...
  An exception flew by!
  Traceback (most recent call last):
    File "<stdin>", line 2, in <module>
  NameError: HiThere   

○ 사용자 정의 예외
 - 예외는 보통 직접적으로나 간접적으로 Exception 클래스를 계승함
  class Error(Exception):
      """Base class for exceptions in this module."""
      pass
  
  class InputError(Error):
      """Exception raised for errors in the input.
  
      Attributes:
          expression -- input expression in which the error occurred
          message -- explanation of the error
      """
      def __init__(self, expression, message):
          self.expression = expression
          self.message = message
  
  class TransitionError(Error):
      """Raised when an operation attempts a state transition that's not
      allowed.
  
      Attributes:
          previous -- state at beginning of transition
          next -- attempted new state
          message -- explanation of why the specific transition is not allowed
      """
  
      def __init__(self, previous, next, message):
          self.previous = previous
          self.next = next
          self.message = message 
 - 대부분의 예외는 표준 예외들의 이름들과 유사하게, 《Error》로 끝나는 
   이름으로 정의됨
 
○ 뒷정리 동작 정의하기
 - try 문은 또 다른 선택적 절을 가질 수 있는데 모든 상황에 실행되어야만 하는 
   뒷정리 동작을 정의하는 데 사용됨
  >>> try:
  ...     raise KeyboardInterrupt
  ... finally:
  ...     print('Goodbye, world!')
  ...
  Goodbye, world!
  KeyboardInterrupt
  Traceback (most recent call last):
    File "<stdin>", line 2, in <module>

 - try 절을 실행하는 동안 예외가 발생하면, except 절에서 예외를 처리할 수 있음
   . 예외가 except 절에서 처리되지 않으면, finally 절이 실행된 후 예외가 다시 
     발생함
 - except나 else 절 실행 중에 예외가 발생할 수 있음
   다시, finally 절이 실행된 후 예외가 다시 발생함

  >>> try:
  ...     raise KeyboardInterrupt
  ... except KeyboardInterrupt:
  ...     raise NameError
  ... finally:
  ...     print('finally')
  ...
  finally
  Traceback (most recent call last):
    File "<stdin>", line 2, in <module>
  KeyboardInterrupt
  
  During handling of the above exception, another exception occurred:
  
  Traceback (most recent call last):
    File "<stdin>", line 4, in <module>
  NameError

 - try 문이 break, continue 또는 return 문에 도달하면, 
   finally 절은 break, continue 또는 return 문 실행 직전에 실행됨
 - finally 절에 return 문이 포함되면, 반환 값은 try 절의 return 문이 주는 
   값이 아니라, finally 절의 return 문이 주는 값이 됨
  >>> def divide(x, y):
  ...     try:
  ...         result = x / y
  ...     except ZeroDivisionError:
  ...         print("division by zero!")
  ...     else:
  ...         print("result is", result)
  ...     finally:
  ...         print("executing finally clause")
  ...
  >>> divide(2, 1)
  result is 2.0
  executing finally clause
  >>> divide(2, 0)
  division by zero!
  executing finally clause
  >>> divide("2", "1")
  executing finally clause
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<stdin>", line 3, in divide
  TypeError: unsupported operand type(s) for /: 'str' and 'str' 
  
 - finally 절은 모든 경우에 실행됨
   . 두 문자열을 나눠서 발생한 TypeError는 except 절에 의해 처리되지 않고 
     finally 절이 실행된 후에 다시 일어남

○ 미리 정의된 뒷정리 동작들
 - 어떤 객체들은 객체가 더 필요 없을 때 개입하는 표준 뒷정리 동작을 정의함
  for line in open("myfile.txt"):
      print(line, end="")
 - with문은 파일과 같은 객체들이 즉시 올바르게 뒷정리되도록 보장하는 방법을 제공
  with open("myfile.txt") as f:
      for line in f:
          print(line, end="")
 - 문장이 실행된 후에, 줄을 처리하는 데 문제가 발생하더라도, 파일 f는 항상 닫힘
 - 파일과 같이, 미리 정의된 뒷정리 동작들을 제공하는 객체들은 그들의 설명서에서 
   이 사실을 설명함
 
○ 클래스
 - 파이썬 클래스는 객체 지향형 프로그래밍의 모든 표준 기능들을 제공함
   클래스 상속 메커니즘은 다중 베이스 클래스를 허락하고, 자식 클래스는 베이스 
   클래스나 클래스들의 어떤 메서드도 재정의할 수 있으며, 메서드는 같은 이름의 
   베이스 클래스의 메서드를 호출할 수 있음
 - 클래스 멤버들은 (데이터 멤버를 포함해서) public하고, 모든 맴버 함수들은 
   virtual 임
 - 내장형도 사용자가 확장하기 위해 베이스 클래스로 사용할 수 있음
 - 특별한 문법을 갖는 대부분의 내장 연산자들은 (산술 연산자, 서브스크립팅, 등등)
   클래스 인스턴스에 대해 새로 정의될 수 있음
  
○ 파이썬 스코프와 이름 공간
 - 이름 공간은 이름에서 객체로 가는 매핑임
 - 대부분의 이름 공간은 현재 파이썬 딕셔너리로 구현되어 있음
   . 보통 다른 식으로는 알아차릴 수 없고 (성능은 예외), 앞으로는 바뀔 수 있음
 - 어트리뷰트라는 단어를 점 뒤에 오는 모든 이름에 사용함
   . 예를 들어, 표현식 z.real에서, real는 객체 z의 어트리뷰트이며, 
   . 엄밀하게 말해서, 모듈에 있는 이름들에 대한 참조는 어트리뷰트 참조임
   . 표현식 modname.funcname에서, modname은 모듈 객체고 funcname는 그것의
     어트리뷰트임
 - 어트리뷰트는 읽기 전용이거나 쓰기 가능할 수 있으며, 
   후자의 경우, 어트리뷰트에 대한 대입이 가능함
   . 모듈 어트리뷰트는 쓰기 가능하며,  modname.the_answer = 42 라고 쓸 수 있음
   . 쓰기 가능한 어트리뷰트는 del문으로 삭제할 수도 있음
   . 예를 들어, del modname.the_answer는 modname라는 이름의 객체에서 
     어트리뷰트 the_answer 를 제거함
 - 이름 공간들은 서로 다른 순간에 만들어지고 서로 다른 수명을 갖음
   . 내장 이름들을 담는 이름 공간은 파이썬 인터프리터가 시작할 때 만들어지고 
     영원히 지워지지 않음
   . 모듈의 전역 이름 공간은 모듈 정의를 읽는 동안 만들어짐
   . 보통, 모듈 이름 공간은 인터프리터가 끝날 때까지 남음
   . 인터프리터의 최상위 호출 때문에 실행되는, 스크립트 파일이나 대화형으로 
     읽히는, 문장들은 __main__ 이라고 불리는 모듈 일부로 여겨져서 그들 자신의 
     이름 공간을 갖음
     (내장 이름들 또한 모듈에 속하는데 이것을 builtins 라 부름)
 - 함수의 지역 이름 공간은 함수가 호출될 때 만들어지고, 함수가 복귀하거나 
   함수 내에서 처리되지 않는 예외를 일으킬 때 삭제됨
 - 스코프는 이름 공간을 직접 액세스할 수 있는 파이썬 프로그램의 텍스트적인 영역
 - 스코프가 정적으로 결정됨에도 불구하고, 동적으로 사용됨
 - 실행 중 어느 시점에서건, 이름 공간을 직접 액세스 가능한, 적어도 세 개의 
   중첩된 스코프가 있음
   . 가장 먼저 검색되는, 가장 내부의 스코프는 지역 이름들을 포함함
   . 가장 가까이서 둘러싸는 스코프로부터 검색이 시작되며, 
     비 지역(non-local)이지만 비 전역(non-global) 이름들을 포함 
   . 마지막 직전의 스코프는 현재 모듈의 전역 이름들을 포함함
   . (가장 나중에 검색되는) 가장 외부의 스코프는 내장 이름들을 포함하고 있는 
     이름 공간임
 - 이름을 global로 선언하면, 모든 참조와 대입은 모듈의 전역 이름들을 포함하는 
   중간 스코프로 바로 감
 - 가장 내부의 스코프 바깥에서 발견되는 변수들을 재연결하려면, nonlocal 키워드를
   사용할 수 있음
   . nonlocal로 선언되지 않으면, 그 변수들은 읽기 전용임
   . 그런 변수에 쓰려고 하면 단순히 가장 내부의 스코프에 새 지역 변수를 만들게 
     되어, 같은 이름의 바깥 변수를 바꾸지 않고 남겨둠
 - 보통, 지역 스코프는 현재 함수의 지역 이름들을 (텍스트 적으로) 참조함
   . 함수 바깥에서, 지역 스코프는 전역 스코프와 같은 이름 공간을 참조함
   . 모듈의 이름 공간. 클래스 정의들은 지역 스코프에 또 하나의 이름 공간을
     배치함
 - 파이썬의 특별한 특징은 global이나 nonlocal문이 없을 때 이름에 대입하면 
   항상 가장 내부의 스코프로 간다는 것임
   . 대입은 데이터를 복사하지 않으며, 이름을 단지 객체에 연결할 뿐임
   . 삭제도 마찬가지이며, 문장 del x 는 지역 스코프가 참조하는 이름 공간에서 
     x 의 연결을 제거함
   . 사실, 새 이름을 소개하는 모든 연산은 지역 스코프를 사용함
   . 특히, import문과 함수 정의는 모듈이나 함수 이름을 지역 스코프에 연결함
 - global문은 특정 변수가 전역 스코프에 있으며 그곳에 재연결되어야 함을 가리킬
   때 사용될 수 있음
 - nonlocal문은 특정 변수가 둘러싸는 스코프에 있으며 그곳에 재연결되어야 함을 
   가리킴

○ 스코프와 이름 공간 예
  def scope_test():
      def do_local():
          spam = "local spam"
  
      def do_nonlocal():
          nonlocal spam
          spam = "nonlocal spam"
  
      def do_global():
          global spam
          spam = "global spam"
  
      spam = "test spam"
      do_local()
      print("After local assignment:", spam)
      do_nonlocal()
      print("After nonlocal assignment:", spam)
      do_global()
      print("After global assignment:", spam)
  
  scope_test()
  print("In global scope:", spam) 

  After local assignment: test spam
  After nonlocal assignment: nonlocal spam
  After global assignment: nonlocal spam
  In global scope: global spam
  
 - 지역 대입이 (이것이 기본임) scope_test 의 spam 연결을 바꾸지 않는지에 유의
 - nonlocal 대입은 scope_test 의 spam 연결을 바꾸고,
 - global 대입은 모듈 수준의 연결을 바꿈
 - global 대입 전에는 spam의 연결이 없다는 것도 볼 수 있음
 
○ 클래스 정의 문법
  class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
 - 함수 정의(def 문)처럼, 클래스 정의는 어떤 효과가 생기기 위해서는 먼저 
   실행되어야 함
   . 상상컨대 클래스 정의를 if 문의 분기나 함수 내부에 놓을 수 있음
 - 클래스 정의에 진입할 때, 새 이름 공간이 만들어지고 지역 스코프로 사용됨
   그래서, 모든 지역 변수들로의 대입은 이 새 이름 공간으로 감
   . 특히, 함수 정의는 새 함수의 이름을 이곳에 연결함
 - 클래스 정의가 (끝을 통해) 정상적으로 끝날 때, 클래스 객체가 만들어짐
   이것은 기본적으로 클래스 정의 때문에 만들어진 이름 공간의 내용물들을 감싸는 
   싸개임
   . 다음 섹션에서 클래스 객체에 대해 더 배우게 됨
   . 원래의 지역 스코프가 (클래스 정의에 들어가기 직전에 유효하던 것) 다시 
     사용되고, 클래스 객체는 클래스 정의 헤더에서 주어진 클래스 이름 
     (예에서 ClassName) 으로 여기에 연결됨

○ 클래스 객체
 - 클래스 객체는 두 종류의 연산을 지원함
   . 어트리뷰트 참조와 인스턴스 만들기
 - 올바른 어트리뷰트 이름은 클래스 객체가 만들어질 때 클래스의 이름 공간에 
   있던 모든 이름임
  class MyClass:
      """A simple example class"""
      i = 12345
  
      def f(self):
          return 'hello world'   

 - __doc__ 도 역시 올바른 어트리뷰트고, 클래스에 속하는 독스트링을 돌려줌
   . "A simple example class"
 - 클래스 인스턴스 만들기는 함수 표기법을 사용함
   . 클래스 객체가 클래스의 새 인스턴스를 돌려주는 매개변수 없는 함수인 체함
   . x = MyClass() 는 클래스의 새 인스턴스를 만들고 이 객체를 지역변수 x에 대입함
 - 인스턴스 만들기 연산(클래스 객체 호출하기)은 빈 객체를 만듬
   . 많은 클래스는 특정한 초기 상태로 커스터마이즈된 인스턴스로 객체를 만드는 
     것을 좋아함
   . 그래서 클래스는 이런 식으로 __init__()라는 이름의 특수 메서드를 
     정의할 수 있음
  def __init__(self):
    self.data = []
 - 클래스가 __init__() 메서드를 정의할 때, 클래스 인스턴스 만들기는 새로 만들어진
   클래스 인스턴스에 대해 자동으로 __init__() 를 호출함
 - 클래스 인스턴스 만들기 연산자로 주어진 인자들은 __init__() 로 전달됨

○ 인스턴스 객체
 - 인스턴스 객체가 이해하는 오직 한가지 연산은 어트리뷰트 참조임
   . 두 가지 종류의 올바른 어트리뷰트 이름이 있음. 데이터 어트리뷰트와 메서드.
 - 데이터 어트리뷰트는 선언될 필요 없음
   . 지역 변수처럼, 처음 대입될 때 태어남
   . 예를 들어, x 가 위에서 만들어진 MyClass 의 인스턴스면, 다음과 같은 
     코드 조각은 트레이스 없이 값 16 을 인쇄함

  >>> x.counter = 1
  >>> while x.counter < 10:
  ...    x.counter = x.counter * 2
  
  >>> print(x.counter)
  >>> del x.counter

 - 메서드는 객체에 《속하는》 함수임
 - (파이썬에서, 메서드 라는 용어는 클래스 인스턴스에만 사용되지 않으며,
   다른 객체 형들도 메서드를 가질 수 있음
   . 예를 들어, 리스트 객체는 append, insert, remove, sort 등과 같은 메서드들을
     갖음
   . 하지만, 앞으로의 논의에서, 명시적으로 언급하지 않는 한, 메서드라는 용어를 
     클래스 인스턴스 객체의 메서드에만 사용할 것임
 - 함수 객체인 클래스의 모든 어트리뷰트들은 상응하는 인스턴스의 메서드들을 
   정의함
 - 우리의 예제에서, x.f 는 올바른 메서드 참조인데, MyClass.f가 함수이기 때문임
 - x.f는 MyClass.f와 같은 것이 아니며, 이것은 함수 객체가 아니라 메서드 객체임

○ 메서드 객체
 - f()의 함수 정의가 인자를 지정했음에도 불구하고, 위에서 x.f()는 인자 없이 
   호출된 것을 알아챘을 것임
   . 인자는 어떻게 된 걸까? 확실히 파이썬은 인자를 필요로 하는 함수를 인자 없이 
     호출하면 예외를 일으키는데, 인자가 실제로는 사용되지 않는다 해도…    
 - 메서드의 특별함은 인스턴스 객체가 함수의 첫 번째 인자로 전달된다는 것임
   . 우리 예에서, 호출 x.f()은 정확히 MyClass.f(x)와 동등함
 - n 개의 인자들의 목록으로 메서드를 호출하는 것은, 첫 번째 인자 앞에 메서드의
   인스턴스 객체를 삽입해서 만든 인자 목록으로 상응하는 함수를 호출하는 것과 
   동등함
 - 데이터 어트리뷰트가 아닌 인스턴스 어트리뷰트를 참조하면, 
   그것의 클래스가 검색됨
 - 만약 그 이름이 함수 객체인 올바른 클래스 어트리뷰트면, 인스턴스 객체와 
   방금 발견된 함수 객체를 (가리키는 포인터들을) 추상 객체에 함께 묶어서 
   메서드 객체를 만듬
 - 메서드 객체가 인자 목록으로 호출되면, 인스턴스 객체와 인자 목록으로부터 
   새 인자 목록이 구성된 후, 함수 객체를 이 새 인자 목록으로 호출함

○ 클래스와 인스턴스 변수
 - 인스턴스 변수는 인스턴스별 데이터를 위한 것이고 클래스 변수는 그 클래스의 
   모든 인스턴스에서 공유되는 어트리뷰트와 메서드를 위한 것임
  class Dog:
      kind = 'canine'         # class variable shared by all instances
      def __init__(self, name):
          self.name = name    # instance variable unique to each instance      

  >>> d = Dog('Fido')
  >>> e = Dog('Buddy')
  >>> d.kind                  # shared by all dogs
  'canine'
  >>> e.kind                  # shared by all dogs
  'canine'
  >>> d.name                  # unique to d
  'Fido'
  >>> e.name                  # unique to e
  'Buddy'

○ 기타 주의사항들
 - 인스턴스와 클래스 모두에서 같은 어트리뷰트 이름이 등장하면, 
   어트리뷰트 조회는 인스턴스를 우선함
  >>> class Warehouse:
  	purpose = 'storage'
  	region = 'west'        
  >>> w1 = Warehouse()
  >>> w2 = Warehouse()
  >>> print(w1.purpose, w1.region)
  storage west
  >>> w1.region = 'east'
  >>> print(w1.purpose, w1.region)
  storage east
  >>> print(w2.purpose, w2.region)
  storage west

 - 데이터 어트리뷰트는 메서드 뿐만 아니라 객체의 일반적인 사용자에 의해서 
   참조될 수도 있음
   . 달리 표현하면, 클래스는 순수하게 추상적인 데이터형을 구현하는데 사용될 수
     없음
   . 사실, 파이썬에서는 데이터 은닉을 강제할 방법이 없음 - 모두 관례에 의존함
 - 사용자는 데이터 어트리뷰트를 건드려서 메서드들에 의해 유지되는 불변성들을 
   망가뜨릴 수 있음
   . 사용자는 이름 충돌을 피하는 한 메서드들의 유효성을 손상하지 않고도 
     그들 자신의 데이터 어트리뷰트를 인스턴스 객체에 추가할 수도 있음에 유의
   .  다시 한번, 명명 규칙은 여러 골칫거리를 피할 수 있게 함
 - 종종, 메서드의 첫 번째 인자는 self라고 불리며, 이것은 관례일 뿐임
   . 이름 self는 파이썬에서 아무런 특별한 의미를 갖지 않음
   . 하지만, 이 규칙을 따르지 않을 때 여러분의 코드가 다른 파이썬 프로그래머들이
     읽기에 불편하고, 클래스 브라우저 프로그램도 이런 규칙에 의존하도록 
     작성되었다고 상상할 수 있음에 유의해야 함
 - 함수 정의가 클래스 정의에 텍스트적으로 둘러싸일 필요는 없음
   . 함수 객체를 클래스의 지역 변수로 대입하는 것 역시 가능

  # Function defined outside the class
  def f1(self, x, y):
      return min(x, x+y)
  
  class C:
      f = f1
        def g(self):
          return 'hello world'
        h = g   

 - 메서드는 self인자의 메서드 어트리뷰트를 사용해서 다른 메서드를 호출할 수 있음
  class Bag:
      def __init__(self):
          self.data = []
  
      def add(self, x):
          self.data.append(x)
  
      def addtwice(self, x):
          self.add(x)
          self.add(x)   
 - 메서드는 일반 함수들과 마찬가지로 전역 이름을 참조할 수 있음
   . 메서드에 결합한 전역 스코프는 그것의 정의를 포함하는 모듈
   . 클래스는 결코 전역 스코프로 사용되지 않음
 - 각 값은 객체고, 그러므로 클래스를 갖으며, object.__class__ 에 저장되어 있음

  >>> i = 1
  >>> i.__class__
  <class 'int'> 

  >>> (1).__class__
  <class 'int'>

○ 상속
 - 파생 클래스 정의의 문법
  class DerivedClassName(BaseClassName):
      <statement-1>
      .
      .
      .
      <statement-N>   

 - 베이스 클래스 이름의 자리에 다른 임의의 표현식도 허락됨
   . 예를 들어, 베이스 클래스가 다른 모듈에 정의되어 있을 때 유용함
   . class DerivedClassName(modname.BaseClassName): 
 - 파생 클래스는 베이스 클래스의 메서드들을 재정의할 수 있음
 - 베이스 클래스에 정의된 다른 메서드를 호출하는 베이스 클래스의 메서드는 
   재정의된 파생 클래스의 메서드를 호출하게 됨
   . C++ 프로그래머를 위한 표현으로: 파이썬의 모든 메서드는 실질적으로 
     virtual임
 - 같은 이름의 베이스 클래스 메서드를 단순히 갈아치우기보다 사실은 확장하고 
   싶을 때, 베이스 클래스의 메서드를 직접 호출하는 간단한 방법이 있음
   . 단지 BaseClassName.methodname(self, arguments)를 호출하면 됨
   . 이것은 베이스 클래스가 전역 스코프에서 BaseClassName으로 액세스 될 수 있을
     때만 동작함
 - 인스턴스의 형을 검사하려면 isinstance() 를 사용함
   . isinstance(obj, int)는 obj.__class__ 가 int 거나 int에서 파생된 클래스인 
     경우만 True가 됨
  >>> isinstance(1, int)
  True
  >>> isinstance(i, int)
  True
  >>> class DerivedInt(int):
  ...     pass
  ...
  >>> va = DerivedInt()
  >>> isinstance(va, int)
  True
  >>>  
 - 클래스 상속을 검사하려면 issubclass()를 사용함
   . issubclass(bool, int)는 True 인데, bool이 int의 서브 클래스이기 때문
   . 하지만, issubclass(float, int)는 False인데, float는 int의 서브 클래스가 
     아니기 때문임

○ 다중 상속
 - 여러 개의 베이스 클래스를 갖는 클래스 정의는 이런 식
  class DerivedClassName(Base1, Base2, Base3):
      <statement-1>
      .
      .
      .
      <statement-N> 
 - 메서드 결정 순서는 super()로의 협력적인 호출을 지원하기 위해 동적으로 변경됨
   . 이 접근법은 몇몇 다른 다중 상속 언어들에서 call-next-method라고 알려져 
     있고, 단일 상속 언어들에서 발견되는 super호출보다 더 강력함

○ 비공개 변수
 - 객체 내부에서만 액세스할 수 있는 《비공개》 인스턴스 변수는 파이썬에 존재하지
   않음
 - 하지만, 대부분의 파이썬 코드에서 따르고 있는 규약이 있음
   . 밑줄로 시작하는 이름은 (예를 들어, _spam) API의 공개적이지 않은 부분으로 
     취급되어야 함
   . 그것이 함수, 메서드, 데이터 멤버중 무엇이건 간에
   . 구현 상세이고 통보 없이 변경되는 대상으로 취급되어야 함
 - 이름 뒤섞기(name mangling)라고 불리는 메커니즘에 대한 제한된 지원이 있음
   . __spam 형태의 (최소 두 개의 밑줄로 시작하고, 최대 한 개의 밑줄로 끝남) 
     모든 식별자는 _classname__spam로 텍스트 적으로 치환되는데, 
     classname은 현재 클래스 이름에서 앞에 오는 밑줄을 제거한 것임
   . 이 뒤섞기는 클래스 정의에 등장하는 이상, 식별자의 문법적 위치와 무관하게 
     수행됨

  class Mapping:
      def __init__(self, iterable):
          self.items_list = []
          self.__update(iterable)
  
      def update(self, iterable):
          for item in iterable:
              self.items_list.append(item)
  
      __update = update   # private copy of original update() method
  
  class MappingSubclass(Mapping):
      def update(self, keys, values):
          # provides new signature for update()
          # but does not break __init__()
          for item in zip(keys, values):
              self.items_list.append(item) 
  
      __update = update   # private copy of original update() method
  
 - 위의 예는 MappingSubclass가 __update 식별자를 도입하더라도 작동함
   . Mapping 클래스에서는 _Mapping__update로 MappingSubclass 클래스에서는 
     _MappingSubclass__update로 각각 대체 되기 때문
 - exec()나 eval()로 전달된 코드는 호출하는 클래스의 클래스 이름을 현재 
   클래스로 여기지 않는다는 것에 주의해야 함
   . 이것은 global문의 효과와 유사한데, 효과가 함께 바이트-컴파일된 코드로 제한
   . 같은 제약이 __dict__ 를 직접 참조할 때뿐만 아니라, getattr(), setattr(), 
     delattr() 에도 적용됨
 
○ 잡동사니
 - 때로 몇몇 이름 붙은 데이터 항목들을 함께 묶어주는 파스칼의 《record》나 
   C의 《struct》와 유사한 데이터형을 갖는 것이 쓸모 있음
   . 빈 클래스 정의가 훌륭히 할 수 있는 일임
  class Employee:
      pass
  
  john = Employee()  # Create an empty employee record
  
  # Fill the fields of the record
  john.name = 'John Doe'
  john.dept = 'computer lab'
  john.salary = 1000 

 - 파일 객체로부터 데이터를 포맷하는 함수가 있을 때, 대신 문자열 버퍼에서 
   데이터를 읽는 메서드 read() 와 readline()을 제공하는 클래스를 정의한 후 
   인자로 전달할 수 있음
 - 인스턴스 메서드 객체도 어트리뷰트를 갖음
   . m.__self__ 는 메서드 m()과 결합한 인스턴스 객체이고, 
     m.__func__ 는 메서드에 상응하는 함수 객체임



○ 이터레이터
 - 대부분의 컨테이너 객체들을 for 문으로 루핑

  for element in [1, 2, 3]:
      print(element)
  for element in (1, 2, 3):
      print(element)
  for key in {'one':1, 'two':2}:
      print(key)
  for char in "123":
      print(char)
  for line in open("myfile.txt"):
      print(line, end='') 

 - 무대 뒤에서, for 문은 컨테이너 객체에 대해 iter() 를 호출함
 - 이 함수는 메서드 __next__()를 정의하는 이터레이터 객체를 돌려주는데, 
   이 메서드는 컨테이너의 요소들을 한 번에 하나씩 액세스함
 - 남은 요소가 없으면, __next__()는 StopIteration예외를 일으켜서 for 루프에 
   종료를 알림
 - next() 내장 함수를 사용해서 __next__() 메서드를 호출할 수 있음
  >>> s = 'abc'
  >>> it = iter(s)
  >>> it
  <str_iterator object at 0x000000000351BA00>
  >>> next(it)
  'a'
  >>> next(it)
  'b'
  >>> next(it)
  'c'
  >>> next(it)
  Traceback (most recent call last):
    File "<pyshell#34>", line 1, in <module>
      next(it)
  StopIteration
  
 - __next__() 메서드를 가진 객체를 돌려주는 __iter__() 메서드를 정의
   . 클래스가 __next__()를 정의하면, __iter__()는 그냥 self를 돌려줄 수 있음
  class Reverse:
      """Iterator for looping over a sequence backwards."""
      def __init__(self, data):
          self.data = data
          self.index = len(data)
  
      def __iter__(self):
          return self
  
      def __next__(self):
          if self.index == 0:
              raise StopIteration
          self.index = self.index - 1
          return self.data[self.index] 
  
  >>> rev = Reverse('spam')
  >>> iter(rev)
  <__main__.Reverse object at 0x00A1DB50>
  >>> for char in rev:
  ...     print(char)
  ...
  m
  a
  p
  s
  
○ 제너레이터
 - 제너레이터는 이터레이터를 만드는 간단하고 강력한 도구임
 - 일반적인 함수처럼 작성되지만 값을 돌려주고 싶을 때마다 yield 문을 사용함
 - 제너레이터에 next()가 호출될 때마다, 제너레이터는 떠난 곳에서 실행을 재개함
   . 모든 데이터 값들과 어떤 문장이 마지막으로 실행되었는지 기억함
  def reverse(data):
      for index in range(len(data)-1, -1, -1):
          yield data[index]  
  
  >>> for char in reverse('golf'):
  ...     print(char)
  ...
  f
  l
  o
  g  
 - 제너레이터가 간단한 이유는 __iter__()와 __next__()메서드가 저절로 
   만들어지기 때문임
 - 또 하나의 주요 기능은 지역 변수들과 실행 상태가 호출 간에 자동으로 보관된다는
   것임
   . 이것은 self.index 나 self.data 와 같은 인스턴스 변수를 사용하는 접근법에 
     비교해 함수를 쓰기 쉽고 명료하게 만듬
 - 제너레이터가 종료할 때 자동으로 StopIteration 을 일으킴

○ 제너레이터 표현식
 - 간단한 제너레이터는 리스트 컴프리헨션과 비슷하지만, 대괄호 대신 괄호를 
   사용하는 문법을 사용한 표현식으로 간결하게 코딩할 수 있음
   . 이 표현식들은 둘러싸는 함수가 제너레이터를 즉시 사용하는 상황을 위해 설계
     되었음
 - 제너레이터 표현식은 완전한 제너레이터 정의보다 간결하지만, 융통성은 떨어지고,
   비슷한 리스트 컴프리헨션보다 메모리를 덜 쓰는 경향이 있음
  >>> sum(i*i for i in range(10))                 # sum of squares
  285
  
  >>> xvec = [10, 20, 30]
  >>> yvec = [7, 5, 3]
  >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
  260
  
  >>> unique_words = set(word for line in page  for word in line.split())
  
  >>> valedictorian = max((student.gpa, student.name) for student in graduates)
  
  >>> data = 'golf'
  >>> list(data[i] for i in range(len(data)-1, -1, -1))
  ['f', 'l', 'o', 'g'] 



○ 모듈 객체의 __dict__  어트리뷰트
 - 모듈 객체는 __dict__ 라고 불리는 비밀스러운 읽기 전용 어트리뷰트를 갖는데, 
   모듈의 이름 공간을 구현하는데 사용하는 딕셔너리를 돌려줌
 - 이름 __dict__ 는 어트리뷰트 이지만 전역 이름은 아님
   . 명백하게, 이것을 사용하는 것은 이름 공간 구현의 추상화를 파괴하는 것이고, 
     사후 디버거와 같은 것들로만 제한되어야 함
   
○ 운영 체제 인터페이스
 - os 모듈은 운영 체제와 상호 작용하기 위한 수십 가지 함수들을 제공함
  >>> import os
  >>> os.getcwd()      # Return the current working directory
  'C:\\Python38'
  >>> os.chdir('/server/accesslogs')   # Change current working directory
  >>> os.system('mkdir today')   # Run the command mkdir in the system shell
  0   
 - from os import * 대신에 import os 스타일을 사용해야 함
   . 그래야 os.open()이 내장 open()을 가리는 것을 피할 수 있는데, 두 함수는 
     아주 다르게 동작함
 - os 와 같은 큰 모듈과 작업할 때, 내장 dir()과 help()함수는 대화형 도우미로 
   쓸모가 있음
  >>> import os
  >>> dir(os)
  <returns a list of all module functions>
  >>> help(os)
  <returns an extensive manual page created from the module's docstrings>   
 - 일상적인 파일과 디렉터리 관리 작업을 위해, shutil 모듈은 사용하기 쉬운 
   더 고수준의 인터페이스를 제공
  >>> import shutil
  >>> shutil.copyfile('data.db', 'archive.db')
  'archive.db'
  >>> shutil.move('/build/executables', 'installdir')
  'installdir'   
 
○ 파일 와일드카드
 - glob 모듈은 디렉터리 와일드카드 검색으로 파일 목록을 만드는 함수를 제공
  >>> import glob
  >>> glob.glob('*.py')
  ['primes.py', 'random.py', 'quote.py'] 

○ 명령행 인자
 - 일반적인 유틸리티 스크립트는 종종 명령행 인자를 처리해야 할 필요가 있음
   . 이 인자들은 sys 모듈의 argv 어트리뷰트에 리스트로 저장됨
   . 예를 들어,  명령행에서 python demo.py one two three 를 실행하면 다음과 
     같은 결과가  출력됨
  >>> import sys
  >>> print(sys.argv)
  ['demo.py', 'one', 'two', 'three']
 - argparse 모듈은 명령 줄 인자를 처리하는 더 정교한 메커니즘을 제공함
   . 다음 스크립트는 하나 이상의 파일명과 선택적으로 표시할 줄 수를 추출함

  import argparse
  
  parser = argparse.ArgumentParser(prog = 'top',
      description = 'Show top lines from each file')
  parser.add_argument('filenames', nargs='+')
  parser.add_argument('-l', '--lines', type=int, default=10)
  args = parser.parse_args()
  print(args)
  
 - python top.py --lines=5 alpha.txt beta.txt
   를 사용하여 명령 줄에서 실행할 때, 스크립트는 
   args.lines를 5로, args.filenames를 ['alpha.txt', 'beta.txt']로 설정함

○ 에러 출력 리디렉션과 프로그램 종료
 - sys 모듈은 stdin, stdout, stderr 어트리뷰트도 갖고 있음
   . 가장 마지막 것은 stdout 이 리디렉트 되었을 때도 볼 수 있는 경고와 에러 
     메시지들을 출력하는데 쓸모가 있음
  >>> sys.stderr.write('Warning, log file not found starting a new one\n')
  Warning, log file not found starting a new one
 - 스크립트를 종료하는 가장 직접적인 방법은 sys.exit() 를 쓰는 것임

○ 문자열 패턴 매칭
 - re 모듈은 고급 문자열 처리를 위한 정규식 도구들을 제공함
   . 복잡한 매칭과 조작을 위해, 정규식은 간결하고 최적화된 솔루션을 제공함
  >>> import re
  >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
  ['foot', 'fell', 'fastest']
  >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
  'cat in the hat'
 - 단지 간단한 기능만 필요한 경우에는, 문자열 메서드들이 선호되는데 읽기 쉽고 
   디버깅이 쉽기 때문임
  >>> 'tea for too'.replace('too', 'two')
  'tea for two'  
  
○ 수학
 - math 모듈은 부동 소수점 연산을 위한 하부 C 라이브러리 함수들에 대한 액세스를 
   제공  
  >>> import math
  >>> math.cos(math.pi / 4)
  0.70710678118654757
  >>> math.log(1024, 2)
  10.0
 - random 모듈은 무작위 선택을 할 수 있는 도구들을 제공함
  >>> random.choice(['apple', 'pear', 'banana'])
  'apple'
  >>> random.sample(range(100), 10)   # sampling without replacement
  [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
  >>> random.random()    # random float
  0.17970987693706186
  >>> random.randrange(6)    # random integer chosen from range(6)
  4   
  
 - statistics 모듈은 수치 데이터의 기본적인 통계적 특성들을 (평균, 중간값, 
   분산, 등등) 계산함
  >>> import statistics
  >>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
  >>> statistics.mean(data)
  1.6071428571428572
  >>> statistics.median(data)
  1.25
  >>> statistics.variance(data)
  1.3720238095238095  
 - SciPy 프로젝트 <https://scipy.org>는 다른 수치 계산용 모듈들을 많이 갖고 있음
 
○ 인터넷 액세스
 - 인터넷을 액세스하고 인터넷 프로토콜들을 처리하는 많은 모듈이 있음
 - 가장 간단한 두 개는 URL에서 데이터를 읽어오는 urllib.request와 메일을 보내는
   smtplib 임
  >>> from urllib.request import urlopen
  >>> with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
  ...     for line in response:
  ...         line = line.decode('utf-8')  # Decoding the binary data to text.
  ...         if 'EST' in line or 'EDT' in line:  # look for Eastern Time
  ...             print(line)
  
  <BR>Nov. 25, 09:43:32 PM EST

  >>> import smtplib
  >>> server = smtplib.SMTP('localhost')
  >>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
  ... """To: jcaesar@example.org
  ... From: soothsayer@example.org
  ...
  ... Beware the Ides of March.
  ... """)
  >>> server.quit()  
 - 두 번째 예는 localhost 에서 메일 서버가 실행되고 있어야 함
 
○ 날짜와 시간
 - datetime 모듈은 날짜와 시간을 조작하는 클래스들을 제공하는데, 
   간단한 방법과 복잡한 방법 모두 제공함
   . 날짜와 시간 산술이 지원되지만, 구현의 초점은 출력 포매팅과 조작을 위해 
     효율적으로 멤버를 추출하는 데에 맞춰져 있음
   . 모듈은 시간대를 고려하는 객체들도 지원
  >>> # dates are easily constructed and formatted
  >>> from datetime import date
  >>> now = date.today()
  >>> now
  datetime.date(2003, 12, 2)
  >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
  '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'
  
  >>> # dates support calendar arithmetic
  >>> birthday = date(1964, 7, 31)
  >>> age = now - birthday
  >>> age.days
  14368  
  
○ 데이터 압축
 - 일반적인 데이터 보관 및 압축 형식들을 다음과 같은 모듈들이 직접 지원함
   . zlib, gzip, bz2, lzma, zipfile, tarfile
  >>> import zlib
  >>> s = b'witch which has which witches wrist watch'
  >>> len(s)
  41
  >>> t = zlib.compress(s)
  >>> len(t)
  37
  >>> zlib.decompress(t)
  b'witch which has which witches wrist watch'
  >>> zlib.crc32(s)
  226805979

○ 성능 측정
 - timeit 모듈은 적당한 성능 이점을 신속하게 보여줌
  >>> from timeit import Timer
  >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
  0.57535828626024577
  >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
  0.54962537085770791 
 - timeit의 정밀도와는 대조적으로, profile 과 pstats 모듈은 큰 블록의 코드에서
   시간 임계 섹션을 식별하기 위한 도구들을 제공함

○ 품질 관리
 - 고품질의 소프트웨어를 개발하는 한 가지 접근법은 개발되는 각 함수에 대한 
   테스트를 작성하고, 그것들을 개발 프로세스 중에 자주 실행하는 것임
 - doctest 모듈은 모듈을 훑어보고 프로그램의 독스트링들에 내장된 테스트들을 검사
   하는 도구를 제공함
 - 테스트 만들기는 평범한 호출을 그 결과와 함께 독스트링으로 복사해서 붙여넣기를
   하는 수준으로 간단해짐
 - 사용자에게 예제를 함께 제공해서 설명서를 개선하고, doctest 모듈이 설명서에서 
   코드가 여전히 사실인지 확인하도록 함
  def average(values):
      """Computes the arithmetic mean of a list of numbers.
  
      >>> print(average([20, 30, 70]))
      40.0
      """
      return sum(values) / len(values)
  
  import doctest
  doctest.testmod()   # automatically validate the embedded tests

 - unittest 모듈은 doctest 모듈만큼 쉬운 것은 아니지만, 더욱 포괄적인 테스트 
   집합을 별도의 파일로 관리할 수 있게 함
  
  import unittest
  
  class TestStatisticalFunctions(unittest.TestCase):
  
      def test_average(self):
          self.assertEqual(average([20, 30, 70]), 40.0)
          self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
          with self.assertRaises(ZeroDivisionError):
              average([])
          with self.assertRaises(TypeError):
              average(20, 30, 70)
  
  unittest.main()  # Calling from the command line invokes all tests   


○ 배터리가 포함됨
 - 파이썬은 《배터리가 포함됩니다》 철학을 갖고 있음
 - 이는 더 큰 패키지의 정교하고 강력한 기능을 통해 가장 잘 나타남
 - xmlrpc.client 와 xmlrpc.server 모듈은 원격 프로시저 호출을 구현하는 일을 
   거의 사소한 일로 만드는데, 모듈의 이름에도 불구하고, XML에 대한 직접적인 
   지식이나 처리가 필요하지 않음
 - email 패키지는 MIME 및 기타 RFC 2822 기반 메시지 문서를 포함하는 전자 메일 
   메시지를 관리하기 위한 라이브러리이며, 실제로 메시지를 보내고 받는 
   smtplib 와 poplib 와는 달리, email 패키지는 복잡한 메시지 구조 
   (첨부 파일 포함) 를 작성하거나 해독하고 인터넷 인코딩과 헤더 프로토콜을 
   구현하기 위한 완벽한 도구 상자를 가지고 있음
 - json 패키지는 널리 사용되는 데이터 교환 형식을 파싱하기위한 강력한 지원을 
   제공함
 - csv 모듈은 데이터베이스와 스프레드시트에서 일반적으로 지원되는 쉼표로 구분된
   값 형식으로 파일을 직접 읽고 쓸 수 있도록 지원함
 - XML 처리는 xml.etree.ElementTree, xml.dom 및 xml.sax 패키지에 의해 지원됨
 - 이러한 모듈과 패키지를 함께 사용하면 파이썬 응용 프로그램과 다른 도구 간의 
   데이터 교환이 크게 단순해짐
 - sqlite3 모듈은 SQLite 데이터베이스 라이브러리의 래퍼인데, 약간 비표준 SQL 
   구문을 사용하여 업데이트되고 액세스 될 수 있는 퍼시스턴트 데이터베이스를 제공
 - 국제화는 gettext, locale, 그리고 codecs 패키지를 포함한 많은 모듈에 의해 지원    
     
○ 출력 포매팅
 - reprlib 모듈은 크거나 깊게 중첩된 컨테이너의 축약된 디스플레이를 위해 
   커스터마이즈된 repr() 의 버전을 제공
  >>> import reprlib
  >>> reprlib.repr(set('supercalifragilisticexpialidocious'))
  "{'a', 'c', 'd', 'e', 'f', 'g', ...}"   
 - pprint 모듈은 인터프리터가 읽을 수 있는 방식으로 내장 객체나 사용자 정의 
   객체를 인쇄하는 것을 보다 정교하게 제어할 수 있게 함
 - 결과가 한 줄보다 길면 《예쁜 프린터》 줄 바꿈과 들여쓰기를 추가하여 데이터 
   구조를 보다 명확하게 나타냄
  >>> import pprint
  >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
  ...     'yellow'], 'blue']]]
  ...
  >>> pprint.pprint(t, width=30)
  [[[['black', 'cyan'],
     'white',
     ['green', 'red']],
    [['magenta', 'yellow'],
     'blue']]]   

 - textwrap 모듈은 텍스트의 문단을 주어진 화면 너비에 맞게 포맷함
  >>> import textwrap
  >>> doc = """The wrap() method is just like fill() except that it returns
  ... a list of strings instead of one big string with newlines to separate
  ... the wrapped lines."""
  ...
  >>> print(textwrap.fill(doc, width=40))
  The wrap() method is just like fill()
  except that it returns a list of strings
  instead of one big string with newlines
  to separate the wrapped lines. 
  
 - locale 모듈은 문화권 특정 데이터 포맷의 데이터베이스에 액세스함
 - locale의 format 함수의 grouping 어트리뷰트는 그룹 구분 기호로 숫자를 
   포매팅하는 직접적인 방법을 제공
  >>> import locale
  >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
  'English_United States.1252'
  >>> conv = locale.localeconv()          # get a mapping of conventions
  >>> x = 1234567.8
  >>> locale.format("%d", x, grouping=True)
  '1,234,567'
  >>> locale.format_string("%s%.*f", (conv['currency_symbol'],
  ...                      conv['frac_digits'], x), grouping=True)
  '$1,234,567.80'   
 
○ 템플릿
 - string 모듈은 다재다능한 Template 클래스를 포함하고 있는데, 최종 사용자가 
   편집하기에 적절한 단순한 문법을 갖고 있음
   . 따라서 사용자는 응용 프로그램을 변경하지 않고도 응용 프로그램을 
     커스터마이즈할 수 있음
 - 형식은 $와 유효한 파이썬 식별자 (영숫자와 밑줄)로 만들어진 자리표시자 이름을
   사용함
   . 중괄호를 사용하여 자리표시자를 둘러싸면 공백없이 영숫자가 
   뒤따르도록 할 수 있음
   . $$ 을 쓰면 하나의 이스케이프 된 $ 를 만듬

  >>> from string import Template
  >>> t = Template('${village}folk send $$10 to $cause.')
  >>> t.substitute(village='Nottingham', cause='the ditch fund')
  'Nottinghamfolk send $10 to the ditch fund.'

 - substitute() 메서드는 자리표시자가 딕셔너리나 키워드 인자로 제공되지 않을 때
   KeyError 를 일으킴
 - 메일 병합 스타일 응용 프로그램의 경우 사용자가 제공한 데이터가 불완전할 수 
   있으며 safe_substitute() 메서드가 더 적절할 수 있음
   . 데이터가 누락 된 경우 자리표시자를 변경하지 않음
  >>> t = Template('Return the $item to $owner.')
  >>> d = dict(item='unladen swallow')
  >>> t.substitute(d)
  Traceback (most recent call last):
    ...
  KeyError: 'owner'
  >>> t.safe_substitute(d)
  'Return the unladen swallow to $owner.'
  
 - Template 서브 클래스는 사용자 정의 구분자를 지정할 수 있음
   . 예를 들어  사진 브라우저를 위한 일괄 이름 바꾸기 유틸리티는 
     현재 날짜, 이미지 시퀀스 번호 또는 파일 형식과 같은 자리표시자에 
     백분율 기호를 사용하도록 선택할 수 있음
  >>> import time, os.path
  >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
  >>> class BatchRename(Template):
  ...     delimiter = '%'
  >>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
  Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f
  
  >>> t = BatchRename(fmt)
  >>> date = time.strftime('%d%b%y')
  >>> for i, filename in enumerate(photofiles):
  ...     base, ext = os.path.splitext(filename)
  ...     newname = t.substitute(d=date, n=i, f=ext)
  ...     print('{0} --> {1}'.format(filename, newname))
  
  img_1074.jpg --> Ashley_0.jpg
  img_1076.jpg --> Ashley_1.jpg
  img_1077.jpg --> Ashley_2.jpg   

○ 바이너리 데이터 레코드 배치 작업
 - struct 모듈은 가변 길이 바이너리 레코드 형식으로 작업하기 위한 pack()과 
   unpack() 함수를 제공함
 - 다음 예제는 zipfile 모듈을 사용하지 않고 ZIP 파일의 헤더 정보를 루핑하는 
   법을 보여줌
   . 팩 코드 "H" 와 "I" 는 각각 2바이트와 4바이트의스레딩 부호 없는 숫자를 
     나타내며, "<" 는 표준  크기이면서 리틀 엔디안 바이트 순서를 가짐을 나타냄

  import struct

  with open('myfile.zip', 'rb') as f:
      data = f.read()

  start = 0
  for i in range(3):                      # show the first 3 file headers
      start += 14
      fields = struct.unpack('<IIIHH', data[start:start+16])
      crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

      start += 16
      filename = data[start:start+filenamesize]
      start += filenamesize
      extra = data[start:start+extra_size]
      print(filename, hex(crc32), comp_size, uncomp_size)

      start += extra_size + comp_size     # skip to the next header         

○ 다중 스레딩
 - 스레딩은 차례로 종속되지 않는 작업을 분리하는 기술임
 - 다음 코드는 메인 프로그램이 계속 실행되는 동안 고수준 threading 모듈이 
   백그라운드에서 작업을 어떻게 수행할 수 있는지 보여줌
	import threading, zipfile

class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile
    
    def run(self):
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)

	background = AsyncZip('mydata.txt', 'myarchive.zip')
	background.start()
	print('The main program continues to run in foreground.')

	background.join()    # Wait for the background task to finish
	print('Main program waited until background was done.')

 - 다중 스레드 응용 프로그램의 가장 큰 문제점은 데이터 또는 다른 
   자원을 공유하는 스레드를 조정하는 것임
   . 이를 위해 threading 모듈은 록, 이벤트, 조건 변수 및 세마포어를 비롯한 
     많은 수의 동기화기본 요소를 제공함
 - 작업 조정에 대한 선호되는 접근 방식은 자원에 대한 모든 액세스를 
   단일 스레드에 집중시킨 다음, queue 모듈을 사용하여 해당 스레드에 
   다른 스레드의 요청을 제공하는 것임
   . 스레드 간 통신 및 조정을 위한 Queue 객체를 사용하는 응용 프로그램은 
     설계하기 쉽고, 읽기 쉽고, 신뢰성이 높음

○ 로깅
 - logging 모듈은 완전한 기능을 갖춘 유연한 로깅 시스템을 제공함
 - 가장 단순한 경우, 로그 메시지는 파일이나 sys.stderr 로 보내짐
	import logging
	logging.debug('Debugging information')
	logging.info('Informational message')
	logging.warning('Warning:config file %s not found', 'server.conf')
	logging.error('Error occurred')
	logging.critical('Critical error -- shutting down')
  . 그러면 다음과 같은 결과가 출력됨
	WARNING:root:Warning:config file server.conf not found
	ERROR:root:Error occurred
	CRITICAL:root:Critical error -- shutting down
 - 기본적으로 정보 및 디버깅 메시지는 표시되지 않고 출력은 표준 에러로 
   보내짐
 - 다른 출력 옵션에는 전자 메일, 데이터 그램, 소켓 또는 HTTP 서버를 
   통한 메시지 라우팅이 포함됨
 - 새로운 필터는 메시지 우선순위에 따라 다른 라우팅을 선택할 수 있음
   DEBUG, INFO, WARNING, ERROR , 그리고 CRITICAL
 - 로깅 시스템은 파이썬에서 직접 구성하거나, 응용 프로그램을 변경하지
   않고 사용자 정의 로깅을 위해 사용자가 편집할 수 있는 설정 파일에서
   로드 할 수 있음

○ 약한 참조
 - 파이썬은 자동 메모리 관리 (대부분 객체에 대한 참조 횟수 추적 및 순환을 
   제거하기 위한 가비지 수거)를 수행함
   . 메모리는 마지막 참조가 제거된 직후에 해제됨
 - 단지 그것들을 추적하는 것만으로도 그들을 영구적으로 만드는 참조를 만듬
   . weakref 모듈은 참조를 만들지 않고 객체를 추적할 수 있는  도구를 제공함
   . 객체가 더 필요하지 않으면 weakref 테이블에서 객체가 자동으로 제거되고 
     weakref 객체에 대한 콜백이 트리거됨
   . 일반적인 응용에는 만드는 데 비용이 많이 드는 개체 캐싱이 포함됨
	>>> import weakref, gc
	>>> class A:
	...     def __init__(self, value):
	...         self.value = value
	...     def __repr__(self):
	...         return str(self.value)
	...
	>>> a = A(10)                   # create a reference
	>>> d = weakref.WeakValueDictionary()
	>>> d['primary'] = a            # does not create a reference
	>>> d['primary']                # fetch the object if it is still alive
	10
	>>> del a                       # remove the one reference
	>>> gc.collect()                # run garbage collection right away
	0
	>>> d['primary']                # entry was automatically removed
	Traceback (most recent call last):
		File "<stdin>", line 1, in <module>
		  d['primary']                # entry was automatically removed
		File "C:/python38/lib/weakref.py", line 46, in __getitem__
		  o = self.data[key]()
	KeyError: 'primary'

○ 리스트 작업 도구
 - array 모듈은 array() 객체를 제공함
   . 이 객체는 등질적인 데이터만을 저장하고 보다 조밀하게 저장하는 리스트와 같음
 - 다음 예제는 파이썬 int 객체의 일반 리스트의 경우처럼 항목당 
   16바이트를 사용하는 대신에, 2바이트의 부호 없는 이진 숫자 
   (형 코드 "H")로 저장된 숫자 배열을 보여줌
	>>> from array import array
	>>> a = array('H', [4000, 10, 700, 22222])
	>>> sum(a)
	26932
	>>> a[1:3]
	array('H', [10, 700])
	
 - collections 모듈은 deque() 객체를 제공함
   . 이 객체는 왼쪽에서 더 빠르게 추가/팝하지만 중간에서의 조회는 더 느려진
     리스트와 같음
   . 이 객체는 대기열 및 넓이 우선 트리 검색을 구현하는 데 적합함
	>>> from collections import deque
	>>> d = deque(["task1", "task2", "task3"])
	>>> d.append("task4")
	>>> print("Handling", d.popleft())
	Handling task1

	unsearched = deque([starting_node])
	def breadth_first_search(unsearched):
		  node = unsearched.popleft()
		  for m in gen_moves(node):
		      if is_goal(m):
		          return m
		      unsearched.append(m)

 - 대안적 리스트 구현 외에도 라이브러리는 정렬된 리스트를 조작하는 
   함수들이 있는 bisect 모듈과 같은 다른 도구를 제공함
	>>> import bisect
	>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
	>>> bisect.insort(scores, (300, 'ruby'))
	>>> scores
	[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]

 - heapq 모듈은 일반 리스트를 기반으로 힙을 구현하는 함수를 제공함 
   . 가장 값이 작은 항목은 항상 위치 0에 유지됨
   . 이것은 가장 작은 요소에 반복적으로 액세스하지만, 전체 목록 정렬을 
     실행하지 않으려는 응용에 유용함
	>>> from heapq import heapify, heappop, heappush
	>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
	>>> heapify(data)                      # rearrange the list into heap order
	>>> heappush(data, -5)                 # add a new entry
	>>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
	[-5, 0, 1]

○ 10진 부동 소수점 산술
 - decimal 모듈은 10진 부동 소수점 산술을 위한 Decimal 데이터형을 제공함
 - 내장 float 이진 부동 소수점 구현과 비교할 때, 클래스는 특히 다음과 
   같은 것들에 유용함
   . 정확한 10진수 표현이 필요한 금융 응용 및 기타 용도,
   . 정밀도 제어,
   . 법적 또는 규제 요구 사항을 충족하는 반올림 제어,
   . 유효숫자 추적, 또는
   . 사용자가 결과가 손으로 계산한 것과 일치 할 것으로 기대하는 응용.
 - 예를 들어, 70센트 전화 요금에 대해 5% 세금을 계산하면, 
   십진 부동 소수점 및 이진 부동 소수점에 다른 결과가 나타남
   결과를 가장 가까운 센트로 반올림하면 차이가 드러남
	>>> from decimal import *
	>>> round(Decimal('0.70') * Decimal('1.05'), 2)
	Decimal('0.74')
	>>> round(.70 * 1.05, 2)
	0.73

 - 정확한 표현은 Decimal 클래스가 이진 부동 소수점에 적합하지 않은 모듈로 
   계산과 동등성 검사를 수행할 수 있도록 함
	>>> Decimal('1.00') % Decimal('.10')
	Decimal('0.00')
	>>> 1.00 % 0.10
	0.09999999999999995

	>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
	True
	>>> sum([0.1]*10) == 1.0
	False
 - decimal 모듈은 필요한 만큼의 정밀도로 산술을 제공함
	>>> getcontext().prec = 36
	>>> Decimal(1) / Decimal(7)
	Decimal('0.142857142857142857142857142857142857')

○ 가상 환경 및 패키지 소개
 - 가상 환경은 특정 버전 파이썬 설치와 여러 추가 패키지를 포함하는
   완비된 디렉터리 트리임

○ 가상 환경 만들기
 - 시스템에 여러 버전의 파이썬이 있는 경우, python3 또는 원하는 버전을
   실행하여 특정 파이썬 버전을 선택할 수 있음
 - 가상 환경을 만들려면, 원하는 디렉터리를 결정하고, venv 모듈을
   스크립트로 실행하는데 디렉터리 경로를 명령행 인자로 전달함
	python3 -m venv tutorial-env
 - 존재하지 않는다면 tutorial-env 디렉터리를 만들고, 그 안에
   파이썬 인터프리터의 사본, 표준 라이브러리 및 다양한 지원 
   파일이 들어있는 디렉터리들을 만듬
 - 가상 환경의 일반적인 디렉터리 위치는 .venv임
   . 이 이름은 디렉터리가 보통 셸에서 숨겨져 있도록 하므로, 디렉터리가 존재하는
     이유를 설명하는 이름을 제공하면서도 방해받지 않음
   . 일부 툴링(tooling)이 지원하는 .env 환경 변수 정의 파일과의 충돌을 방지함
 - 가상 환경을 만들었으면, 가상 환경을 활성화할 수 있음
   . 윈도우에서 이렇게 실행함
	tutorial-env\Scripts\activate.bat
   . Unix 또는 MacOS에서 이렇게 실행함
	source tutorial-env/bin/activate
 - 가상 환경을 활성화하면, 셸의 프롬프트가 변경되어 사용 중인 가상 환경을 보여
   주고, 환경을 수정하여 python을 실행하면 특정 버전의 파이썬이 실행되도록 함
	(tutorial-env) $ python
	Python 3.5.1 (default, May  6 2016, 10:59:36)
		...
	>>> import sys
	>>> sys.path
	['', '/usr/local/lib/python35.zip', ...,
	'~/envs/tutorial-env/lib/python3.5/site-packages']
	>>>

○ pip로 패키지 관리하기
 - pip 라는 프로그램을 사용하여 패키지를 설치, 업그레이드 및 제거할 수 있음
   . 기본적으로 pip 는 파이썬 패키지 색인 (Python Package Index), 
     <https://pypi.org>, 에서 패키지를 설치함
 - 웹 브라우저에서 파이썬 패키지 색인을 살펴보거나, pip의 제한된 검색 기능을 
   사용할 수 있음
	(tutorial-env) $ pip search astronomy
	skyfield               - Elegant astronomy for Python
	gary                   - Galactic astronomy and gravitational dynamics.
	novas                  - The United States Naval Observatory NOVAS astronomy library
	astroobs               - Provides astronomy ephemeris to plan telescope observations
	PyAstronomy            - A collection of astronomy related tools for Python.
	...

 - pip는 《search》, 《install》, 《uninstall》,《freeze》등 많은 부속 명령을 
   갖고 있음
 - 패키지 이름을 지정하여 최신 버전의 패키지를 설치할 수 있음
	(tutorial-env) $ pip install novas
	Collecting novas
		Downloading novas-3.1.1.3.tar.gz (136kB)
	Installing collected packages: novas
		Running setup.py install for novas
	Successfully installed novas-3.1.1.3
 - 패키지 이름 뒤에 == 과 버전 번호를 붙여 특정 버전의 패키지를 설치할 수도 있음
	(tutorial-env) $ pip install requests==2.6.0
	Collecting requests==2.6.0
		Using cached requests-2.6.0-py2.py3-none-any.whl
	Installing collected packages: requests
	Successfully installed requests-2.6.0
 - pip install --upgrade 를 실행하여 패키지를 최신 버전으로 업그레이드할 수 있음
	(tutorial-env) $ pip install --upgrade requests
	Collecting requests
	Installing collected packages: requests
		Found existing installation: requests 2.6.0
		  Uninstalling requests-2.6.0:
		    Successfully uninstalled requests-2.6.0
	Successfully installed requests-2.7.0

 - pip uninstall 다음에 하나 이상의 패키지 이름이 오면 가상 환경에서 패키지가 
   제거됨
 - pip show 는 특정 패키지에 대한 정보를 표시합니다:
	(tutorial-env) $ pip show requests
	---
	Metadata-Version: 2.0
	Name: requests
	Version: 2.7.0
	Summary: Python HTTP for Humans.
	Home-page: http://python-requests.org
	Author: Kenneth Reitz
	Author-email: me@kennethreitz.com
	License: Apache 2.0
	Location: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages
	Requires:
 - pip list는 가상 환경에 설치된 모든 패키지를 표시함
	(tutorial-env) $ pip list
	novas (3.1.1.3)
	numpy (1.9.2)
	pip (7.0.3)
	requests (2.7.0)
	setuptools (16.0)
 - pip freeze 는 설치된 패키지의 비슷한 목록을 만들지만, 
   pip install 이 기대하는 형식을 사용함
   . 일반적인 규칙은 이 목록을 requirements.txt 파일에 넣는 것임
	(tutorial-env) $ pip freeze > requirements.txt
	(tutorial-env) $ cat requirements.txt
	novas==3.1.1.3
	numpy==1.9.2
	requests==2.7.0
 - requirements.txt 는 버전 제어에 커밋되어 응용 프로그램 일부로 제공될 수 있음
   . 사용자는 install -r 로 모든 필요한 패키지를 설치할 수 있음
	(tutorial-env) $ pip install -r requirements.txt
	Collecting novas==3.1.1.3 (from -r requirements.txt (line 1))
		...
	Collecting numpy==1.9.2 (from -r requirements.txt (line 2))
		...
	Collecting requests==2.7.0 (from -r requirements.txt (line 3))
		...
	Installing collected packages: novas, numpy, requests
		Running setup.py install for novas
	Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0

○ 이제 뭘 하지?
 - https://docs.python.org/ko/3/tutorial/whatnow.html

○ 대화형 입력 편집 및 히스토리 치환
 - 일부 파이썬 인터프리터 버전은 Korn 셸 및 GNU Bash 셸에 
   있는 기능과 유사하게 현재 입력 줄 편집 및 히스토리 치환을
   지원합니다. 이는 다양한 스타일의 편집을 지원하는 GNU 
    Readline 라이브러리를 사용하여 구현됨
 - 변수와 모듈 이름의 완성은 인터프리터 시작 시 자동으로 활성화
   되어서 Tab 키가 완료 기능을 호출합니다; 파이썬 명령문 이름, 
   현재 지역 변수 및 사용 가능한 모듈 이름을 찾습니다. string.a와
   같은 점으로 구분된 표현식의 경우, 표현식을 마지막 '.' 까지 값을
   구한 다음, 결과 객체의 어트리뷰트로 완성을 제안합니다.
   __getattr__() 메서드를 가진 객체가 표현식의 일부면 응용 
   프로그램이 정의한 코드를 실행할 수 있음에 주의해야 합니다. 기본 
   설정은 사용자 디렉터리에 .python_history 라는 파일로 
   히스토리를 저장합니다. 다음 대화형 인터프리터 세션에서 
   히스토리를 다시 사용할 수 있습니다.
 - 꽤 오랫동안 사용됐던 개선된 대화형 인터프리터는 IPython 인데, 
   탭 완성, 객체 탐색 및 고급 히스토리 관리 기능을 갖추고 있습니다. 
   또한, 철저하게 커스터마이즈해서 다른 응용 프로그램에 내장할 수 
   있습니다. 비슷한 또 다른 개선된 대화형 환경은 bpython 입니다.

○ 부동 소수점 산술: 문제점 및 한계
 - 부동 소수점 숫자는 컴퓨터 하드웨어에서 밑(base)이 2인(이진) 
   소수로 표현됩니다. 
 - 예를 들어, 소수 0.125는 1/10 + 2/100 + 5/1000의 값을 가지며,
 - 같은 방식으로 이진 소수 0.001는 값 0/2 + 0/4 + 1/8을 가짐
 - 이 두 소수는 같은 값을 가지며, 유일한 차이점은 첫 번째가 밑이
   10인 분수 표기법으로 작성되었고 두 번째는 밑이 2라는 것임
 - 불행히도, 대부분의 십진 소수는 정확하게 이진 소수로 표현될 수 
   없습니다. 결과적으로, 일반적으로 입력하는 십진 부동 소수점 
   숫자가 실제로 기계에 저장될 때는 이진 부동 소수점 수로 근사 될 뿐임
 - 분수 1/3을 생각해봅시다. 이 값을 십진 소수로 근사할 수 있습니다
   0.3 또는, 더 정확하게, 0.33 또는, 더 정확하게, 0.3333 등등.
   아무리 많은 자릿수를 적어도 결과가 정확하게 1/3이 될 수 업지만,
   점점 더 1/3에 가까운 근사치가 됨
 - 같은 방식으로, 아무리 많은 자릿수의 숫자를 사용해도, 십진수 
   0.1은 이진 소수로 정확하게 표현될 수 없습니다. 이진법에서, 
   1/10은 무한히 반복되는 소수입니다
	0.0001100110011001100110011001100110011001100110011...
 - 유한 한 비트 수에서 멈추면, 근삿값을 얻게 됩니다. 오늘날 
   대부분 기계에서, float는 이진 분수로 근사 되는 데, 최상위 
   비트로부터 시작하는 53비트를 분자로 사용하고, 2의 거듭제곱
   수를 분모로 사용합니다. 1/10의 경우, 이진 분수는 
   3602879701896397 / 2 ** 55 인데, 실제 값 1/10과 거의 
   같지만 정확히 같지는 않습니다.
 - 파이썬은 기계에 저장된 이진 근삿값의 진짜 십진 값에 대한 
   십진 근삿값을 인쇄할 뿐입니다. 대부분 기계에서, 만약 
   파이썬이 0.1로 저장된 이진 근삿값의 진짜 십진 값을 출력한다면
   다음과 같이 표시해야 합니다
	>>> 0.1
	0.1000000000000000055511151231257827021181583404541015625
 - 이것은 대부분 사람이 유용하다고 생각하는 것보다 많은 숫자이므로,
   파이썬은 반올림된 값을 대신 표시하여 숫자를 다룰만하게 만듭니다
	>>>
	>>> 1 / 10
	0.1
 - 인쇄된 결과가 정확히 1/10인 것처럼 보여도, 실제 저장된 값은
   가장 가까운 표현 가능한 이진 소수임을 기억하세요.
 - 흥미롭게도, 가장 가까운 근사 이진 소수를 공유하는 여러 다른 
   십진수가 있습니다. 예를 들어, 0.1 과 0.10000000000000001 및
   0.1000000000000000055511151231257827021181583404541015625는
   모두 3602879701896397 / 2 ** 55 로 근사 됩니다. 이 십진 
   값들이 모두 같은 근삿값을 공유하기 때문에 eval(repr(x)) == x 
   불변을 그대로 유지하면서 그중 하나를 표시할 수 있습니다.
 - 역사적으로, 파이썬 프롬프트와 내장 repr() 함수는 유효 숫자
   17개의 숫자인 0.10000000000000001 을 선택합니다. 
   파이썬 3.1부터, 이제 파이썬(대부분 시스템에서)이 가장 짧은 
   것을 선택할 수 있으며, 단순히 0.1 만 표시합니다.
 - 좀 더 만족스러운 결과를 얻으려면, 문자열 포매팅을 사용하여 
   제한된 수의 유효 숫자를 생성할 수 있음
	format(math.pi, '.12g')  # give 12 significant digits
	'3.14159265359'
	>>> format(math.pi, '.2f')   # give 2 digits after the point
	'3.14'
	>>> repr(math.pi)
	'3.141592653589793'

 - 0.1은 정확히 1/10이 아니므로, 0.1의 세 개를 합한 것 역시 정확히
   0.3이 아닙니다:
	>>> .1 + .1 + .1 == .3
	False
 - 또한, 0.1은 1/10의 정확한 값에 더 가까워질 수 없고, 
   0.3도 3/10의 정확한 값에 더 가까워질 수 없으므로, 
   round() 함수로 미리 반올림하는 것은 도움이 되지 않습니다:
	>>>
	>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
	False 
   
 - 숫자를 의도한 정확한 값에 더 가깝게 만들 수는 없지만, 
   round() 함수는 사후 반올림에 유용하여 부정확한 값을 가진 결과를
   서로 비교할 수 있게 합니다:
	>>> round(.1 + .1 + .1, 10) == round(.3, 10)
	True
 - 모든 float 연산에 새로운 반올림 에러가 발생할 수 있다는 점을 명심해야 함

 - 보통 str() 만으로도 충분하며, 더 세밀하게 제어하려면 포맷 문자열
   문법에서 str.format() 메서드의 포맷 지정자를 보세요.
   정확한 십진 표현이 필요한 사용 사례의 경우, 회계 응용 프로그램 및
   고정밀 응용 프로그램에 적합한 십진 산술을 구현하는 decimal 모듈을 사용해보세요.
   정확한 산술의 또 다른 형태는 유리수를 기반으로 산술을 구현하는 
   fractions 모듈에 의해 지원됩니다 
   (따라서 1/3과 같은 숫자는 정확하게 나타낼 수 있습니다). 
 - 파이썬은 여러분이 float의 정확한 값을 진짜로 알아야 하는 드문 
   경우를 지원할 수 있는 도구들을 제공합니다. 
   float.as_integer_ratio() 메서드는 float의 값을 분수로 표현합니다:
	>>> x = 3.14159
	>>> x.as_integer_ratio()
	(3537115888337719, 1125899906842624)
 - 비율은 정확한 값이기 때문에, 원래 값을 손실 없이 다시 만드는 데 사용할 수 있습니다:
	>>> x == 3537115888337719 / 1125899906842624
	True
 - float.hex() 메서드는 float를 16진수(밑이 16이다)로 표현하는데, 
   컴퓨터에 저장된 정확한 값을 줍니다:
	>>> x.hex()
	'0x1.921f9f01b866ep+1'
 - 이 정확한 16진수 표현은 float 값을 정확하게 재구성하는 데 사용할 수 있습니다:
>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True

 - 다른 유용한 도구는 math.fsum() 함수입니다. 이 함수는 합산 동안 
   정밀도 상실을 완화합니다. 누적 합계에 값이 더해지면서 《
   잃어버린 숫자들》을 추적합니다. 최종 합계에 영향을 주는 지점까지 
   에러가 누적되지 않아서 전체적인 정확도에 차이를 만들 수 있습니다:
	sum([0.1] * 10) == 1.0
	False
	math.fsum([0.1] * 10) == 1.0
	True

 - 컴퓨터에 저장된 정확한 숫자가 십진수
   0.1000000000000000055511151231257827021181583404541015625와
   같음을 의미합니다. 전체 십진법 값을 표시하는 대신, 많은 언어
   (이전 버전의 파이썬 포함)는 결과를 17개의 유효숫자로 반올림합니다:
	>>> format(0.1, '.17f')
	'0.10000000000000001'
 - fractions 와 decimal 모듈은 이 계산을 쉽게 만듭니다:
	>>> from decimal import Decimal
	>>> from fractions import Fraction
	>>> Fraction.from_float(0.1)
	Fraction(3602879701896397, 36028797018963968)
	>>> (0.1).as_integer_ratio()
	(3602879701896397, 36028797018963968)
	>>> Decimal.from_float(0.1)
	Decimal('0.1000000000000000055511151231257827021181583404541015625')
	>>> format(Decimal.from_float(0.1), '.17')
	'0.10000000000000001'

○ 대화형 모드 에러 처리
 - 기본 또는 보조 프롬프트에 인터럽트 문자 (일반적으로 Control-C
   또는 Delete)를 입력하면 입력을 취소하고 기본 프롬프트로 돌아감
 - 명령어가 실행되는 동안 인터럽트를 입력하면 try 문에 의해 처리될
   수 있는 KeyboardInterrupt 예외가 발생함

○ 실행 가능한 파이썬 스크립트
 - BSD 스타일의 유닉스 시스템에서 파이썬 스크립트는 셸 스크립트처럼 
   직접 실행할 수 있게 만들 수 있습니다. 다음과 같은 줄
	#!/usr/bin/env python3.5
 - (인터프리터가 사용자의 PATH 에 있다고 가정할 때)을 스크립트의 시작
   부분에 넣고 파일에 실행 가능 모드를 줍니다. #! 는 반드시 파일의 처음
   두 문자여야 합니다. 일부 플랫폼에서는 이 첫 번째 줄이 유닉스 스타일의
   줄 종료 ('\n')로 끝나야 하며, 윈도우 줄 종료('\r\n')는 허락되지 않음.
   파이썬에서 해시, 또는 파운드, 문자 '#' 는 주석을 시작하는 데 사용됨
 - 스크립트는 chmod 명령을 사용하여 실행 가능한 모드, 또는 권한을 부여
   받을 수 있음
	$ chmod +x myscript.py
 - 윈도우 시스템에서는 《실행 가능 모드》라는 개념이 없습니다. 파이썬 
   설치 프로그램은 .py 파일을 python.exe``와 자동으로 연결하여, 파이썬
   파일을 이중 클릭하면 스크립트로 실행합니다. 확장자는.pyw`` 일 수도 
   있습니다. 이 경우, 일반적으로 나타나는 콘솔 창은 표시되지 않습니다.

○ 대화형 시작 파일
 - 파이썬을 대화형으로 사용할 때, 종종 인터프리터가 시작될 때마다
   실행되는 표준 명령들이 있으면 편리합니다. PYTHONSTARTUP 환경
   변수를 시작 명령이 들어있는 파일 이름으로 설정하면 됩니다. 
   이것은 유닉스 셸의 .profile 기능과 유사합니다.
 - 이 파일은 대화형 세션에서만 읽히며, 파이썬이 스크립트에서 명령을 
   읽을 때나, /dev/tty 가 명령의 명시적 소스인 경우(대화형 세션처럼
   동작한다)에는 읽지 않습니다. 대화형 명령이 실행되는 같은 이름 공간에서
   실행되므로, 이 파일에서 정의하거나 임포트하는 객체들을 대화형 세션에서
   정규화하지 않은 이름으로 사용할 수 있습니다. 이 파일에서 sys.ps1 및 
   sys.ps2 프롬프트를 변경할 수도 있습니다.
 - 현재 디렉터리에서 추가 시작 파일을 읽으려면, 전역 시작 파일에서 
   if os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read())
   와 같은 코드를 사용해서 프로그램할 수 있습니다. 
 - 스크립트에서 시작 파일을 사용하려면 스크립트에서 명시적으로 수행해야 함
	import os
	filename = os.environ.get('PYTHONSTARTUP')
	if filename and os.path.isfile(filename):
		  with open(filename) as fobj:
		      startup_file = fobj.read()
		  exec(startup_file)

○ 커스터마이제이션 모듈
 - 파이썬은 커스터마이즈할 수 있는 두 가지 훅을 제공함
 - sitecustomize 와 usercustomize.
 - 어떻게 작동하는지 보려면, 먼저 여러분의 사용자 site-packages 
   디렉터리의 위치를 찾아야 함
	>>> site.getusersitepackages()
	'/home/user/.local/lib/python3.5/site-packages'
 - 이제 그 디렉터리에 usercustomize.py 라는 이름의 파일을 만들고 원하는 것들을 
   넣을 수 있음
   . 자동 임포트를 비활성화하는 -s 옵션으로 시작하지 않는 한, 이 파일은 모든 
     파이썬 실행에 영향을 줌
 - sitecustomize 는 같은 방식으로 작동하지만, 일반적으로 전역 site-packages 
   디렉터리에 컴퓨터 관리자가 만들고, usercustomize 전에 임포트됨
