○ 외부 패키지 사용 시 문제점
 - 외부 패키지 버전 일관성 문제
 - 외부 패키지 다운로드 불가 문제

○ 개요
 - 1.13버전에서 고 모듈 지원

○ 고 모듈 이전 해결 방법
 - 벤더링 : vendor 디렉토리에 특정 버전의 외부 패키지들을 저장 시킨 뒤 빌드에 참여 시킴
 - 도커 이미지 : 도커이미지 상 GOPATH에 해당되는 경로에 미리 외부 패키지들을 저장시키면 벤더링 효과

○ 고 모듈
 - A module is a collection of Go packages stored in a file tree with a go.mod file at its root.
 - 간단히 말해 모듈은 go.mod 파일과 하위 패키지들을 포함하는 디렉토리
 - 모듈은 go.mod 파일이 없는 패키지와도 호환됨

○ 외부 모듈 버전 관리
 - 외부 모듈 경로와 버전 정보가 go.mod 파일에 기록됨
 - 이후 외부 모듈들을 다시 구성해야 할 경우가 발생하면, 이 go.mod 파일에 명시된 버전으로 모듈들을 다운로드 받게 됨

[go.mod]
module sample
go 1.13
require (
	github.com/aliyun/aliyun-oss-go-sdk v2.0.5+incompatible
	github.com/artdarek/go-unzip v0.0.0-20180315101617-33dc05190e4b
	github.com/asaskevich/govalidator v0.0.0-20200108200545-475eaeb16496
	github.com/baiyubin/aliyun-sts-go-sdk v0.0.0-20180326062324-cfa1a18b161f // indirect
	github.com/extrame/ole2 v0.0.0-20160812065207-d69429661ad7 // indirect
	github.com/go-sql-driver/mysql v1.5.0
	github.com/go-xorm/xorm v0.7.9
	github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0
	github.com/labstack/echo v3.3.10+incompatible
	github.com/pangpanglabs/echoswagger v1.1.0
	github.com/pangpanglabs/goutils v0.0.0-20200116103626-3f9fcfaa29b0
	github.com/sergeilem/xls v0.0.1
	github.com/tealeg/xlsx v1.0.5
	github.com/urfave/cli v1.22.2
	golang.org/x/image v0.0.0-20200119044424-58c23975cae1
)

○ 다운로드 할 모듈 버전 지정
 - 모듈 경로 맨 끝에 @버전을 명시하면 되며, 생략하면 @latest가 됨
 go get github.com/user/module@1.3.0
 go get github.com/user/module@latest

○ 프록시 서버
 - 외부 모듈은 프록시 서버를 통해 다운로드 됨
 - 공식 프록시 서버(https://proxy.golang.org)가 기본적으로 사용되며 설정에 따라 사설 프록시 서버 사용도 가능

○ 환경 변수
 - GO111MODULE: on | off | auto
   . 1.13버전 이후로 디렉토리에 go.mod 파일이 있으면 기본적으로 모듈 모드로 동작함
   . 1.11, 1.12 버전의 경우 디렉토리가 GOPATH에 설정한 경로 상에 위치하면 go.mod 파일이 있더라도 기본적으로 모듈 모드로 동작하지 않음
   . 이 경우 명시적으로 모듈 모드를 사용하기 위해 해당 환경 변수를 on으로 설정하면 됨
 - GOPROXY: proxy server url
   . 모듈 모드에서 외부 모듈 다운로드할 때 참조됨
   . 따로 설정하지 않으면 공식 프록시 서버(https://proxy.golang.org)로 설정됨

○ 적용 방법
 1. 프로젝트 위치로 이동

 2. go mod init [모듈 경로]으로 go.mod 파일 생성
  - 프로젝트가 GOPATH에 설정한 경로 상에 위치하면 모듈 경로 생략 가능
 - 프로젝트가 $GOPATH/src/new-module에 위치했다면 아래와 같이 기록됨
[go.mod]
1 module new-module
2 go 1.13

 3. go get 또는 go mod tidy를 통해 사용되는 외부 모듈 목록을 go.mod 파일에 기록
[go.mod]
module new-module
go 1.13
require (
	github.com/labstack/echo v3.3.10+incompatible
)
 - github.com/labstack/echo를 외부 모듈로 사용하고 있었다면 위와 같이 기록됨

 4. 위 과정을 거치면서 생성된 go.mod와 go.sum(체크섬) 파일을 커밋하여 관리

○ 모듈 적용 후 발생할 수 있는 문제
 - 공식 프록시 서버 사용 불가

 - 비모듈 모드 때와 버전 불일치
  . 만약 외부 모듈 경로에 버전이 명시되지 않으면 다운로드할 때 모드별로 상이하게 동작하게 됨
    -- 모듈 모드 : 0.1 버전 혹은 모듈이 적용되기 전 가장 최신 버전을 다운로드 함
    -- 비모듈 모드: 저장소의 기본 브랜치가 가리키는 버전을 다운로드 함

 - 모듈 모드가 동작 안함
  . 1.11, 1.12 버전일 경우 디렉토리가 GOPATH에 설정한 경로상에 위치하면 go.mod 파일이 있어도 기본적으로 비모듈 모드가 됨
  . 이 경우 명시적으로 GO111MODULE을 on으로 설정하여야 모듈 모드로 동작함
 . 공식 프록시 서버를 기본적으로 사용하지 않기 때문에 GOPROXY에 직접 프록시 서버를 지정하여야 함
GO111MODULE=on GOPROXY=https://proxy.golang.org go get
GO111MODULE=on go build
  . 만약 환경 변수를 전역으로 설정하지 않고 커맨드마다 따로 설정하려면 빌드 커맨드 앞에도 GO111MODULE를 설정해야 함

 - 벤더링 안됨
  . 비모듈 모드와는 다르게 모듈 모드에서는 빌드 옵션을 추가하여야 벤더링된 외부 모듈을 사용함
  . 일부분 모듈 벤더링이 아직 지원되지 않음
  . 벤더링을 원하면 모든 외부 모듈을 벤더링하여야 함
go mod vendor
go build -mod vendor
 . vendor 디렉토리로 모든 외부 모듈을 복사
  . 빌드할 때 -mod vendor 옵션을 붙여 벤더링된 외부 모듈을 사용

 - 로컬 모듈 사용
  . 프록시 서버를 통해 다운로드 받은 외부 모듈이 아닌 로컬 모듈을 사용해야 한다면 go.mod 파일 수정이 필요함
colleague
|-- foo
|   `-- go.mod
|   `-- xxx.go
|-- kit
|   `-- go.mod
|   `-- xxx.go
  . 예를 들어 위와 같은 디렉토리 구성에서 colleague/foo 모듈이 colleague/kit 로컬 모듈을 사용한다면
  colleague/foo 디렉토리 go.mod 파일에 replace 구문을 추가함
module colleague/foo
go 1.13
require (
    colleague/kit v0.0.0
)
replace colleague/kit => ../kit
  . 외부 모듈일 때와 다르게 로컬 모듈은 반드시 go.mod 파일을 가지고 있어야 함
  . 만약 colleague/kit 디렉토리에 go.mod 파일이 없다면 빌드할 때 go.mod 파일을 찾을 수 없다는 오류가 발생함
  . require 구문에서 로컬 모듈 버전을 명시하기 애매하다면 v0.0.0으로 지정하거나 go mod tidy를 사용하여
  자동으로 버전이 지정되도록 할 수 있음
  


○ Go modules
 - Go 1.11과 1.12에는 새로운 디펜던시 관리 시스템인 모듈(modules)의 예비 지원이 추가됨
 - 모듈은 Go의 새로운 디펜던시 관리 시스템이고, 디펜던시 버전 명시와 관리를 쉽게 할 수 있도록 도와줌
 - 모듈은, go.mod 파일을 가지고, 루트 디렉토리에 있는 파일 트리에 저장된 Go 패키지의 모음임
 - go.mod 파일은 모듈의 모듈 경로를 정의하며, 여기에서 모듈 경로는 모듈의 루트 디렉토리이기도한 import path임
 - go.mod 파일은 빌드에 필요한  각각의 디펜던시도 정의하며 각각의 디펜던시는 모듈 경로와 semantic version으로 명시됨
 - 예,
	module github.com/confluentinc/confluent-kafka-go/examples

	go 1.11

	require (
		github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 // indirect
		github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d // indirect
		gopkg.in/alecthomas/kingpin.v2 v2.2.6
		gopkg.in/confluentinc/confluent-kafka-go.v1 v1.1.0
	)
 - Go 1.11에서 작업 경로가 $GOPATH/src의 바깥이며, 작업 경로나 그 부모 경로에 go.mod 파일이 있다면 go 
   커맨드는 모듈 기능을 활성화함 (호환성을 위해 go.mod 파일이 있더라도 작업 경로가 $GOPATH/src 하위의 
   경로라면 기존의 GOPATH 모드로 작동함) 
 - Go 1.13부터는 모듈 모드가 디폴트 설정이 될 예정임

○ 새로운 모듈 만들기
 - GOPATH/src 바깥 경로에 새로운 디렉토리를 하나 만들고 hello.go 파일을 만듬
 - hello_test.go라는 이름으로 테스트 코드도 작성해줌
 - 이 시점에서 이 디렉토리에는 패키지는 있지만, 모듈은 없음. 왜냐하면 여기엔 go.mod 파일이 없기 때문임
 - 만약 현재 디렉토리가 /home/gopher/hello이고, go test를 실행한다면 다음과 같은 결과가 나올 것임
   . ok	_/home/gopher/hello	0.020s
 - 마지막 라인은 전체 패키지 테스트의 요약임(역:_로 시작하는 이상한 경로에 주목) 우리는 $GOPATH 외부에서
   작업하고 있는 데다가, 이 디렉토리는 모듈도 아닙니다. 그래서 go 커맨드는 import path를 알 수 없으므로 현재
   디렉토리 이름을 사용해 _/home/gopher/hello라는 이름의 가짜 경로를 만든 것임
 - go mod init 명령을 써서 현재 디렉토리를 모듈 루트로 만들고, go test를 다시 실행해 봄
   . $ go mod init example.com/hello 
   . ok	example.com/hello	0.020s
 - go.mod 파일은 모듈의 루트에만 만들어짐. 그리고 하위 디렉토리의 패키지들은 각자 '모듈패스 + 상대경로'로
   이루어진 import path를 자동으로 갖게 됨. 예를 들어, world라는 이름의 하위 디렉토리를 만들었다면
   world로 들어가서 go mod init 명령을 실행할 필요가 없는 것임. 각 패키지는 자동으로 example.com/hello 모듈의
   부분으로 인식되므로, 결과적으로 world의 import path는 example.com/hello/world가 됨

○ 디펜던시 추가하기
 - Go 모듈을 만든 주된 이유는 다른 개발자들이 작성한 코드를 사용하는 경험(즉, 디펜던시를 추가하는 작업)을 더 좋게
   향상시키기 위함이었음
 - 이제 우리의 hello.go를 업데이트해서 rsc.io/quote를 import하고 그것을 사용해 Hello()를 구현하는 것임
	package hello

	import "rsc.io/quote"

	func Hello() string {
	    return quote.Hello()
	}
 - 테스트를 다시 돌려 보면,
	$ go test
	go: finding rsc.io/quote v1.5.2
	go: downloading rsc.io/quote v1.5.2
	go: extracting rsc.io/quote v1.5.2
	go: finding rsc.io/sampler v1.3.0
	go: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
	go: downloading rsc.io/sampler v1.3.0
	go: extracting rsc.io/sampler v1.3.0
	go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
	go: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
	PASS
	ok      example.com/hello    0.023s
 - go 커맨드는 go.mod 파일에 나열된 디펜던시 모듈들의 버전을 참고해서 각 모듈을 가져옴
 - 만약 어떤 패키지를 가져올 때 go.mod에 명시한 버전이 없다면 go 커맨드는 자동으로 해당 패키지가 포함된 모듈의
   가장 최신 버전을 찾은 다음, go.mod에 추가함 ("Latest"는 latest 태그가 붙은 stable(non-prerelease) 버전,
   또는 latest 태그가 붙은 prerelease 버전임)
 - 우리의 예제에서, go test 명령을 실행하자 rsc.io/quote의 v1.5.2를 새롭게 다운받았음. 그리고 
   rsc.io/quote가 사용하는 rsc.io/sampler와 golang.org/x/test라는 두 개의 디펜던시도 함께
   다운로드 받았음. go.mod 파일에는 직접적인 디펜더시들(direct dependencies)만 기록됨
	$ cat go.mod
	module example.com/hello

	go 1.12

	require rsc.io/quote v1.5.2
 - 이제 go test 명령을 또 실행해 보아도, 이런 작업을 반복하지 않음. go.mod 파일이 최신판으로 갱신되었고,
   다운로드된 모듈들이 로컬($GOPATH/pkg/mod)에 캐시 되었기 때문임
 - 정확성, 보안 및 적절한 라이센싱과 같은 중요한 영역의 새로운 의존성을 고려해야 함
 - 하나의 직접적인 디펜던시를 추가하면 간접적인 디펜던시들이 여럿 추가될 수 있음
 - go list -m all 명령을 쓰면 현재 모듈과 모든 디펜던시의 목록을 보여줌
	$ go list -m all
	example.com/hello
	golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c
	rsc.io/quote v1.5.2
	rsc.io/sampler v1.3.0
 - go list 의 출력에서 첫 번째 줄은 현재 모듈을 의미함. 아랫줄부터는 모듈 경로 기준으로 정렬된 
   디펜던시 목록임
 - golang.org/x/text 오른쪽의 버전 v0.0.0-20170915032832-14c0d48ead0c는 의사 버전(pseudo-
   version)의 한 예라 할 수 있음. 이런 의사 버전은 태그가 없는 커밋에 대해 go가 붙여주는 버전 형식임
 - go 커맨드는 go.mod외에도 go.sum이라는 파일을 만들고 관리함. go.sum은 특정 버전의 모듈들의 내용으로
   만든 암호화 해시값을 갖고 있음
	$ cat go.sum
	golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZO...
	golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:Nq...
	rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3...
	rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPX...
	rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/Q...
	rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9...
 - go 커맨드는 go.sum 파일을 참고하여 처음 다운로드받은 모듈과 나중에 다운로드받는 모듈이 같은 비트를 갖는지를
   검사함. 이를 통해 악의/우연적인 이유 또는 기타 등등의 복잡한 이유로 프로젝트가 의존하는 모듈이 예상치 못하게
   변형되는 일을 방지함. 즉, go.mod와 go.sum 모두 버전 관리 도구에 체크되어야 함

○ 디펜던시 업그레이드 하기
 - Go 모듈은 semantic version 태그 형식의 버전을 참조함. semantic version은 메이저, 마이너, 패치의 세 부분으로
   구성됨. 가령, v0.1.2의 경우 메이저 버전은 0이고 마이너 버전은 1이며 패치 버전은 2임
 - 이제 golang.org/x/text의 마이너 버전 업그레이드 
 - go list -m all 명령을 실행했을 때 화면에 출력된 결과를 보면 golang.org/x/text의 untagged version을
   사용하고 있음을 알 수 있음. 이제 이것을 latest tagged version으로 업그레이드하고 잘 돌아가는지
   테스트해 봅시다.
	$ go get golang.org/x/text
	go: finding golang.org/x/text v0.3.0
	go: downloading golang.org/x/text v0.3.0
	go: extracting golang.org/x/text v0.3.0

	$ go test
	PASS
	ok      example.com/hello    0.013s
 - 잘 돌아감. go list -m all과 go.mod 파일을 다시 살펴보면,
	$ go list -m all
	example.com/hello
	golang.org/x/text v0.3.0
	rsc.io/quote v1.5.2
	rsc.io/sampler v1.3.0

	$ cat go.mod
	module example.com/hello

	go 1.12

	require (
	    golang.org/x/text v0.3.0 // indirect
	    rsc.io/quote v1.5.2
	)
 - olang.org/x/text 패키지가 latest tagged version(v0.3.0)으로 업그레이드되었습니다. 
 - go.mod 파일에도 v0.3.0으로 업데이트되었네요. // indirect 주석은 모듈이 해당 디펜던시를 직접적으로 사용하지 
   않으며, 다른 모듈 디펜던시들에 의해 간접적으로 사용되고 있음을 의미합니다. 자세한 내용은 go help modules 
   명령으로 확인해보세요.
 - 이제 rsc.io/sampler의 마이너 버전을 업그레이드
 - 앞에서와 똑같은 방법으로 go get 명령을 실행하고 테스트를 돌려 봄
	$ go get rsc.io/sampler
	go: finding rsc.io/sampler v1.99.99
	go: downloading rsc.io/sampler v1.99.99
	go: extracting rsc.io/sampler v1.99.99

	$ go test
	--- FAIL: TestHello (0.00s)
	    hello_test.go:8: Hello() = "99 bottles of beer on the wall, 99 bottles of beer, ...", want "Hello, world."
	FAIL
	exit status 1
	FAIL    example.com/hello    0.014s
 - rsc.io/sampler의 최신 버전이 우리의 코드 사용과 호환되지 않음
 - 문제가 된 모듈의 사용 가능한 tagged version 목록을 보자
	$ go list -m -versions rsc.io/sampler
	rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99
 - 우리는 v1.3.0을 쓰고 있을 때 잘 돌아가는 걸 확인했음. v1.3.1을 한번 사용해 보자
	$ go get rsc.io/sampler@v1.3.1
	go: finding rsc.io/sampler v1.3.1
	go: downloading rsc.io/sampler v1.3.1
	go: extracting rsc.io/sampler v1.3.1

	$ go test
	PASS
	ok      example.com/hello    0.022s
	$
 - go get 명령어를 사용할 때 @v1.3.1을 명시한 것에 주목하세요. 일반적으로 go get 명령어 인자에 버전을 
   명시할 수 있습니다. 기본값은 @latest이며 이 값은 최신 버전을 뜻합니다.

○ 새로운 메이저 버전을 가진 디펜던시 추가하기 
 - hello.go에 새로운 함수를 추가
	package hello

	import (
	    "rsc.io/quote"
	    quoteV3 "rsc.io/quote/v3"
	)

	func Hello() string {
	    return quote.Hello()
	}

	func Proverb() string {
	    return quoteV3.Concurrency()
	}
 - hello_test.go에 테스트 코드 추가
	func TestProverb(t *testing.T) {
	    want := "Concurrency is not parallelism."
	    if got := Proverb(); got != want {
		t.Errorf("Proverb() = %q, want %q", got, want)
	    }
	}
 - 테스트를 돌려보면,
	$ go test
	go: finding rsc.io/quote/v3 v3.1.0
	go: downloading rsc.io/quote/v3 v3.1.0
	go: extracting rsc.io/quote/v3 v3.1.0
	PASS
	ok      example.com/hello    0.024s
 - 우리 모듈이 이제 rsc.io/quote와 rsc.io/quote/v3를 디펜던시로 갖고 있음
	$ go list -m rsc.io/q...
	rsc.io/quote v1.5.2
	rsc.io/quote/v3 v3.1.0
 - Go 모듈의 주요 버전(v1, v2 등)들은 각자 다른 모듈 경로를 사용합니다. v2부터 살펴보면, 경로는 메이저 버전으로 
   끝나야 합니다. 이 예시에서 rsc.io/quote의 v3은 더 이상 rsc.io/quote가 아니라, rsc.io/quote/v3이라는 
   모듈 경로로 식별됩니다.
 - 이러한 규칙은 semantic import versioning이라 하는데, 호환되지 않는 패키지들(메이저 버전이 다르다던가)이 
   각기 다른 이름을 갖도록 하는 방법입니다.
 - 한편, rsc.io/quote의 v1.6.0은 v1.5.2와 역 호환되므로 rsc.io/quote라는 이름을 사용합니다. (이전 섹션에서 
   rsc.io/sampler v1.99.99는 v1.3.0과 역 호환이 가능해야 했을 것입니다. 그러나 버그라던가 모듈의 동작을 
   착각하고 잘못 구현하는 등의 일이 일어날 수 있습니다.)
 - go 커맨드는 빌드에 있어 특정 모듈 경로별로 최대 하나씩의 버전을 포함하는 것을 허용합니다. 이는 각 메이저 버전당 
   최대 하나의 버전을 가질 수 있음을 의미합니다. (역: 메이저 버전별로 모듈 경로의 postfix가 달라지기 때문에, 
   path 하나에 version 하나를 매핑하는 심플한 key value 규칙인 셈입니다.)
 - 예를 들면 rsc.io/quote과 rsc.io/quote/v2, rsc.io/quote/v3에 대해 각자 하나씩의 버전만 허용되는 식입니다.
 - 이 방식은 하나의 모듈 경로를 두고 일어날 수 있는 버전 중복 문제에 대한 명확한 규칙을 제공합니다. 가령, 
   rsc.io/quote를 사용하는 프로그램을 빌드할 때 rsc.io/quote v1.5.2도 쓰고 rsc.io/quote v1.6.0도 쓰는 
   것은 불가능합니다. 그러면서도 다른 메이저 버전을 허용하기 때문에(모듈 경로가 다르므로) 점진적으로 새로운 
   메이저 버전으로 업그레이드하는 것도 가능합니다.
 - 이 예제에서 우리는 rsc/quote/v3의 quote.Concurrency를 v1.5.2에서 v3.1.0으로 마이그레이션 하고 싶었지만 
   아직 준비되지 않은 상태입니다. 점진적인 마이그레이션이 가능한 것은 특히 대규모의 코드 베이스를 가진 프로그램에 
   있어 매우 중요합니다.

○ 디펜던시를 새로운 메이저 버전으로 업그레이드하기
 - 이제 rsc.io/quote를 rsc.io/quote/v3으로 컨버전하는 작업을 해 봅시다. 메이저 버전을 변경으로 인해 일부 
   API가 사라지거나 이름이 바뀌거나, 그 외의 다른 변경이 일어나는 등의 호환성 문제가 발생할 수 있음을 예상해야 
   합니다. 문서를 읽어보면, Hello가 HelloV3으로 변경된 것을 알 수 있습니다.
	$ go doc rsc.io/quote/v3
	package quote // import "rsc.io/quote"

	Package quote collects pithy sayings.

	func Concurrency() string
	func GlassV3() string
	func GoV3() string
	func HelloV3() string
	func OptV3() string 
 - 출력 결과를 보면 import path에서 /v3가 빠져 있는 버그가 있는데, 이미 알려진 버그입니다.)
 - 이제 우리는 hello.go의 quote.Hello()를 quoteV3.HelloV3()으로 업데이트할 수 있습니다.
	package hello

	import "rsc.io/quote/v3"

	func Hello() string {
	    return quote.HelloV3()
	}

	func Proverb() string {
	    return quote.Concurrency()
	}
 - 테스트를 돌려보면,
	$ go test
	PASS
	ok      example.com/hello       0.014s


○ 사용하지 않는 디펜던시 제거하기
 - 우리는 rsc.io/quote를 사용하는 코드를 모두 제거했습니다. 그러나 go list -m all 명령을 입력해보거나 
   go.mod 파일을 확인해 보면 아직 사라지지 않고 남아 있다는 것을 알 수 있습니다.
	$ go list -m all
	example.com/hello
	golang.org/x/text v0.3.0
	rsc.io/quote v1.5.2
	rsc.io/quote/v3 v3.1.0
	rsc.io/sampler v1.3.1

	$ cat go.mod
	module example.com/hello

	go 1.12

	require (
	    golang.org/x/text v0.3.0 // indirect
	    rsc.io/quote v1.5.2
	    rsc.io/quote/v3 v3.0.0
	    rsc.io/sampler v1.3.1 // indirect
	)
 - 왜 그럴까요? go build나 go test와 같은 명령으로 싱글 패키지를 빌드해보면, 뭔가 빠졌다던가 뭔가 추가해야 
   한다든가 하는 것들은 쉽게 알아낼 수 있습니다. 그러나 무언가가 없어도 된다고 말하는 것은 어려운 일입니다. 
   디펜던시 제거는 모듈의 모든 패키지를 체크하고, 해당 패키지의 가능한 모든 빌드 태그 조합을 확인한 후에나 
   할 수 있는 일입니다. 일반적인 빌드 명령은 이러한 정보를 로드하지 않으므로 디펜던시를 안전하게 제거할 수 없습니다.
 - go mod tidy 명령은 다음과 같이 사용하지 않는 디펜던시를 제거합니다.
	$ go mod tidy
	$ go list -m all
	example.com/hello
	golang.org/x/text v0.3.0
	rsc.io/quote/v3 v3.1.0
	rsc.io/sampler v1.3.1
	
	$ cat go.mod
	module example.com/hello

	go 1.12

	require (
	    golang.org/x/text v0.3.0 // indirect
	    rsc.io/quote/v3 v3.1.0
	    rsc.io/sampler v1.3.1 // indirect
	)

	$ go test
	PASS
	ok      example.com/hello    0.020s

○ 결론
 - Go 모듈은 Go의 디펜던시 관리의 미래입니다. 모듈 기능은 현재 지원되는 모든 Go 버전(Go 1.11, 1.12)에서 
   사용할 수 있습니다.
 - 이 포스트는 Go 모듈을 사용하는 작업 흐름을 소개하였습니다.
   . go mod init은 새로운 모듈을 생성하고, 모듈을 설명하는 go.mod 파일을 초기화합니다.
   . go build와 go test, 그 외의 패키지 빌드 커맨드들은 필요에 따라 go.mod에 새로운 디펜던시를 추가합니다.
   . go list -m all은 현재 모듈의 디펜던시 목록을 보여줍니다.
   . go get은 필요한 버전의 디펜던시를 변경하거나 새로운 디펜던시를 추가합니다.
   . go mod tidy는 사용하지 않는 디펜던시를 제거합니다.
 - 당신의 로컬 개발 환경에서 모듈 사용을 시작한다면 go.mod와 go.sum를 당신의 프로젝트에 추가하세요. 
