sds 5 : admin1234

[docker 불편]
 - 장황한 옵션
 - 앱 컨테이너와 데이터베이스 컨테이너의 실행 순서

[docker-compose 설치]
○ download
 - $ sudo curl -L "https://github.com/docker/compose/releases/download/1.25.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
○ apply executable permission
 - $ sudo chmod +x /usr/local/bin/docker-compose
 - $ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose (선택사항임)
 - $ docker-compose --version

[docker-compose로 개발 환경 구성하기]
○ 선행 조건
 - docker 엔진의 버전이 1.13.1 이상이어야 하고  -> 192.168.1.217 docker version : 19.03.5
 - docker-compolse 버전은 1.6.0 이상이어야 함   -> 192.168.1.217 docker-compose version : 1.25.0 
 
○ docker-compose.yml 파일
 - docker-compose.yml은 장황한 docker 실행 옵션을 미리 적어둔 문서라고 볼 수 있음
 - 프로젝트 루트에 파일을 만듬

version: '2.1'

services:
  db:
    image: postgres:9.6.1
    volumes:
      - ./docker/data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=sampledb
      - POSTGRES_USER=sampleuser
      - POSTGRES_PASSWORD=samplesecret
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8
    healthcheck:
      test: "pg_isready -h localhost -p 5432 -q -U postgres"
      interval: 3s
      timeout: 1s
      retries: 10

  django:
    build:
      context: .
      dockerfile: ./compose/django/Dockerfile-dev
    environment:
      - DJANGO_DEBUG=True
      - DJANGO_DB_HOST=db
      - DJANGO_DB_PORT=5432
      - DJANGO_DB_NAME=sampledb
      - DJANGO_DB_USERNAME=sampleuser
      - DJANGO_DB_PASSWORD=samplesecret
      - DJANGO_SECRET_KEY=dev_secret_key
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
    links:
      - db
    command: /start-dev.sh
    volumes:
      - ./:/app/ 
      
 - version
   . docker-compose.yml 파일의 첫 줄에는 파일 규격 버전을 적음
   . 파일의 규격에 따라 지원하는 옵션이 달라지는데, '3'이라고 적으면 3으로 시작하는 최신 버전을 사용한다는 의미가 아니고 0을 default로 3.0을 사용한다는 의미
   . 개발서버 docker버전 18.09.7, 테스트서버 docker버전 18.06.3-ce
   . compose file format 3.7 : docker engine release 18.06.0+
 - services
   . 실행하려는 컨테이너들을 정의함, compose에서는 container 대신 service라는 개념을 사용함
 - image
   . 서비스에서 사용할 docker image
 - volumes
   . docker run으로 container를 실행할 때 --volume 옵션을 사용하는 것과 같음
   . 다만 docker-compose.yml의 volumes에는 상대 경로를 지정할 수 있어 편리함
 - environment
   . docker run 명령의 -e 옵션에 적었던 내용과 동일
 - build
   . build 옵션
   . context는 docker build 명령을 실행할 디렉토리 경로
   . dockerfile은 빌드할 때 사용할 Dockerfile을 지정
 - ports
   . docker run 명령의 -p 옵션과 동일
 - command
   . docker run으로 실행할 때 가장 마지막에 적었던 명령어 부분
 - links
   . 도커 컴포즈 파일 버전 3으로 와서는 links 항목을 사용하지 않더라도 한 네트워크 안에 있는 서비스끼리 서로 통신을 할 수 있음
   . docker-compose.yml 안에 있는 서비스들은 별도로 지정하지 않으면 하나의 네트워크에 속함



[docker-compose의 주요 명령어]
○ up -d
 - docker-compose.yml 파일의 내용에 따라 이미지를 빌드하고 서비스를 실행함
 - 진행 과정   
   . 서비스를 띄울 네트워크 설정
   . 필요한 볼륨 생성(혹은 이미 존재하는 볼륨과 연결)
   . 필요한 이미지 풀(pull)
   . 필요한 이미지 빌드(build)
   . 서비스 의존성에 따라 서비스 실행 
 - 옵션
   . -d: 서비스 실행 후 콘솔로 빠져나옴 (docker run에서의 -d와 같음)
   . --force-recreate: 컨테이너를 지우고 새로 만듬
   . --build: 서비스 시작 전 이미지를 새로 만듬
                
○ ps
 - 현재 환경에서 실행 중인 각 서비스의 상태를 보여줌
 - $ docker-compose ps
 
○ stop, start
 - 서비스를 멈추거나, 멈춰있는 서비스를 시작
 - $ docker-compose stop 
 - $ docker-compose start
 
○ down
 - 서비스를 지움
 - 컨테이너와 네트워크를 삭제하며, 옵션에 따라 볼률도 지움
 - $ docker-compose down --volume
 - --volume: 볼륨까지 삭제함
     
○ exec
 - 실행중인 컨테이너에서 명령어를 실행함
 - 자동화된 마이그레이션용 파일 생성이나 유닛 테스트, lint 등을 실행할 때 사용함
 - 비슷한 명령으로 run이 존재함, run은 새 컨테이너를 만들어서 명령어를 실행함,
   docker run과 마찬가지로 --rm 옵션을 추가하지 않으면, 컨테이너가 종료된 후에도 삭제되지 않음,
   (이런 이유 때문에 개인적으로는 exec를 선호하지만, 컨테이너에서 추천하는 방식은 사실 run임)
 - $ docker-compose exec node npm run test

○ logs
 - 서비스의 로그를 확인할 수 있음
 - logs 뒤에 서비스 이름을 적지 않으면 도커 컴포즈가 관리하는 모든 서비스의 로그를 함께 보여줌
 - -f: 지금까지 쌓인 로그를 다 보여준 후에도 셀로 빠져나오지 않고, 로그가 쌓일 때마다 계속해서 출력함
  

[참고]
 - yaml의 list 표현
   . key: 
       - item1
       - item2
   . 또는
   . key: [
       item1, item2
     ]             
 - yaml의 text 표현
   . | 은 줄바꿈을 포함하고, > 는 줄바꿈을 무시함

   
 - 외부에서 컨테이너 안의 명령 실행하기
  . docker exec 명령어로 컨테이너 밖에서 컨테이너 안의 명령을 실행할 수 있음
  . $ docker exec <container name> <command>
    ex) docker exec snowdeer_docker echo "Hello, SnowDeer"
 - 현재 실행중인 컨테이너에 접속하기
   . docker attach 명령어로 현재 실행중인 컨테이너에 접속할 수 있음
   . $ docker attach <container name>
   
          
[팁]
○ docker-compose.yml 파일을 수정했다면
 - docker-compose.yml 파일을 수정하고 이를 서비스에 적용하려면 서비스를 멈추고(stop), 서비스를 지우고(rm), 서비스를 시작해야(up) 함
 - 하지만 up 명령만 실행해도, (현재 실행중인 서비스 설정과 달라진 부분이 있다면) 알아서 컨테이너를 재생성하고 서비스를 재시작해줌
 - $ docker-compose up -d [서비스_이름]
 - 혹시 컨테이너를 재생성하지 않는 것 같다면, --force-recreate 옵션을 붙이면 됨
○ Dockerfile 파일을 수정했다면
 - Dockerfile 파일을 수정했을 땐 build 명령을 사용하여 docker image를 새로 만들고 서비스 중지와 삭제 , 재시작을 해야함
 - 하지만 up 명령에 다음과 같이 --build  옵션을 넣으면 알아서 이미지를 새로 만들고 서비스를 재시작함
 - $ docker-compose up -d --build [서비스_이름]
     
○ [ERROR: 'No space left on device'
 - 위와 같은 메시지가 뜨면서 새 이미지를 빌드할 수 없는 경우가 발생함
 - 하드디스크에 용량이 엄청 많이 남아 있었는데도 말이죠. 이는 도커에서 사용하는 가상 파일 시스템의 기본 최대값이 64기가바이트여서 발생하는 문제
 - 주의! 다음 내용을 진행하면 도커 이미지와 컨테이너, 볼륨이 모두 사라짐
 - 이 경우 도커의 환경설정에서 Reset disk image 버튼을 누르면 해결됨


[Scale]
 - $ docker-compose up -d --scale service1=5 --scale service2=6 

[Multiple brokers]
 - $ docker-compose up --scale kafka=3
 - services:
     kafka:
       ports:
         - "9092-9094:9092"


○ Docker Compose Network
 - 기본적으로 Docker Compose는 하나의 디폴트 네트워크에 모든 컨테이너를 연결함
 - 디폴트 네트워크의 이름은 docker-compose.yml가 위치한 디렉토리 이름 뒤에 
   _default가 붙음.  예를 들어, 디렉토리 이름이 our_app라면 디폴트 네트워크 
   이름은 our_app_default가 됨
 - 디폴트 네트워크의 이름은 Docker Compose로 애플리케이션을 올릴 때 어렵지 않게
   확인할 수 있음. 왜냐하면 Compose는 먼저 네트워크를 생성해놓고 각 컨테이너를 
   구동한 후 네트워크에 연결시키기 때문임
 - Docker Compose로 애플리케이션을 내릴 때는 반대 순서로 먼저 컨테이너를 
   종료/제거해놓고 제일 마지막에 네트워크를 제거함
 - 애플리케이션이 돌아가고 있는 중에도 Docker 네트워크 목록을 조회하면 디폴트
   네트워크가 확인됨
   $ docker network ls   

○ 컨테이너간 통신
 - 디폴트 네트워크 안에서 컨테이너 간의 통신에서는 서비스의 이름이 호스트명으로 
   사용됨. 예를 들어, web 서비스의 컨테이너에서 db 서비스의 컨테이너를 대상으로 
   ping 명령어를 날릴 수 있음
   $ docker-compose exec web ping db 또는 $ docker exec web ping db
 - 컨테이넌 간 통신에서 주의할 점은 접속하는 위치가 디폴트 네트워크 내부냐 
   외부냐에 따라서 포트(port)가 달라질 수 있음
   . docker-compose.yml에 web 서비스의 ports 설정이 아래와 같다면,
     services:
       web:
         build: .
         ports:
           - "8001:8000"
   . 호스트 컴퓨터에서 접속할 때는 8001 포트를 사용해야 하고, 같은 디폴트 네트워크
     내의 다른 컨테이너에서 접속할 때는 포트 8000을 사용해야 함
     $ curl -I localhost:8001
     $ docker-compose exec alpine curl -I web:8000

○ 커스텀 네트워크 추가
 - Docker Compose는 디플트 네트워크 뿐만 아니라 다른 네트워크도 필요에 따라 
   추가해줄 수 있음
 - docker-compose.yml의 networks 항목 아래에 our_net이라는 네트워크를 추가하고, 
   web 서비스의 networks 항목 아래에 our_net 네트워크를 추가
 - 이렇게 설정을 하게되면 db 서비스는 디폴트 네트워크에만 연결되지만, web 
   서비스는 디폴트 네트워크 뿐만 아니라 our_net 네트워크에도 연결되게 됨
services:
  web:
    build: .
    ports:
      - "8000:8000"
    networks:
      - default
      - our_net

  db:
    image: postgres
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres

networks:
  our_net:
    driver: bridge

 - out_new은 Docker Compose 내부에서 정의된 네트워크이므로 애플리케이션을 내릴 
   때 디폴트 네트워크와 함께 삭제됨

○ 외부 네트워크 사용
 - Docker Compose가 제공하는 디폴트 네트워크 대신에 외부에서 미리 생성해놓은 
   다른 네트워크를 사용할 수도 있음
 - 먼저 our_net이라는 네트워크를 별도로 생성
   $ docker network create out_new
 - docker-compose.yml에서 default 네트워크의 external 옵션에 our_net을 설정함
networks:
  default:
    external:
      name: our_net
 - Docker Compose로 애프리케이션을 올리고, our_net 네트워크의 상세 정보를 
  확인해보면 Containers 항목에 두 개의 컨테이너가 연결된 것을 볼 수 있음
  $ docker-compose up -d
  $ docker network inspect our_net
 - 외부에서 생성된 네트워크이므로 Docker Compose 애플리케이션을 내릴 때 해당 
   네트워크가 함께 삭제되지 않음
$ docker-compose down
Stopping our_app_web_1 ... done
Stopping our_app_db_1  ... done
Removing our_app_web_1 ... done
Removing our_app_db_1  ... done
Network our_net is external, skipping

 - 외부 네트워크를 잘 활용하면 서로 다른 Docker Compose에서 돌아가고 있는 
   컨테이너 간에도 연결도 가능하게 됨. 예를 들어, 첫 번째 Docker Compose의 
   디폴트 네트워크를 두 번째 Docker Compose의 커스텀 네트워크로 추가해주면, 
   두 번째 Docker Compose 내의 컨테이너도 첫 번째 Docker Compose의 디폴트 
   네트워크에 연결될 수 있음


   

   
    
