○ 이름에 의한 호출 파라미터
 - 이름에 의한 호출을 이용하려면 () => 대신 =>를 사용하면 됨
 - 빈 파라미터 목록인 ()를 생략할 수 있는 이름에 의한 호출 파라미터 타입은
   파라미터에서만 사용할 수 있음
 - 이름으로 전달하는 변수, 이름으로 전달하는 필드는 존재하지 않음
 - 값이 파라미터로 전달될 때 평가되지 않고, 실제로 call이 될 때 평가
 - 이런 식으로 이름에 의한 호출이나 지연 계산 등을 처리해주기 위해 컴파일러가
   프로그래머 대신 만들어주는 도우미 함수를 썽크(thunk)라고 부름
  

○ 파라미터 없는 메소드
 - 어떤 메소드가 인자도 받지 않고 
 - 그 메소드가 속한 객체의 필드를 읽는 방식으로만 변경 가능한 상태에 접근하는 경우
 - (객체의 상태를 변경하지 않는 경우) 파라미터 없는 메소드를 사용
 - 스칼라에서는 파라미터 없는 메소드와 빈 괄호 메소드를 자유롭게 섞어 쓸 수 있게 했음
 - 파라미터 없는 메소드를 빈 괄호 메소드로 오버라이드할 수 있고 그 반대도 가능
 - 인자가 필요하지 않다면 메소드 호출 시 빈 괄호를 아예 생략할 수도 있음
 
○ 자바 4가지 네임스페이스
 - 필드, 메소드, 타입, 패키지

○ 스칼라 2가지 네임스페이스
 - 값(필드, 메소드, 패키지, 싱글톤 객체) 
 - 타입(클래스, 트레이트 이름)  
 ※ 스칼라가 필드와 메소드를 동일한 네임스페이스로 취급하는 이유는 
    파라미터 없는 메소드를 val로 오버라이드하기 위함
 ※ 스칼라에서 패키지도 필드와 메소드와 같은 네임스페이스를 공유하는 이유는
    타입을 임포트하는 것은 물론 싱글톤 객체의 필드와 메소드를 임포트할 수 있게 하기 위함
        
○ 슈퍼클래스의 생성자 호출  
 - 원하는 인자를 슈퍼클래스 이름 뒤에 괄호로 묶어서 넘기면 됨
class LineElement(s: String) extends ArrayElement(Array(s)) {
  override def width = s.length
  override def height = 1
}

○ override 수식자
 - 스칼라에서는 부모 클래스에 있는 구체적(concrete) 멤버를 오버라이드하는 모든 
   멤버에 override 수식자를 붙여야 함
 - 하지만 추상 멤버를 구현할 경우에는 override 수식자를 생략할 수 있음
 - 기반 클래스에 있는 멤버를 오버라이드하거나 구현하는 경우가 아니라면 override
   수식자를 사용해서는 안됨

○ final 멤버 선언
 - 서브클래스가 특정 멤버를 오버라이드하지 못하게 막고 싶을 때 사용
 - final 수식자를 클래스 선언 앞에 추가하면 클래스 전체를 서브클래싱 불가능하게 만듬

○ 스칼라 배열
 - 스칼라의 배열은 시퀀스 구조를 나타내는 scala.Seq 클래스의 인스턴스로 변환 가능

○ zip 연산자
 - zip 연산자는 두 인자에서 차례로 대응하는 원소들을 추출해 순서쌍의 배열을 만듬
 - Array(1, 2, 3) zip Array("a", "b") --> Array((1, "a"), (2, "b"))
 - 두 배열 중 하나가 다른 배열보다 길이가 길면, 나머지 원소를 생략함
 
○ 팩토리 객체
 - 팩토리 객체는 다른 객체를 생성하는 메소드를 제공하는 객체

○ Any
 - 스칼라 클래스 계층의 최상위 클래스
 - 메소드
   . final def ==(that: Any): Boolean
   . final def !=(that: Any): Boolean
   . def equals(that: Any): Boolean
   . def ##: Int
   . def hashCode: Int
   . def toString: String

○ AnyVal
 - Any의 서브클래스인 AnyVal은 모든 스칼라 값 클래스의 부모 클래스임
 - Byte, Short, Char, Int, Long, Float, Double, Boolean, Unit
 - 앞 8개 클래스의 인스턴스는 모두 스칼라에서 리터럴을 사용해 만들 수 있음
 - 이들 클래스는 new를 사용해 인스턴스화할 수 없음
 - 모든 값 클래스를 추상 클래스인 동시에 final 클래스로 만드는 '속임수'를 사용해
   이런 제약을 가했음
 - Unit은 자바의 void 타입과 비슷
 - Unit에는 인스턴스 값이 하나뿐이고 그 값은 ()라고 씀
 - 값 클래스 타입 간에 암시적 변환이 자동으로 제공됨
   
○ AnyRef
 - java.lang.Object에 별명을 붙인 것에 지나지 않음

○ Int
 - 스칼라는 정수가 (자바) 객체여야 하는 경우 '백업' 클래스인 java.lnag.Integer를 사용함
 - 정수에 대해 toString 같은 메소드를 호출하거나 Any 타입의 변수에 정수를 할당하는 경우

○ ==
 - 스칼라의 동일성 연산 ==는 타입의 표현과 관계없이 투명하게 동작
 - 값 타입의 경우, 자연적인 동일성임
 - 참조 타입의 경우, Object에서 상속한 equals 메소드의 별명임
 - 대부분의 서브클래스는 자기 클래스에 가장 자연스러운 동일성을 표현할 수 있도록
   이를 오버라이드함
 - AnyRef에는 오버라이드할 수 없고, 참조 동일성을 사용하게 만들어준 eq라는 메소드가 있음
   
○ Null 클래스
 - null 참조의 타입
 - 모든 참조 타입(AnRef를 상속한 모든 클래스)의 서브클래스
 - Null은 값 타입과는 호환성이 없음(null을 정수 타입의 변수에 할당할 수 없음)
   . val i: Int = null (오류)

○ Nothing 클래스
 - 다른 모든 타입의 서브타입
 - 이 타입의 값은 존재하지 않음
 
○ 값 클래스 정의
 - 파라미터를 오직 하나만 취하며
 - def들을 제외한 어떤 필드도 내부에 없애야 함
 - 값 클래스를 확장할 수 없고
 - 값 클래스가 equals나 hashCode를 재정의할 수도 없음

○ 믹스인
 - trait를 믹스인할 때에는 extends 키워드를 사용
 - extends를 사용하면 트레이트의 슈퍼클래스를 암시적으로 상속함
 - 트레이트에서 물려받은 메소드는 부모 클래스에서 물려받은 경우와 같이 사용 가능

○ 트레이트와 클래스의 차이점
 - 트레이트는 클래스 파라미터를 가질 수 없음
 - 클래스에서는 super 호출을 정적으로 바인딩하지만, 트레이트에서는 동적으로 바인딩
   . 트레이트를 클래스 구현에 믹스인할 때마다 새로 정해짐
   . 쌓을 수 있는 변경이 가능


   
○ _root_ 패키지
 - 스칼라는 사용자가 작성한 모든 패키지 외부에 존재하는 _root_ 패키지를 제공
 - 모든 최상위 패키지는 _root_ 패키지의 멤버
 
○ 임포트
 - 스칼라에서 패키지와 그 멤버는 import 절을 통해 불러올 수 있음
 - 임포트한 항목은 java.io.File 같이 완전한 이름 대신 File 같은 단순한 이름을 
   사용해 접근할 수 있음 
 - 자바의 주민식 임포트는 별표(*)를 사용하지만 스칼라에서는 밑줄(_)을 사용함
   import bobsdelights._
 - 스칼라 임포트는 컴파일 단위의 시작 부분뿐만아니라 코드의 어디에라도 들어갈 수 있음
 - 또한 임의의 값을 임포트할 수도 있음
   def showFruit(fruit: Fruit) = {
     import fruit._
     println(name, + "s are " + color)
   }
 - 패키지뿐만 아니라 (싱글톤 또는 일반) 객체도 참조할 수 있음
 - 불러온 멤버 이름을 숨기거나 다른 이름을 지정할 수 있음
 - import Fruits.{Apple, Orange}
 - import Fruits.{Apple => McIntosh, Orange}
 - import Fruits.{_} 는 import Fruits._ 와 동일
 - import Fruits.{Apple => McIntosh, _} Fruits 객체의 모든 멤버를 불러오나, Apple의 이름을 바꿈
 - import Fruits.{Pear => _, _} Fruits에서 Pear를 제외한 모든 멤버를 불러옴
 - 간단한 임포트 절은 셀렉터가 있는 임포트를 특별히 줄인 것으로 생각할 수 있음
   . import p._ 은 import.p.{_}
   . import p.n 은 import.p.{n} 
   
○ 암시적 임포트
 - 스칼라는 모든 프로그램에 몇 가지 임포트를 항상 추가함
 - 실질적으로 세 가지 임포트 절을 모든 스칼라 소스 맨 위쪽에 추가하는 것과 같음
   . import java.lang._ // java.lang 패키지에서 모든 것 불러오기
   . import scala._     // scala 패키지에서 모든 것 불러오기
   . import Predef._    // Predef 객체에서 모든 것 불러오기
 ※ 스칼라는 원래는 닷넷(.NET)에서 구현됐다. 닷넷에서는 java.lang 패키지와
    유사한 닷넷의 System 네임스페이스(namespace)가 그 대신 임포트됐음
 - scala 패키지에는 많이 사용하는 클래스 및 객체와 표준 스칼라 라이브러리가 들어 있음
 - Predef 객체는 타입, 메소드, 그리고 스칼라 프로그램에서 일반적으로 사용하는 암시적
   변환을 포함함
 - 스칼라는 나중에 임포트한 패키지가 더 앞에서 임포트한 것을 가림
   . 예를 들어, StringBuilder 클래스는 scala 패키지와 java.lang 패키지에 모두 들어 있음
   . 더 뒤에 임포트한 scala 패키지가 더 앞에 있는 java.lang 임포트를 가리기 때문에,
   . 단순히 StringBuilder만 사용하면 java.lang.StringBuilder가 아니라 scala.StringBuilder를 가리킴
          
○ private 접근 수식자
 - private가 앞에 붙은 멤버는 오직 그 정의를 포함한 클래스나 객체 내부에서만 접근할 수 있음
 - 이 규칙을 내부 클래스에도 똑같이 적용함
 - 자바였다면, 외부 클래스가 자신의 내부 클래스에 있는 비공개 멤버에 접근 가능
  
○ protected 접근 수식자
 - 스칼라에서는 보호 멤버를 정의한 클래스의 서브클래스에서만 그 멤버에 접근할 수 있음
 - 자바에서는 어떤 클래스의 보호 멤버에 그 클래스와 같은 패키지 안에 있는 다른 클래스들도
   접근할 수 있음

○ 공개 멤버
 - private나 protected가 없는 멤버는 모두 공개 멤버
 - 공개 멤버를 위한 수식자는 없음
 - 공개 멤버는 어디에서나 접근 가능

○ 보호 스코프
 - private[X] : X 패키지 내부에 있는 모든 객체와 클래스에서 접근 가능
 - protected[X] : protected[X] 수식자가 C 클래스 안에 있다면, C의 모든 서브클래스 내부와
                  더불어 X(C를 둘러싼 X라는 이름의 패키지이거나, X라는 이름의 클래스나 객체)
                  의 내부에서도 접근 가능
 - privtate[this] : object-private, 그 정의를 포함하는 클래스 및 객체 내부에서만 접근이 가능
   . class Navigator {
       private[this] var speed = 200
       ...
     }
    . 다음과 같은 코드가 Navigator 클래스 안에 있다고 해도 이런 접근은 불가능
      val other = new Navigator
      other.speed // 이 줄은 컴파일 불가능
      
○ 가시성과 동반 객체
 - 스칼라에 정적 멤버가 없고, 대신 여러 멤버를 포함하며 단 하나만 존재하는 동반 객체
   (companion object)가 있음
 - 스칼라 접근 규칙은 비공개(private) 또는 보호(protected) 접근에 대해 동반 객체와
   클래스에 동일한 권리를 줌
 - 싱글톤 객체의 서브클래스를 만들 수가 없으므로 동반 객체안에서 보호(protected) 
   멤버를 선언하는 것은 말도 안됨
 ※ 어떤 싱글톤 객체의 이름이 어떤 클래스와 같을 때, 그 객체를 클래스의 동반 객체라고 함
    해당 클래스는 싱글톤 객체의 동반 클래스라고 부름

○ 패키지 객체
 - 스칼라는 패키지 객체 내부에 있는 모든 정의를 패키지 자체에 속한 멤버로 취급
 - 패키지 내에서 사용할 타입 별명(type alias)과 암시적 변환(implickt conversion)을 넣기 위해 사용
 - 패키지 객체는 package.class라는 이름의 클래스 파일로 컴파일되는데, 그 클래스 파일은 패키지
   클래스와 대응하는 패키지 디렉토리에 들어감
 - 이 관례를 소스 파일에도 사용하는 것이 좋음, 그래서 package.scala 파일에 패키지 객체 저장함
     
 
 





   

     



    
